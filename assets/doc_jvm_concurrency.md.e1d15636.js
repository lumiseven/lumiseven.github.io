import{_ as e,c as t,o as i,b as r}from"./app.24f9d2a9.js";const k=JSON.parse('{"title":"Java 并发编程","description":"","frontmatter":{},"headers":[],"relativePath":"doc/jvm/concurrency.md","lastUpdated":1678380645000}'),o={name:"doc/jvm/concurrency.md"},l=r('<h1 id="java-并发编程" tabindex="-1">Java 并发编程 <a class="header-anchor" href="#java-并发编程" aria-hidden="true">#</a></h1><h2 id="要点总结" tabindex="-1">要点总结 <a class="header-anchor" href="#要点总结" aria-hidden="true">#</a></h2><ul><li>Java 并发基础：了解并发的概念、原理、优势和挑战，掌握线程的创建、启动、状态转换和终止，理解并发关键字（volatile，final，synchronized）的作用和使用场景。</li><li>J.U.C框架：学习 Java 提供的并发工具类，包括 <strong>Lock 框架（ReentrantLock，ReadWriteLock等）</strong>、<strong>Tools 类（CountDownLatch，CyclicBarrier等）</strong>、<strong>Collections 类（ConcurrentHashMap，CopyOnWriteArrayList等）</strong>、**Atomic 类（AtomicInteger，AtomicReference等）**和 <strong>Executors 类（ThreadPoolExecutor，ScheduledExecutorService等）</strong>。</li><li>并发问题与优化：掌握常见的并发问题（死锁、活锁、饥饿、内存可见性、竞态条件等）的原因和解决方法，学习如何使用线程安全策略（不可变性、同步、锁分离等）、设计模式（单例模式、生产者消费者模式等）和测试工具（JMeter，VisualVM等）来优化并发程序。</li></ul><h2 id="常见的并发原因和解决方法" tabindex="-1"><a href="./concurrency2">常见的并发原因和解决方法</a> <a class="header-anchor" href="#常见的并发原因和解决方法" aria-hidden="true">#</a></h2><h2 id="并发工具类" tabindex="-1">并发工具类 <a class="header-anchor" href="#并发工具类" aria-hidden="true">#</a></h2><ol><li>常用的并发工具类 <ul><li><code>CountDownLatch</code> CountDownLatch 类位于java.util.concurrent包下,利用它可以实现类似计数器的功能。比如有一个任务A,它要等待其他3个任务执行完毕之后才能执行,此时就可以利用CountDownLatch来实现这种功能了。</li><li><code>CyclicBarrier</code>(回环栅栏) CyclicBarrier它的作用就是会<code>让所有线程都等待完成后才会继续下一步行动</code>。 CyclicBarrier初始化时规定一个数目,然后计算调用了CyclicBarrier.await()进入等待的线程数。当线程数达到了这个数目时,所有进入等待状态的线程被唤醒并继续。CyclicBarrier初始时还可带一个Runnable的参数, 此Runnable任务在CyclicBarrier的数目达到后,所有其它线程被唤醒前被执行。</li><li><code>Semaphore</code> (信号量) Semaphore 是 synchronized 的加强版,作用是<code>控制线程的并发数量</code>(允许自定义多少线程同时访问)。就这一点而言,单纯的synchronized 关键字是实现不了的。</li></ul></li></ol><h2 id="并发队列" tabindex="-1">并发队列 <a class="header-anchor" href="#并发队列" aria-hidden="true">#</a></h2><ol><li><p>什么是并发队列</p><ul><li>消息队列很多人知道:消息队列是分布式系统中重要的组件,是系统与系统直接的通信</li><li>并发队列是什么:并发队列多个线程以有次序共享数据的重要组件</li></ul></li><li><p>并发队列和并发集合的区别:</p><ul><li>队列遵循“先进先出”的规则,可以想象成排队检票,队列一般用来解决大数据量采集处理和显示的。</li><li>并发集合就是在多个线程中共享数据的</li></ul></li><li><p>怎么判断并发队列是阻塞队列还是非阻塞队列 在并发队列上JDK提供了Queue接口,一个是以Queue接口下的BlockingQueue接口为代表的阻塞队列,另一个是高性能(无堵塞)队列。</p></li><li><p>阻塞队列和非阻塞队列区别</p><ul><li>当队列阻塞队列为空的时,从队列中获取元素的操作将会被阻塞。</li><li>或者当阻塞队列是满时,往队列里添加元素的操作会被阻塞。</li><li>或者试图从空的阻塞队列中获取元素的线程将会被阻塞,直到其他的线程往空的队列插入新的元素。</li><li>试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞,直到其他的线程使队列重新变得空闲起来</li></ul></li><li><p>常用并发列队的介绍</p><ol><li>非堵塞队列: <ul><li>ArrayDeque, (数组双端队列) ArrayDeque (非堵塞队列)是JDK容器中的一个双端队列实现,内部使用<code>数组进行元素存储</code>,不允许存储null值,可以高效的进行元素查找和尾部插入取出,是用作队列、双端队列、栈的绝佳选择,性能比LinkedList还要好。</li><li>PriorityQueue, (优先级队列) PriorityQueue (非堵塞队列) 一个<code>基于优先级的无界优先级队列</code>。优先级队列的元素按照其自然顺序进行排序,或者根据构造队列时提供的 Comparator 进行排序,具体取决于所使用的构造方法。该队列不允许使用 null 元素也不允许插入不可比较的对象</li><li>ConcurrentLinkedQueue, (基于链表的并发队列) ConcurrentLinkedQueue (非堵塞队列): 是一个适用于<code>高并发场景下的队列,通过无锁的方式,实现了高并发状态下的高性能。</code>ConcurrentLinkedQueue的性能要好于BlockingQueue接口,它是一个基于链接节点的无界线程安全队列。该队列的元素遵循先进先出的原则。该队列不允许null元素。</li></ul></li><li>堵塞队列: <ul><li>DelayQueue, (基于<code>时间优先级</code>的队列,延期阻塞队列) DelayQueue是一个没有边界BlockingQueue实现,加入其中的元素必需实现Delayed接口。当生产者线程调用put之类的方法加入元素时,会触发Delayed接口中的compareTo方法进行排序,也就是说队列中元素的顺序是按到期时间排序的,而非它们进入队列的顺序。排在队列头部的元素是最早到期的,越往后到期时间赿晚。</li><li>ArrayBlockingQueue, (<code>基于数组的并发阻塞队列</code>) ArrayBlockingQueue是一个有边界的阻塞队列,它的内部实现是一个数组。有边界的意思是它的容量是有限的,我们必须在其初始化的时候指定它的容量大小,容量大小一旦指定就不可改变。ArrayBlockingQueue是以先进先出的方式存储数据</li><li>LinkedBlockingQueue, (<code>基于链表的FIFO阻塞队列</code>) LinkedBlockingQueue阻塞队列大小的配置是可选的,如果我们初始化时指定一个大小,它就是有边界的,如果不指定,它就是无边界的。说是无边界,其实是采用了默认大小为Integer.MAX_VALUE的容量 。它的内部实现是一个链表。</li><li>LinkedBlockingDeque, (<code>基于链表的FIFO双端阻塞队列</code>) LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列,即<code>可以从队列的两端插入和移除元素</code>。双向队列因为多了一个操作队列的入口,在多线程同时入队时,也就减少了一半的竞争。相比于其他阻塞队列,LinkedBlockingDeque多了addFirst、addLast、peekFirst、peekLast等方法,以first结尾的方法,表示插入、获取获移除双端队列的第一个元素。以last结尾的方法,表示插入、获取获移除双端队列的最后一个元素。LinkedBlockingDeque是可选容量的,在初始化时可以设置容量防止其过度膨胀,如果不设置,默认容量大小为Integer.MAX_VALUE。</li><li>PriorityBlockingQueue, (<code>带优先级的无界阻塞队列</code>) priorityBlockingQueue是一个无界队列,它没有限制,在内存允许的情况下可以无限添加元素;它又是具有优先级的队列,是通过构造函数传入的对象来判断,传入的对象必须实现comparable接口。</li><li>SynchronousQueue (<code>并发同步阻塞队列</code>) SynchronousQueue是一个内部只能包含一个元素的队列。插入元素到队列的线程被阻塞,直到另一个线程从队列中获取了队列中存储的元素。同样,如果线程尝试获取元素并且当前不存在任何元素,则该线程将被阻塞,直到线程将元素插入队列。将这个类称为队列有点夸大其词。这更像是一个点。</li></ul></li></ol></li><li><p>并发队列的常用方法 不管是那种列队,是那个类,当是他们使用的方法都是差不多的</p></li></ol><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>add()</td><td>在不超出队列长度的情况下插入元素,可以立即执行,成功返回true,如果队列满了就抛出异常。</td></tr><tr><td>offer()</td><td>在不超出队列长度的情况下插入元素的时候则可以立即在队列的尾部插入指定元素,成功时返回true,如果此队列已满,则返回false。</td></tr><tr><td>put()</td><td>插入元素的时候,如果队列满了就进行等待,直到队列可用。</td></tr><tr><td>take()</td><td>从队列中获取值,如果队列中没有值,线程会一直阻塞,直到队列中有值,并且该方法取得了该值。</td></tr><tr><td>poll(long timeout,TimeUnit unit)</td><td>在给定的时间里,从队列中获取值,如果没有取到会抛出异常。</td></tr><tr><td>remainingCapacity()</td><td>获取队列中剩余的空间。</td></tr><tr><td>remove(Object o)</td><td>从队列中移除指定的值。</td></tr><tr><td>contains(Object o)</td><td>判断队列中是否拥有该值。</td></tr><tr><td>drainTo(Collectionc)</td><td>将队列中值,全部移除,并发设置到给定的集合中。</td></tr></tbody></table>',9),a=[l];function c(d,n,u,s,h,p){return i(),t("div",null,a)}const _=e(o,[["render",c]]);export{k as __pageData,_ as default};
