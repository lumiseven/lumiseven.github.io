import{_ as s,c as o,o as n,a as l}from"./app.9e6df08e.js";const y=JSON.parse('{"title":"mysql 的乐观锁原理是什么? 有什么并发限制吗?","description":"","frontmatter":{},"headers":[],"relativePath":"jotting/1751351404.md","lastUpdated":1751367489000}'),a={name:"jotting/1751351404.md"},e=l(`<h1 id="mysql-的乐观锁原理是什么-有什么并发限制吗" tabindex="-1">mysql 的乐观锁原理是什么? 有什么并发限制吗? <a class="header-anchor" href="#mysql-的乐观锁原理是什么-有什么并发限制吗" aria-hidden="true">#</a></h1><p>MySQL 的乐观锁（Optimistic Locking）<strong>并不是数据库内置的锁定机制</strong>，而是一种在应用层面实现的并发控制策略。它基于这样的假设：事务冲突的概率很低。</p><h3 id="乐观锁的原理" tabindex="-1">乐观锁的原理 <a class="header-anchor" href="#乐观锁的原理" aria-hidden="true">#</a></h3><p>乐观锁的主要原理是：</p><ol><li><strong>不阻止并发读写：</strong> 在数据被读取时，不施加任何锁定。多个事务可以同时读取同一条数据。</li><li><strong>版本控制：</strong> 在数据表中增加一个特殊的字段，通常是： <ul><li><strong>版本号（version）字段：</strong> 一个整型数字，每次更新数据时都会递增。</li><li><strong>时间戳（timestamp）字段：</strong> 记录数据最后修改的时间。</li></ul></li><li><strong>更新时检查：</strong> 当一个事务要更新数据时，它会： <ul><li><strong>读取当前数据及版本号/时间戳。</strong></li><li><strong>在客户端进行修改。</strong></li><li><strong>尝试更新数据，并在 <code>WHERE</code> 子句中同时校验之前读取的版本号/时间戳。</strong></li><li><strong>如果版本号/时间戳匹配（即在读取到数据到尝试更新的这段时间内，数据没有被其他事务修改过），则更新成功，并将版本号递增。</strong></li><li><strong>如果版本号/时间戳不匹配（即数据已经被其他事务修改过），则更新失败。</strong> 此时应用层会知道操作冲突，通常会抛出异常、提示用户重试、或者根据业务逻辑进行其他处理。</li></ul></li></ol><p><strong>示例 SQL：</strong></p><p>假设 <code>products</code> 表有一个 <code>version</code> 字段和一个 <code>stock</code> 字段。</p><ol><li><p><strong>读取数据：</strong></p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">SELECT</span><span style="color:#A6ACCD;"> stock, </span><span style="color:#F78C6C;">version</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">FROM</span><span style="color:#A6ACCD;"> products </span><span style="color:#F78C6C;">WHERE</span><span style="color:#A6ACCD;"> id </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">123</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">-- 假设返回 stock = 100, version = 1</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>更新数据（尝试将库存减1）：</strong></p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">UPDATE</span><span style="color:#A6ACCD;"> products</span></span>
<span class="line"><span style="color:#F78C6C;">SET</span><span style="color:#A6ACCD;"> stock </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">99</span><span style="color:#A6ACCD;">, </span><span style="color:#F78C6C;">version</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">version</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span></span>
<span class="line"><span style="color:#F78C6C;">WHERE</span><span style="color:#A6ACCD;"> id </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">123</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">AND</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">version</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">; </span><span style="color:#676E95;font-style:italic;">-- 这里的 version = 1 是之前读取到的</span></span>
<span class="line"></span></code></pre></div><ul><li><strong>如果 <code>WHERE</code> 子句匹配（即 <code>id=123</code> 并且 <code>version=1</code>），</strong> 说明在读取后 <code>id=123</code> 的记录没有被其他事务修改过，<code>UPDATE</code> 语句会执行成功，<code>stock</code> 变为 99，<code>version</code> 变为 2。</li><li><strong>如果 <code>WHERE</code> 子句不匹配（即 <code>id=123</code> 的记录 <code>version</code> 已经不是 1 了，可能被其他事务更新为了 2），</strong> 说明在读取后数据被其他事务修改过，<code>UPDATE</code> 语句的 <code>ROWS AFFECTED</code> 会是 0，表示没有更新任何行。应用层通过检查 <code>ROWS AFFECTED</code> 的数量即可判断是否冲突。</li></ul></li></ol><h3 id="乐观锁的优点" tabindex="-1">乐观锁的优点 <a class="header-anchor" href="#乐观锁的优点" aria-hidden="true">#</a></h3><ul><li><strong>高并发性：</strong> 不会阻塞读操作，也较少阻塞写操作，因为锁定的粒度非常细（只在更新瞬间校验）。</li><li><strong>适用于读多写少且冲突概率低的场景：</strong> 在这种场景下，冲突重试的成本较低。</li><li><strong>降低死锁风险：</strong> 因为不使用表级或行级锁（传统的悲观锁）。</li></ul><h3 id="乐观锁的缺点和并发限制" tabindex="-1">乐观锁的缺点和并发限制 <a class="header-anchor" href="#乐观锁的缺点和并发限制" aria-hidden="true">#</a></h3><p>尽管乐观锁有很多优点，但它也存在一些并发限制和挑战：</p><ol><li><p><strong>冲突处理复杂性：</strong></p><ul><li><strong>需要应用层处理冲突：</strong> 当更新失败时，应用程序需要捕获这个失败（通常是 <code>ROWS AFFECTED = 0</code>），然后决定如何处理：重试操作（可能需要重新读数据并基于新数据进行计算）、提示用户、或者回滚等。这增加了应用逻辑的复杂性。</li><li><strong>多次尝试重试：</strong> 如果冲突频繁，用户可能需要多次尝试才能成功操作，影响用户体验。</li></ul></li><li><p><strong>不适用于写多或冲突频繁的场景：</strong></p><ul><li>如果数据更新非常频繁，导致冲突概率很高，那么大量的失败重试会抵消乐观锁带来的性能优势，甚至可能比悲观锁的性能更差。</li></ul></li><li><p><strong>非原子性操作的风险：</strong></p><ul><li>乐观锁只保证了<strong>单个更新操作</strong>的原子性（即 <code>UPDATE</code> 语句本身的原子性）。</li><li>如果一个业务操作涉及<strong>多个相互依赖的更新，</strong> 并且需要在一个逻辑单元内保持一致性，仅靠乐观锁可能不够。例如，从账户 A 扣钱，同时给账户 B 加钱。如果只对单个账户使用乐观锁，可能导致一个成功另一个失败，从而出现数据不一致。对于这类复杂的跨多表的事务，通常需要更强的事务隔离级别和/或分布式事务机制。</li></ul></li><li><p><strong>死锁风险：</strong> 虽然乐观锁本身不引入死锁，但如果应用层在处理冲突重试时，逻辑不当（例如，在不确定的顺序下反复获取资源），仍然可能间接导致一些逻辑上的“死锁”或活锁（一个或多个事务反复失败重试，但永远无法成功）。</p></li><li><p><strong>额外字段开销：</strong> 需要在表中增加额外的 <code>version</code> 或 <code>timestamp</code> 字段。</p></li><li><p><strong>时间戳作为版本控制的局限性：</strong></p><ul><li>使用时间戳时，如果数据库服务器时间跳变或精度不够高，可能导致误判。</li><li>时间戳不是严格递增的，当并发非常高时，可能存在多个事务在同一毫秒内读取和更新的情况，导致版本校验失效。版本号（整型递增）通常更为可靠。</li></ul></li><li><p><strong>无法解决幻读：</strong> 乐观锁主要解决的是<strong>更新丢失（Lost Update）</strong> 问题，即多个事务尝试更新同一条记录时，避免一个事务的更新覆盖了另一个事务的更新。它无法完全解决<strong>幻读（Phantom Read）</strong> 问题，即在一个事务中，根据某个条件查询出的记录数量，在后续的相同条件下查询时发生了变化（有新记录插入或旧记录删除）。解决幻读通常需要更高的事务隔离级别（如 <code>REPEATABLE READ</code> 或 <code>SERIALIZABLE</code>）。</p></li></ol><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h3><p>MySQL 的乐观锁是一种<strong>应用层面的并发控制策略</strong>，通过版本号或时间戳检查来实现。它能有效提高系统的并发性能，特别适用于读多写少、冲突概率低的场景。然而，它需要应用层处理冲突逻辑，并且不适用于写多、冲突频繁或对数据一致性有极高要求的复杂事务场景。在选择悲观锁还是乐观锁时，需要根据具体的业务场景、数据访问模式和对并发冲突处理的策略进行权衡。</p>`,15),t=[e];function r(p,c,i,d,C,g){return n(),o("div",null,t)}const D=s(a,[["render",r]]);export{y as __pageData,D as default};
