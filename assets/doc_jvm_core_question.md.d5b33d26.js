import{_ as s,c as n,o as a,a as l}from"./app.bd26c8cd.js";const F=JSON.parse('{"title":"谈谈你对Java平台的理解","description":"","frontmatter":{},"headers":[],"relativePath":"doc/jvm/core_question.md","lastUpdated":1752029805000}'),o={name:"doc/jvm/core_question.md"},p=l(`<h1 id="谈谈你对java平台的理解" tabindex="-1">谈谈你对Java平台的理解 <a class="header-anchor" href="#谈谈你对java平台的理解" aria-hidden="true">#</a></h1><p>作为一名常年与 Java 打交道的研究者，我对 Java 平台的理解可以用 <strong>“一个由虚拟机推动的巨大开发者生态”</strong> 来概括。它不是单一技术，而是一个<strong>多层次、高度标准化的计算平台和生态体系</strong>，核心围绕着 <strong>跨平台性、稳定性、安全性、高性能和庞大的社区</strong>。下面尽可能详细地阐述其关键组成部分和特性：</p><h2 id="一、核心基石-java-虚拟机" tabindex="-1">一、核心基石：Java 虚拟机 <a class="header-anchor" href="#一、核心基石-java-虚拟机" aria-hidden="true">#</a></h2><ul><li><strong>引擎与运行环境：</strong> JVM 是 Java 平台的灵魂。它提供<strong>运行时环境</strong>让平台无关的 Java 字节码能执行（即<code>.class</code>文件）。</li><li><strong>关键职责：</strong><ul><li><strong>类加载：</strong> 通过高效类加载器（Bootstrap、Extension、System/Application 等）实现动态加载，搭配“双亲委派”机制确保安全。</li><li><strong>字节码执行：</strong><ul><li><strong>解释器：</strong> 即时翻译执行字节码（启动快）。</li><li><strong>即时编译器：</strong> JIT（如 C1、C2/GraalVM）在运行时编译热点代码为本地机器码（运行快）。</li><li><strong>AOT 编译器：</strong> 如 GraalVM Native Image，在编译时直接将字节码编译为本地可执行文件（启动极快，占用资源减少）。</li></ul></li><li><strong>内存管理（GC）：</strong><ul><li><strong>自动垃圾回收：</strong> JVM 通过复杂的垃圾回收器回收内存（如 Serial、Parallel Scavenge/Old、CMS、G1、ZGC、Shenandoah），大幅减少开发者负担。</li><li><strong>内存模型：</strong> 如堆（Heap）、栈（Stack）、方法区/元空间（Metaspace）等定义。</li></ul></li><li><strong>运行时优化：</strong> 持续优化字节码执行效率（如内联、逃逸分析和即时编译）。</li></ul></li><li><strong>跨平台特性：</strong> “一次编写，随处运行”的关键基础就是 JVM，各平台有对应实现。</li></ul><h2 id="二、核心库-api" tabindex="-1">二、核心库 API <a class="header-anchor" href="#二、核心库-api" aria-hidden="true">#</a></h2><ul><li><strong>基础设施支持：</strong> 提供强大且标准化的功能支撑核心开发： <ul><li><strong>基础类库：</strong> <code>java.lang</code>（如 Object, String, Class 等）、<code>java.util</code>（容器如 List， Map， 时间处理等）、<code>java.io</code>/<code>java.nio</code>（IO/NIO）。</li><li><strong>并发包：</strong> <code>java.util.concurrent</code>（线程池如 ExecutorService、并发容器、Lock 和 AQS）。</li><li><strong>工具类：</strong> 数学计算（<code>java.math</code>）、反射（<code>java.lang.reflect</code>）、注解、函数式接口（java.util.function）等。</li><li><strong>安全管理：</strong> <code>java.security</code> （访问控制、证书等）。</li></ul></li><li><strong>标准扩展 API：</strong><ul><li><strong>数据库访问：</strong> JDBC（<code>java.sql</code>, <code>javax.sql</code>）。</li><li><strong>网络通信：</strong> 套接字、HTTP 客户端（HTTPURLConnection、HttpClient JDK 11+）。</li><li><strong>XML 处理：</strong> JAXP。</li><li><strong>日志：</strong> <code>java.util.logging</code>（SLF4J/Logback 等更常用，但也在平台内或上层生态内）。</li></ul></li></ul><h2 id="三、java-语言本身" tabindex="-1">三、Java 语言本身 <a class="header-anchor" href="#三、java-语言本身" aria-hidden="true">#</a></h2><ul><li><strong>面向对象设计：</strong> 封装、继承、多态是其核心支柱。</li><li><strong>强类型和相对安全：</strong> 编译期类型检查有效减少运行时错误。</li><li><strong>相对简单：</strong> 无指针、内存自动管理等提升开发体验。</li><li><strong>稳健发展：</strong><ul><li><strong>持续演进：</strong> JDK 5（泛型、枚举、注解）、JDK 8（Lambda、Stream API）、JDK 9（模块系统）、JDK 11（LTS 主力）、JDK 17/21（新 LTS）。</li><li><strong>项目推进：</strong> Valhalla（值类型）、Panama（FFI）、Loom（虚拟线程）等持续优化语言性能和表现力。</li></ul></li></ul><h2 id="四、工具集-支撑全开发周期" tabindex="-1">四、工具集：支撑全开发周期 <a class="header-anchor" href="#四、工具集-支撑全开发周期" aria-hidden="true">#</a></h2><ul><li><strong>JDK：</strong> 包含 JRE、编译器（javac）、调试器（jdb）、监控工具（jconsole, jvisualvm）、打包工具（jar）等。</li><li><strong>诊断与调优工具：</strong><ul><li>命令行（jps, jstat, jmap, jstack）</li><li>图形化（VisualVM, JMC）</li><li>第三方（Arthas, YourKit）</li></ul></li></ul><h2 id="五、生态体系-平台的真正实力" tabindex="-1">五、生态体系：平台的真正实力 <a class="header-anchor" href="#五、生态体系-平台的真正实力" aria-hidden="true">#</a></h2><ul><li><strong>构建工具：</strong> Maven、Gradle（标准化依赖管理和构建）。</li><li><strong>主流框架：</strong><ul><li>综合：Spring Framework（包括 Spring Boot、Spring Cloud、Spring Security 等）</li><li>Web：Jakarta EE（前 Java EE）、Play、Dropwizard</li><li>ORM：Hibernate、MyBatis</li></ul></li><li><strong>测试工具：</strong> JUnit、TestNG、Mockito、JaCoCo 等完整测试生态。</li><li><strong>应用服务器：</strong> Tomcat、Jetty、WildFly、GlassFish、WebLogic、WebSphere（部署企业级解决方案）。</li><li><strong>微服务支持：</strong> Netflix OSS、Spring Cloud 等实现现代化分布式架构。</li><li><strong>大数据技术：</strong> Apache Hadoop/Spark/Flink/Kafka 多以 JVM 平台为基础。</li></ul><h2 id="六、java-平台的核心价值主张" tabindex="-1">六、Java 平台的核心价值主张 <a class="header-anchor" href="#六、java-平台的核心价值主张" aria-hidden="true">#</a></h2><ul><li><strong>跨平台可移植性：</strong> 在绝大多数操作系统上均可运行。</li><li><strong>高性能与可扩展：</strong> JVM 持续优化和即时编译确保高性能，GC 技术成熟支撑大规模应用。</li><li><strong>高安全性：</strong> 字节码校验、安全管理器、沙箱机制和类加载机制提供多维度保障。</li><li><strong>成熟的开发体验：</strong> 丰富的文档、IDE（IntelliJ IDEA/Eclipse）强大支持、异常处理清晰。</li><li><strong>蓬勃的生态圈：</strong> 社区支持强大、开源库覆盖全面，持续解决复杂场景问题。</li><li><strong>稳健与成熟度高：</strong> 经过 20 多年验证的架构使其成为企业级应用的首选。</li><li><strong>与时俱进：</strong> 不断拥抱新技术范式（云原生、函数式编程、服务网格等）。</li></ul><hr><h2 id="核心概念总结" tabindex="-1">核心概念总结 <a class="header-anchor" href="#核心概念总结" aria-hidden="true">#</a></h2><table><thead><tr><th>概念</th><th>作用</th><th>关键技术示例</th></tr></thead><tbody><tr><td><strong>JVM</strong></td><td>代码执行环境</td><td>类加载器、垃圾回收器、JIT/HotSpot</td></tr><tr><td><strong>字节码</strong></td><td>跨平台中间格式</td><td>.class 文件、JVM指令集</td></tr><tr><td><strong>核心库</strong></td><td>提供基础API</td><td>java.lang、java.util、java.io、java.nio</td></tr><tr><td><strong>Java SE/EE</strong></td><td>平台标准规范</td><td>SE 基础API、EE企业级扩展</td></tr><tr><td><strong>工具链</strong></td><td>开发者支持</td><td>JDK工具、Maven/Gradle、JUnit</td></tr><tr><td><strong>生态系统</strong></td><td>扩展平台能力</td><td>Spring框架、Hibernate、Tomcat服务</td></tr></tbody></table><h2 id="我眼中的-java-平台关键特征" tabindex="-1">我眼中的 Java 平台关键特征 <a class="header-anchor" href="#我眼中的-java-平台关键特征" aria-hidden="true">#</a></h2><ol><li><strong>虚拟机为中心</strong>：JVM 是跨平台基石，性能优化核心。</li><li><strong>强类型 OOP 语言+函数式扩展</strong>：Java 语言持续进化，兼顾传统与现代编程范式。</li><li><strong>丰富核心库</strong>：提供现代软件开发所需的基础构建块。</li><li><strong>成熟内存管理系统</strong>：自动 GC 和多种优化策略显著提升开发者效率。</li><li><strong>生态驱动价值</strong>：从 Maven 到 Spring，整个生态解决了现实世界开发中的各种难题。</li><li><strong>企业级稳健性</strong>：经过大规模实践验证的架构使其长期担当关键业务支撑。</li><li><strong>开放性标准与开源动力</strong>：JCP 等标准化组织与强大的开源社区持续推动进化。</li></ol><hr><p><strong>总而言之，Java 平台是一个以 JVM 为核心驱动、拥有强大核心库支撑、以 Java 语言为主要开发语言、配套成熟工具链、并被庞大开源生态和商业应用所包围的高度成功的计算平台。其核心价值在于跨平台能力、高性能保障、成熟的开发体验和极其丰富的生态系统支撑</strong>。它既是技术体系，更是一种开发文化，始终在适应新挑战的同时保持着强大的生命力。这正是 Java 长盛不衰的根本原因——不仅是工具，更是完整的解决方案生态系统。</p><hr><h1 id="java中的exception和error有什么区别" tabindex="-1">java中的exception和error有什么区别 <a class="header-anchor" href="#java中的exception和error有什么区别" aria-hidden="true">#</a></h1><p>在Java中，<code>Error</code> 和 <code>Exception</code> 都是 <code>Throwable</code> 类的子类，但它们代表了不同性质的问题，处理方式也有显著区别。以下是主要区别的总结：</p><hr><h3 id="🚨-1-根本区别" tabindex="-1">🚨 <strong>1. 根本区别</strong> <a class="header-anchor" href="#🚨-1-根本区别" aria-hidden="true">#</a></h3><table><thead><tr><th></th><th><strong><code>Exception</code></strong></th><th><strong><code>Error</code></strong></th></tr></thead><tbody><tr><td><strong>本质</strong></td><td><strong>应用程序级问题</strong></td><td><strong>系统级严重问题</strong></td></tr><tr><td><strong>可恢复性</strong></td><td>多数可被捕获并恢复</td><td><strong>通常不可恢复</strong>（如内存耗尽）</td></tr><tr><td><strong>责任方</strong></td><td>程序员编写的代码</td><td>JVM环境或底层资源问题</td></tr></tbody></table><hr><h3 id="🧩-2-类型区分" tabindex="-1">🧩 <strong>2. 类型区分</strong> <a class="header-anchor" href="#🧩-2-类型区分" aria-hidden="true">#</a></h3><ul><li><p><strong><code>Exception</code> (异常)</strong></p><ul><li><strong>受检异常（Checked）</strong>：编译时必须处理（<code>IOException</code>, <code>SQLException</code>等）</li><li><strong>非受检异常（Unchecked）</strong>：运行时异常（<code>NullPointerException</code>, <code>ArrayIndexOutOfBoundsException</code>等）</li></ul></li><li><p><strong><code>Error</code> (错误)</strong> 所有错误都是<strong>非受检</strong>的（如 <code>OutOfMemoryError</code>, <code>StackOverflowError</code>），无需在代码中显式处理。</p></li></ul><hr><h3 id="⚙️-3-典型例子" tabindex="-1">⚙️ <strong>3. 典型例子</strong> <a class="header-anchor" href="#⚙️-3-典型例子" aria-hidden="true">#</a></h3><table><thead><tr><th><strong><code>Exception</code> 示例</strong></th><th><strong><code>Error</code> 示例</strong></th></tr></thead><tbody><tr><td><code>FileNotFoundException</code></td><td><code>OutOfMemoryError</code>（内存耗尽）</td></tr><tr><td><code>ClassNotFoundException</code></td><td><code>StackOverflowError</code>（栈溢出）</td></tr><tr><td><code>InterruptedException</code></td><td><code>NoClassDefFoundError</code>（类加载失败）</td></tr></tbody></table><hr><h3 id="🛠️-4-处理方式建议" tabindex="-1">🛠️ <strong>4. 处理方式建议</strong> <a class="header-anchor" href="#🛠️-4-处理方式建议" aria-hidden="true">#</a></h3><ul><li><p><strong><code>Exception</code> 处理</strong>： 应通过 <code>try-catch</code> 捕获并恢复，或用 <code>throws</code> 声明：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 可能抛出Exception的代码</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">IOException</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 恢复逻辑（如重试或提示用户）</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong><code>Error</code> 处理</strong>： ❌ <strong>禁止主动捕获</strong>！因无法有效恢复，捕获可能掩盖严重问题：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 错误示例！（不要这样写）</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 某些操作</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">OutOfMemoryError</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 无法实际解决内存耗尽问题</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h3 id="📌-关键总结" tabindex="-1">📌 <strong>关键总结</strong> <a class="header-anchor" href="#📌-关键总结" aria-hidden="true">#</a></h3><table><thead><tr><th>特性</th><th><code>Exception</code></th><th><code>Error</code></th></tr></thead><tbody><tr><td><strong>是否可恢复</strong></td><td>✅ 多数可恢复</td><td>❌ 不可恢复</td></tr><tr><td><strong>是否强制处理</strong></td><td>受检异常强制处理</td><td>不强制处理</td></tr><tr><td><strong>来源</strong></td><td>应用程序逻辑问题</td><td>JVM/系统资源崩溃</td></tr><tr><td><strong>是否应被捕获</strong></td><td>✅ 需针对性处理</td><td>❌ 避免捕获（除特殊场景如日志记录）</td></tr></tbody></table><hr><h3 id="🌰-代码示例" tabindex="-1">🌰 代码示例 <a class="header-anchor" href="#🌰-代码示例" aria-hidden="true">#</a></h3><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 异常处理（正常流程）</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    Files</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">readString</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Path</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">of</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">missing_file.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">));</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">IOException</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 捕获Exception</span></span>
<span class="line"><span style="color:#A6ACCD;">    System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">err</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">文件不存在：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> e</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getMessage</span><span style="color:#89DDFF;">());</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Error场景：捕获无意义，程序仍会崩溃</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">int</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> arr </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">Integer</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">MAX_VALUE</span><span style="color:#89DDFF;">];</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 触发OutOfMemoryError</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">OutOfMemoryError</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 此处无法真正恢复内存！</span></span>
<span class="line"><span style="color:#A6ACCD;">    System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">err</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">内存耗尽（实际应终止程序）</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><blockquote><p>💡 <strong>最佳实践</strong>：</p><ul><li>对 <code>Exception</code> 编写健壮的恢复逻辑</li><li>对 <code>Error</code> 记录日志后<strong>终止程序</strong>（通常由JVM自动处理）</li><li>永远不要吞掉 <code>Throwable</code>（如 <code>catch (Throwable t)</code>）！</li></ul></blockquote><hr><h1 id="谈谈-java中的-final-finally-finalize-有什么不同" tabindex="-1">谈谈 java中的 final finally finalize 有什么不同？ <a class="header-anchor" href="#谈谈-java中的-final-finally-finalize-有什么不同" aria-hidden="true">#</a></h1><p>在Java中，<code>final</code>、<code>finally</code> 和 <code>finalize</code> 虽然名称相似，但功能和使用场景<strong>完全不同</strong>。以下是详细对比：</p><hr><h3 id="⭐-1-final-关键字" tabindex="-1">⭐ <strong>1. final（关键字）</strong> <a class="header-anchor" href="#⭐-1-final-关键字" aria-hidden="true">#</a></h3><p><strong>核心作用</strong>： <strong>修饰不可变性</strong>，可应用于类、方法、变量。</p><table><thead><tr><th>应用场景</th><th>规则</th><th>示例</th></tr></thead><tbody><tr><td><strong>final变量</strong></td><td>变量值/引用地址不可变（基本类型值不变，引用类型地址不变）</td><td><code>final int x = 10;</code> <br> <code>final List&lt;String&gt; list = new ArrayList&lt;&gt;();</code></td></tr><tr><td><strong>final方法</strong></td><td>禁止子类重写（Override）</td><td><code>public final void doWork() { ... }</code></td></tr><tr><td><strong>final类</strong></td><td>禁止类被继承（不能有子类）</td><td><code>public final class ImmutableClass { ... }</code></td></tr></tbody></table><p><strong>注意事项</strong>：</p><ul><li><code>final</code> 修饰引用类型变量时，<strong>对象内容可变</strong>（如集合可增删元素）。</li><li>常与 <code>static</code> 组合定义常量：<code>public static final double PI = 3.14;</code></li></ul><hr><h3 id="⭐-2-finally-关键字" tabindex="-1">⭐ <strong>2. finally（关键字）</strong> <a class="header-anchor" href="#⭐-2-finally-关键字" aria-hidden="true">#</a></h3><p><strong>核心作用</strong>： <strong>确保资源清理</strong>，必须与 <code>try-catch</code> 块一起使用。</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>必然执行</strong></td><td>无论是否发生异常、<code>return</code> 或 <code>break</code>，都会执行（<em>极端情况除外</em>）</td></tr><tr><td><strong>资源清理</strong></td><td>用于关闭文件流、数据库连接、释放锁等</td></tr><tr><td><strong>避免资源泄漏</strong></td><td>比靠GC回收更及时可靠</td></tr></tbody></table><p><strong>执行逻辑</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 可能抛出异常的代码</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">openFile</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">IOException</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 异常处理</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    file</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">close</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 无论如何都会关闭文件</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><strong>极端不执行场景</strong>：</p><ol><li><code>System.exit(0)</code> 强制退出</li><li>JVM崩溃（如 <code>kill -9</code> 杀掉进程）</li><li>无限循环阻塞 finally 线程</li></ol><hr><h3 id="⭐-3-finalize-方法" tabindex="-1">⭐ <strong>3. finalize（方法）</strong> <a class="header-anchor" href="#⭐-3-finalize-方法" aria-hidden="true">#</a></h3><p><strong>核心作用</strong>： <strong>对象回收前的最后一次清理</strong>（Object类的方法）。</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>不可靠的执行时机</strong></td><td>GC回收前触发，<strong>时机不确定甚至不执行</strong></td></tr><tr><td><strong>已被官方弃用</strong></td><td>Java 9 标记为<code>@Deprecated</code>（实际开发中避免使用）</td></tr><tr><td><strong>潜在风险</strong></td><td>性能问题（减慢GC）<br>资源泄漏（若未执行）<br>僵尸对象复活（可破坏GC）</td></tr></tbody></table><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#C792EA;">protected</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">finalize</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> throws Throwable </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">releaseNativeResource</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 尝试释放JNI资源</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        super</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">finalize</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 调用父类清理</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><strong>替代方案</strong>：</p><ul><li>推荐使用 <strong><code>AutoCloseable</code> 接口 + try-with-resources</strong>（Java 7+）：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">FileInputStream</span><span style="color:#A6ACCD;"> file </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">FileInputStream</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">test.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 自动调用file.close()</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">IOException</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h3 id="🎯-三者的本质区别" tabindex="-1">🎯 <strong>三者的本质区别</strong> <a class="header-anchor" href="#🎯-三者的本质区别" aria-hidden="true">#</a></h3><table><thead><tr><th>特性</th><th>final</th><th>finally</th><th>finalize</th></tr></thead><tbody><tr><td><strong>类型</strong></td><td><strong>关键字</strong></td><td><strong>关键字</strong></td><td><strong>Object的方法</strong></td></tr><tr><td><strong>作用域</strong></td><td>类/方法/变量</td><td>异常处理块</td><td>垃圾回收</td></tr><tr><td><strong>执行时机</strong></td><td>编译/运行时</td><td>异常处理后</td><td>GC前（不确定）</td></tr><tr><td><strong>可靠性</strong></td><td>语言级保证</td><td>非极端场景保证</td><td>不保证执行</td></tr><tr><td><strong>用途</strong></td><td>增强安全/设计约束</td><td>资源清理</td><td>历史遗留清理</td></tr></tbody></table><hr><h3 id="✅-最佳实践建议" tabindex="-1">✅ <strong>最佳实践建议</strong> <a class="header-anchor" href="#✅-最佳实践建议" aria-hidden="true">#</a></h3><ol><li>🛡️ <strong>多用 <code>final</code></strong>：提升代码安全性和设计清晰度（如不可变类）。</li><li>🔁 <strong>资源清理用 <code>finally</code> 或 try-with-resources</strong>：确保100%执行。</li><li>❌ <strong>避免 <code>finalize</code></strong>：使用 <code>Cleaner</code>（Java 9+）或手动资源管理替代。</li></ol><blockquote><p><strong>关键总结</strong>：</p><ul><li><code>final</code> → <strong>设计约束</strong>（不可变）</li><li><code>finally</code> → <strong>资源清理</strong>（必须执行）</li><li><code>finalize</code> → <strong>历史遗留</strong>（弃用机制）</li></ul></blockquote><hr><h1 id="java中的强引用-弱引用-幻象引用-有什么区别" tabindex="-1">java中的强引用 弱引用 幻象引用 有什么区别？ <a class="header-anchor" href="#java中的强引用-弱引用-幻象引用-有什么区别" aria-hidden="true">#</a></h1><p>在Java中，引用类型主要分为<strong>强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和幻象引用（Phantom Reference）</strong>。它们的主要区别在于垃圾回收器（GC）对待这些引用的方式不同，从而影响对象的生命周期和回收机制。</p><hr><h3 id="_1-强引用-strong-reference" tabindex="-1">1. <strong>强引用（Strong Reference）</strong> <a class="header-anchor" href="#_1-强引用-strong-reference" aria-hidden="true">#</a></h3><p><strong>特点</strong>：</p><ul><li><strong>最常见</strong>的引用类型，默认创建的引用都是强引用。</li><li>只要强引用存在，对象<strong>不会被GC回收</strong>（即使内存不足，JVM宁愿抛出<code>OutOfMemoryError</code>）。</li><li>强引用之间的依赖关系可能导致<strong>内存泄漏</strong>（如集合中无用的对象未移除）。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 强引用</span></span>
<span class="line"></span></code></pre></div><p><strong>回收时机</strong>：</p><ul><li>显式设置 <code>obj = null</code> 解除引用后，对象会被回收。</li><li>作用域结束（如局部变量超出作用域）。</li></ul><hr><h3 id="_2-弱引用-weak-reference" tabindex="-1">2. <strong>弱引用（Weak Reference）</strong> <a class="header-anchor" href="#_2-弱引用-weak-reference" aria-hidden="true">#</a></h3><p><strong>特点</strong>：</p><ul><li>通过 <code>java.lang.ref.WeakReference</code> 类实现。</li><li>当<strong>仅存在弱引用</strong>时，对象会在<strong>下一次GC时被回收</strong>（无论内存是否充足）。</li><li>常用于实现<strong>缓存</strong>（如 <code>WeakHashMap</code>），避免因缓存导致内存泄漏。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> weakRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">());</span></span>
<span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 获取对象（若未被回收）</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">gc</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// GC后若对象被回收，则 weakRef.get() 返回 null</span></span>
<span class="line"></span></code></pre></div><p><strong>典型场景</strong>：</p><ul><li><code>WeakHashMap</code> 的键（Key）使用弱引用存储，当键不再被强引用时，对应的键值对会被自动移除。</li></ul><hr><h3 id="_3-幻象引用-phantom-reference" tabindex="-1">3. <strong>幻象引用（Phantom Reference）</strong> <a class="header-anchor" href="#_3-幻象引用-phantom-reference" aria-hidden="true">#</a></h3><p><strong>特点</strong>：</p><ul><li>通过 <code>java.lang.ref.PhantomReference</code> 类实现。</li><li><strong>最弱</strong>的引用类型，无法通过 <code>get()</code> 方法获取到对象（始终返回 <code>null</code>）。</li><li>必须配合 <strong>引用队列（ReferenceQueue）</strong> 使用。</li><li>用于在对象<strong>被回收时收到系统通知</strong>（如清理堆外内存等资源）。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> queue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> phantomRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 对象被GC回收前，phantomRef 会自动加入 queue</span></span>
<span class="line"><span style="color:#C792EA;">Reference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> ref </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">remove</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 阻塞直到有引用入队</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">对象已被回收，资源清理完成</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div><p><strong>回收时机</strong>：</p><ul><li>对象本身被回收后，幻象引用会进入引用队列，通知开发者执行<strong>资源清理</strong>（如关闭文件句柄、释放堆外内存）。</li></ul><hr><h3 id="_4-软引用-soft-reference" tabindex="-1">4. <strong>软引用（Soft Reference）</strong> <a class="header-anchor" href="#_4-软引用-soft-reference" aria-hidden="true">#</a></h3><p><strong>补充说明</strong>：</p><ul><li>虽未提及但需完整对比：通过 <code>SoftReference</code> 类实现。</li><li>当<strong>内存不足</strong>时（即将抛出 <code>OutOfMemoryError</code> 前），GC才会回收仅被软引用的对象。</li><li>适合实现<strong>内存敏感的缓存</strong>（如大图片缓存）。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">SoftReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> softRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">SoftReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">());</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="引用队列-referencequeue" tabindex="-1">引用队列（ReferenceQueue） <a class="header-anchor" href="#引用队列-referencequeue" aria-hidden="true">#</a></h3><ul><li><strong>作用</strong>：在弱引用、软引用或幻象引用关联的对象被回收后，引用对象本身会被加入到队列中。</li><li><strong>典型用法</strong>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> queue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> ref </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 检查对象是否被回收</span></span>
<span class="line"><span style="color:#C792EA;">Reference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> clearedRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">poll</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 非阻塞检查</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h3 id="对比总结" tabindex="-1">对比总结 <a class="header-anchor" href="#对比总结" aria-hidden="true">#</a></h3><table><thead><tr><th>引用类型</th><th>回收时机</th><th><code>get()</code> 返回值</th><th>用途</th><th>实现类</th></tr></thead><tbody><tr><td><strong>强引用</strong></td><td><strong>永不回收</strong>（除非解除）</td><td>对象本身</td><td>常规对象引用</td><td>默认（无特殊类）</td></tr><tr><td><strong>软引用</strong></td><td><strong>内存不足时</strong></td><td>对象本身（若未回收）</td><td>实现内存敏感缓存（如图片缓存）</td><td><code>SoftReference</code></td></tr><tr><td><strong>弱引用</strong></td><td><strong>下一次GC时</strong></td><td>对象本身（若未回收）</td><td>防止缓存导致内存泄漏（如<code>WeakHashMap</code>）</td><td><code>WeakReference</code></td></tr><tr><td><strong>幻象引用</strong></td><td><strong>GC回收后通知</strong></td><td><strong>始终为null</strong></td><td>对象回收的清理工作（如堆外内存）</td><td><code>PhantomReference</code></td></tr></tbody></table><hr><h3 id="关键区别点" tabindex="-1">关键区别点 <a class="header-anchor" href="#关键区别点" aria-hidden="true">#</a></h3><ol><li><p><strong>回收强度</strong>： 强引用 &gt; 软引用 &gt; 弱引用 &gt; 幻象引用 （从左到右，对对象的约束依次减弱，回收可能性增加）</p></li><li><p><strong>实际效果</strong>：</p><ul><li>强引用阻止GC回收对象；</li><li>软引用在内存紧张时被回收；</li><li>弱引用在下次GC时即刻回收；</li><li>幻象引用仅用于接收对象回收的通知。</li></ul></li><li><p><strong>实用场景</strong>：</p><ul><li>强引用：常规对象管理。</li><li>软引用：对象缓存（如 <code>Android</code> 图片加载库）。</li><li>弱引用：自动清理的无干扰缓存（如 <code>WeakHashMap</code>）。</li><li>幻象引用：资源清理（如 <code>DirectByteBuffer</code> 堆外内存释放）。</li></ul></li></ol><hr><h3 id="代码验证示例" tabindex="-1">代码验证示例 <a class="header-anchor" href="#代码验证示例" aria-hidden="true">#</a></h3><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">java</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">lang</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">ref</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">*</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ReferenceTest</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">throws</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">InterruptedException</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> queue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 强引用</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> strongObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">强引用对象：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> strongObj</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 弱引用</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> weakRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">弱引用对象（GC前）：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 幻象引用</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> phantomRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">幻象引用对象（始终null）：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> phantomRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 触发GC</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">gc</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        Thread</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sleep</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 给GC时间</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 检查回收结果</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">弱引用对象（GC后）：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">());</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 输出 null</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 从队列中检查回收通知（弱引用和幻象引用都会入队）</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Reference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> ref</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">((</span><span style="color:#A6ACCD;">ref </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">poll</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ref </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">弱引用进入队列 - 对象被回收</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ref </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> phantomRef</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">幻象引用进入队列 - 可执行清理工作</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><strong>输出</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">强引用对象：java.lang.Object@1b6d3586</span></span>
<span class="line"><span style="color:#A6ACCD;">弱引用对象（GC前）：java.lang.Object@4554617c</span></span>
<span class="line"><span style="color:#A6ACCD;">幻象引用对象（始终null）：null</span></span>
<span class="line"><span style="color:#A6ACCD;">弱引用对象（GC后）：null</span></span>
<span class="line"><span style="color:#A6ACCD;">弱引用进入队列 - 对象被回收</span></span>
<span class="line"><span style="color:#A6ACCD;">幻象引用进入队列 - 可执行清理工作</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><hr><p>通过不同引用类型的设计，Java为开发者提供了更精细的内存管理手段，尤其在缓存、监听、资源清理等场景中能有效防止内存泄漏。</p><hr><h1 id="java中的强引用-弱引用-幻象引用-有什么区别-1" tabindex="-1">java中的强引用 弱引用 幻象引用 有什么区别？ <a class="header-anchor" href="#java中的强引用-弱引用-幻象引用-有什么区别-1" aria-hidden="true">#</a></h1><p>在Java中，引用类型主要分为<strong>强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和幻象引用（Phantom Reference）</strong>。它们的主要区别在于垃圾回收器（GC）对待这些引用的方式不同，从而影响对象的生命周期和回收机制。</p><hr><h3 id="_1-强引用-strong-reference-1" tabindex="-1">1. <strong>强引用（Strong Reference）</strong> <a class="header-anchor" href="#_1-强引用-strong-reference-1" aria-hidden="true">#</a></h3><p><strong>特点</strong>：</p><ul><li><strong>最常见</strong>的引用类型，默认创建的引用都是强引用。</li><li>只要强引用存在，对象<strong>不会被GC回收</strong>（即使内存不足，JVM宁愿抛出<code>OutOfMemoryError</code>）。</li><li>强引用之间的依赖关系可能导致<strong>内存泄漏</strong>（如集合中无用的对象未移除）。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 强引用</span></span>
<span class="line"></span></code></pre></div><p><strong>回收时机</strong>：</p><ul><li>显式设置 <code>obj = null</code> 解除引用后，对象会被回收。</li><li>作用域结束（如局部变量超出作用域）。</li></ul><hr><h3 id="_2-弱引用-weak-reference-1" tabindex="-1">2. <strong>弱引用（Weak Reference）</strong> <a class="header-anchor" href="#_2-弱引用-weak-reference-1" aria-hidden="true">#</a></h3><p><strong>特点</strong>：</p><ul><li>通过 <code>java.lang.ref.WeakReference</code> 类实现。</li><li>当<strong>仅存在弱引用</strong>时，对象会在<strong>下一次GC时被回收</strong>（无论内存是否充足）。</li><li>常用于实现<strong>缓存</strong>（如 <code>WeakHashMap</code>），避免因缓存导致内存泄漏。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> weakRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">());</span></span>
<span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 获取对象（若未被回收）</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">gc</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// GC后若对象被回收，则 weakRef.get() 返回 null</span></span>
<span class="line"></span></code></pre></div><p><strong>典型场景</strong>：</p><ul><li><code>WeakHashMap</code> 的键（Key）使用弱引用存储，当键不再被强引用时，对应的键值对会被自动移除。</li></ul><hr><h3 id="_3-幻象引用-phantom-reference-1" tabindex="-1">3. <strong>幻象引用（Phantom Reference）</strong> <a class="header-anchor" href="#_3-幻象引用-phantom-reference-1" aria-hidden="true">#</a></h3><p><strong>特点</strong>：</p><ul><li>通过 <code>java.lang.ref.PhantomReference</code> 类实现。</li><li><strong>最弱</strong>的引用类型，无法通过 <code>get()</code> 方法获取到对象（始终返回 <code>null</code>）。</li><li>必须配合 <strong>引用队列（ReferenceQueue）</strong> 使用。</li><li>用于在对象<strong>被回收时收到系统通知</strong>（如清理堆外内存等资源）。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> queue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> phantomRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 对象被GC回收前，phantomRef 会自动加入 queue</span></span>
<span class="line"><span style="color:#C792EA;">Reference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> ref </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">remove</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 阻塞直到有引用入队</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">对象已被回收，资源清理完成</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div><p><strong>回收时机</strong>：</p><ul><li>对象本身被回收后，幻象引用会进入引用队列，通知开发者执行<strong>资源清理</strong>（如关闭文件句柄、释放堆外内存）。</li></ul><hr><h3 id="_4-软引用-soft-reference-1" tabindex="-1">4. <strong>软引用（Soft Reference）</strong> <a class="header-anchor" href="#_4-软引用-soft-reference-1" aria-hidden="true">#</a></h3><p><strong>补充说明</strong>：</p><ul><li>虽未提及但需完整对比：通过 <code>SoftReference</code> 类实现。</li><li>当<strong>内存不足</strong>时（即将抛出 <code>OutOfMemoryError</code> 前），GC才会回收仅被软引用的对象。</li><li>适合实现<strong>内存敏感的缓存</strong>（如大图片缓存）。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">SoftReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> softRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">SoftReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">());</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="引用队列-referencequeue-1" tabindex="-1">引用队列（ReferenceQueue） <a class="header-anchor" href="#引用队列-referencequeue-1" aria-hidden="true">#</a></h3><ul><li><strong>作用</strong>：在弱引用、软引用或幻象引用关联的对象被回收后，引用对象本身会被加入到队列中。</li><li><strong>典型用法</strong>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> queue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> ref </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 检查对象是否被回收</span></span>
<span class="line"><span style="color:#C792EA;">Reference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> clearedRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">poll</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 非阻塞检查</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h3 id="对比总结-1" tabindex="-1">对比总结 <a class="header-anchor" href="#对比总结-1" aria-hidden="true">#</a></h3><table><thead><tr><th>引用类型</th><th>回收时机</th><th><code>get()</code> 返回值</th><th>用途</th><th>实现类</th></tr></thead><tbody><tr><td><strong>强引用</strong></td><td><strong>永不回收</strong>（除非解除）</td><td>对象本身</td><td>常规对象引用</td><td>默认（无特殊类）</td></tr><tr><td><strong>软引用</strong></td><td><strong>内存不足时</strong></td><td>对象本身（若未回收）</td><td>实现内存敏感缓存（如图片缓存）</td><td><code>SoftReference</code></td></tr><tr><td><strong>弱引用</strong></td><td><strong>下一次GC时</strong></td><td>对象本身（若未回收）</td><td>防止缓存导致内存泄漏（如<code>WeakHashMap</code>）</td><td><code>WeakReference</code></td></tr><tr><td><strong>幻象引用</strong></td><td><strong>GC回收后通知</strong></td><td><strong>始终为null</strong></td><td>对象回收的清理工作（如堆外内存）</td><td><code>PhantomReference</code></td></tr></tbody></table><hr><h3 id="关键区别点-1" tabindex="-1">关键区别点 <a class="header-anchor" href="#关键区别点-1" aria-hidden="true">#</a></h3><ol><li><p><strong>回收强度</strong>： 强引用 &gt; 软引用 &gt; 弱引用 &gt; 幻象引用 （从左到右，对对象的约束依次减弱，回收可能性增加）</p></li><li><p><strong>实际效果</strong>：</p><ul><li>强引用阻止GC回收对象；</li><li>软引用在内存紧张时被回收；</li><li>弱引用在下次GC时即刻回收；</li><li>幻象引用仅用于接收对象回收的通知。</li></ul></li><li><p><strong>实用场景</strong>：</p><ul><li>强引用：常规对象管理。</li><li>软引用：对象缓存（如 <code>Android</code> 图片加载库）。</li><li>弱引用：自动清理的无干扰缓存（如 <code>WeakHashMap</code>）。</li><li>幻象引用：资源清理（如 <code>DirectByteBuffer</code> 堆外内存释放）。</li></ul></li></ol><hr><h3 id="代码验证示例-1" tabindex="-1">代码验证示例 <a class="header-anchor" href="#代码验证示例-1" aria-hidden="true">#</a></h3><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">java</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">lang</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">ref</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">*</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ReferenceTest</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">throws</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">InterruptedException</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> queue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 强引用</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> strongObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">强引用对象：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> strongObj</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 弱引用</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> weakRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">弱引用对象（GC前）：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 幻象引用</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> phantomRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">幻象引用对象（始终null）：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> phantomRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 触发GC</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">gc</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        Thread</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sleep</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 给GC时间</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 检查回收结果</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">弱引用对象（GC后）：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">());</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 输出 null</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 从队列中检查回收通知（弱引用和幻象引用都会入队）</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Reference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> ref</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">((</span><span style="color:#A6ACCD;">ref </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">poll</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ref </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">弱引用进入队列 - 对象被回收</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ref </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> phantomRef</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">幻象引用进入队列 - 可执行清理工作</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><strong>输出</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">强引用对象：java.lang.Object@1b6d3586</span></span>
<span class="line"><span style="color:#A6ACCD;">弱引用对象（GC前）：java.lang.Object@4554617c</span></span>
<span class="line"><span style="color:#A6ACCD;">幻象引用对象（始终null）：null</span></span>
<span class="line"><span style="color:#A6ACCD;">弱引用对象（GC后）：null</span></span>
<span class="line"><span style="color:#A6ACCD;">弱引用进入队列 - 对象被回收</span></span>
<span class="line"><span style="color:#A6ACCD;">幻象引用进入队列 - 可执行清理工作</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><hr><p>通过不同引用类型的设计，Java为开发者提供了更精细的内存管理手段，尤其在缓存、监听、资源清理等场景中能有效防止内存泄漏。</p><hr><h1 id="java-中-string-stringbuffer-stringbuilder-有什么区别" tabindex="-1">java 中 String StringBuffer StringBuilder 有什么区别？ <a class="header-anchor" href="#java-中-string-stringbuffer-stringbuilder-有什么区别" aria-hidden="true">#</a></h1><p>在Java中，<code>String</code>、<code>StringBuffer</code>和<code>StringBuilder</code>都用于处理字符串，但它们在<strong>可变性、线程安全性和性能</strong>方面有显著区别。以下是详细对比：</p><hr><h3 id="_1-string-不可变" tabindex="-1">1. <strong>String (不可变)</strong> <a class="header-anchor" href="#_1-string-不可变" aria-hidden="true">#</a></h3><ul><li><strong>核心特性</strong>：不可变（Immutable），任何修改操作（如拼接、替换）都会<strong>创建新对象</strong>。</li><li><strong>线程安全</strong>：天然线程安全（因不可变性）。</li><li><strong>内存开销</strong>：频繁修改会产生大量临时对象，影响性能。</li><li><strong>典型场景</strong>：常量字符串、不频繁修改的字符串。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> str </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">str </span><span style="color:#89DDFF;">+=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;"> World</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 隐式创建新对象+垃圾回收</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="_2-stringbuffer-可变-线程安全" tabindex="-1">2. <strong>StringBuffer (可变 + 线程安全)</strong> <a class="header-anchor" href="#_2-stringbuffer-可变-线程安全" aria-hidden="true">#</a></h3><ul><li><strong>核心特性</strong>：可变（Mutable），修改直接在原对象上进行。</li><li><strong>线程安全</strong>：<strong>线程安全</strong>（所有方法用<code>synchronized</code>修饰）。</li><li><strong>性能</strong>：比<code>String</code>高效（减少对象创建），但因同步锁开销，单线程下慢于<code>StringBuilder</code>。</li><li><strong>典型场景</strong>：多线程环境下的字符串修改（如Web应用）。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">StringBuffer</span><span style="color:#A6ACCD;"> sb </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">StringBuffer</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">sb</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">append</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;"> World</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 修改原对象，无新对象产生</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="_3-stringbuilder-可变-非线程安全" tabindex="-1">3. <strong>StringBuilder (可变 + 非线程安全)</strong> <a class="header-anchor" href="#_3-stringbuilder-可变-非线程安全" aria-hidden="true">#</a></h3><ul><li><strong>核心特性</strong>：可变（Mutable），API与<code>StringBuffer</code>兼容（非线程安全版）。</li><li><strong>线程安全</strong>：<strong>非线程安全</strong>（无同步锁）。</li><li><strong>性能</strong>：单线程下<strong>最快</strong>（无同步开销）。</li><li><strong>典型场景</strong>：单线程环境下的高频字符串操作（如循环拼接）。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">StringBuilder</span><span style="color:#A6ACCD;"> sb </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">StringBuilder</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">sb</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">append</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;"> World</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 修改原对象，效率最高（单线程）</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="性能对比-单线程" tabindex="-1">性能对比（单线程） <a class="header-anchor" href="#性能对比-单线程" aria-hidden="true">#</a></h3><table><thead><tr><th>操作</th><th><code>String</code></th><th><code>StringBuffer</code></th><th><code>StringBuilder</code></th></tr></thead><tbody><tr><td>10万次字符串拼接</td><td>慢（约2000ms+）</td><td>中（约5ms）</td><td><strong>快（约3ms）</strong></td></tr><tr><td>内存占用</td><td>高（对象爆炸）</td><td>低</td><td>低</td></tr><tr><td>线程安全</td><td>✅</td><td>✅</td><td>❌</td></tr></tbody></table><hr><h3 id="如何选择" tabindex="-1">如何选择？ <a class="header-anchor" href="#如何选择" aria-hidden="true">#</a></h3><table><thead><tr><th>场景</th><th>推荐类</th></tr></thead><tbody><tr><td>字符串常量、不修改</td><td><code>String</code></td></tr><tr><td><strong>多线程</strong>环境修改字符串</td><td><code>StringBuffer</code></td></tr><tr><td><strong>单线程</strong>环境修改字符串（主流）</td><td><code>StringBuilder</code></td></tr></tbody></table><blockquote><p><strong>最佳实践</strong>：</p><ul><li>JDK 5+开始，编译器会自动将<code>String</code>的<code>+</code>拼接优化为<code>StringBuilder</code>（仅适用于循环外简单拼接）。</li><li>循环内拼接<strong>务必手动使用<code>StringBuilder</code></strong>，避免编译器优化失效：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 正确示例</span></span>
<span class="line"><span style="color:#C792EA;">StringBuilder</span><span style="color:#A6ACCD;"> sb </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">StringBuilder</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    sb</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">append</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 只创建一个对象</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></blockquote><hr><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h3><table><thead><tr><th>特性</th><th><code>String</code></th><th><code>StringBuffer</code></th><th><code>StringBuilder</code></th></tr></thead><tbody><tr><td><strong>可变性</strong></td><td>❌（不可变）</td><td>✅（可变）</td><td>✅（可变）</td></tr><tr><td><strong>线程安全</strong></td><td>✅（天然）</td><td>✅（同步锁）</td><td>❌（无锁）</td></tr><tr><td><strong>性能</strong></td><td>低（频繁修改时）</td><td>中（锁开销）</td><td><strong>高</strong>（单线程首选）</td></tr><tr><td><strong>使用场景</strong></td><td>常量、少量修改</td><td>多线程环境</td><td>单线程高频操作</td></tr></tbody></table><hr><h1 id="java中的动态代理是基于什么原理" tabindex="-1">java中的动态代理是基于什么原理？ <a class="header-anchor" href="#java中的动态代理是基于什么原理" aria-hidden="true">#</a></h1><p>在Java中，动态代理是一种在运行时动态生成代理类对象的机制，它基于以下核心原理：</p><hr><h3 id="核心原理" tabindex="-1"><strong>核心原理</strong> <a class="header-anchor" href="#核心原理" aria-hidden="true">#</a></h3><ol><li><p><strong>运行时字节码生成</strong></p><ul><li>当调用<code>Proxy.newProxyInstance()</code>方法时，JVM会在内存中动态生成一个代理类的字节码（.class文件）。</li><li>生成的代理类继承自<code>java.lang.reflect.Proxy</code>类，并实现用户指定的接口（若接口非public则需同一ClassLoader加载）。</li><li>这一过程由<code>Proxy</code>类的内部逻辑完成，无需手动编写代理类代码。</li></ul></li><li><p><strong>方法调用委派机制</strong></p><ul><li>代理类中所有方法调用都会被重定向到一个统一的处理器：<code>InvocationHandler.invoke()</code>。</li><li>代理类的每个方法内部逻辑如下：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">ReturnType</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">methodName</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Parameters</span><span style="color:#A6ACCD;"> params</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> handler</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">invoke</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this,</span><span style="color:#A6ACCD;">   </span><span style="color:#676E95;font-style:italic;">// 代理对象自身</span></span>
<span class="line"><span style="color:#A6ACCD;">        method</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 目标方法（通过反射获取的Method对象）</span></span>
<span class="line"><span style="color:#A6ACCD;">        args    </span><span style="color:#676E95;font-style:italic;">// 方法参数</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong>反射调用目标方法</strong></p><ul><li>在<code>InvocationHandler.invoke()</code>的实现中，通过反射机制（<code>method.invoke(target, args)</code>）调用被代理对象的实际方法。</li><li>开发者可在<code>invoke()</code>中加入自定义逻辑（如性能监控、事务控制等）。</li></ul></li></ol><hr><h3 id="核心组件" tabindex="-1"><strong>核心组件</strong> <a class="header-anchor" href="#核心组件" aria-hidden="true">#</a></h3><ol><li><p><strong><code>java.lang.reflect.Proxy</code></strong></p><ul><li>入口类，提供静态方法创建代理对象：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Foo</span><span style="color:#A6ACCD;"> proxy </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Foo</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> Proxy</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newProxyInstance</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">    target</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getClass</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">getClassLoader</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 1. 类加载器</span></span>
<span class="line"><span style="color:#A6ACCD;">    target</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getClass</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">getInterfaces</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 2. 代理需实现的接口数组</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">MyInvocationHandler</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// 3. 调用处理器</span></span>
<span class="line"><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong><code>java.lang.reflect.InvocationHandler</code></strong></p><ul><li>单方法接口，定义代理行为的核心逻辑：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">InvocationHandler</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">invoke</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">proxy</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Method</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">method</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">throws</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Throwable</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ol><hr><h3 id="工作流程" tabindex="-1"><strong>工作流程</strong> <a class="header-anchor" href="#工作流程" aria-hidden="true">#</a></h3><div class="language-mermaid"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">sequenceDiagram</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">participant</span><span style="color:#A6ACCD;"> Client </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">客户端</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">participant</span><span style="color:#A6ACCD;"> Proxy </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">动态代理对象</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">participant</span><span style="color:#A6ACCD;"> Handler </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">InvocationHandler</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">participant</span><span style="color:#A6ACCD;"> Target </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">被代理对象</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    Client </span><span style="color:#89DDFF;font-style:italic;">-&gt;&gt;</span><span style="color:#A6ACCD;"> Proxy</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">调用接口方法</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">Note</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">over</span><span style="color:#A6ACCD;"> Proxy</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">自动拦截方法调用</span></span>
<span class="line"><span style="color:#A6ACCD;">    Proxy </span><span style="color:#89DDFF;font-style:italic;">-&gt;&gt;</span><span style="color:#A6ACCD;"> Handler</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">转发调用至invoke()</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">Note</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">over</span><span style="color:#A6ACCD;"> Handler</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">执行前置逻辑(如日志)</span></span>
<span class="line"><span style="color:#A6ACCD;">    Handler </span><span style="color:#89DDFF;font-style:italic;">-&gt;&gt;</span><span style="color:#A6ACCD;"> Target</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">反射调用实际方法(method.invoke())</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">Note</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">over</span><span style="color:#A6ACCD;"> Handler</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">执行后置逻辑(如事务提交)</span></span>
<span class="line"><span style="color:#A6ACCD;">    Target </span><span style="color:#89DDFF;font-style:italic;">--&gt;&gt;</span><span style="color:#A6ACCD;"> Handler</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">返回结果</span></span>
<span class="line"><span style="color:#A6ACCD;">    Handler </span><span style="color:#89DDFF;font-style:italic;">--&gt;&gt;</span><span style="color:#A6ACCD;"> Proxy</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">返回结果</span></span>
<span class="line"><span style="color:#A6ACCD;">    Proxy </span><span style="color:#89DDFF;font-style:italic;">--&gt;&gt;</span><span style="color:#A6ACCD;"> Client</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">返回结果</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="关键特点" tabindex="-1"><strong>关键特点</strong> <a class="header-anchor" href="#关键特点" aria-hidden="true">#</a></h3><ol><li><p><strong>接口代理</strong></p><ul><li>动态代理只能基于接口生成代理（继承<code>Proxy</code>类导致无法再继承其他类）。</li><li>若需代理无接口的类，需使用第三方库（如CGLib或Byte Buddy）。</li></ul></li><li><p><strong>性能开销</strong></p><ul><li>反射调用有性能损耗（JVM优化的<code>MethodHandle</code>可缓解）。</li><li>代理类首次生成后会被缓存复用。</li></ul></li><li><p><strong>动态性</strong></p><ul><li>代理逻辑（<code>InvocationHandler</code>）可在运行时替换，实现高度灵活的AOP编程。</li></ul></li></ol><hr><h3 id="底层实现机制" tabindex="-1"><strong>底层实现机制</strong> <a class="header-anchor" href="#底层实现机制" aria-hidden="true">#</a></h3><ol><li><p><strong>字节码生成过程</strong></p><ul><li><code>sun.misc.ProxyGenerator</code>动态生成代理类字节码。</li><li>通过<code>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</code>可导出.class文件查看：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">$Proxy0.class</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong>代理类示例</strong>（反编译后）</p></li></ol><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">$Proxy0</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Proxy</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Foo</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Method</span><span style="color:#A6ACCD;"> m1</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 目标方法的Method引用</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> $</span><span style="color:#82AAFF;">Proxy0</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">InvocationHandler</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">h</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        super</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">h</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">doSomething</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">arg</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 所有方法调用转发至InvocationHandler</span></span>
<span class="line"><span style="color:#A6ACCD;">        h</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">invoke</span><span style="color:#89DDFF;">(this,</span><span style="color:#A6ACCD;"> m1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">[]{</span><span style="color:#A6ACCD;">arg</span><span style="color:#89DDFF;">});</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        m1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Class</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">forName</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Foo</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">getMethod</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">doSomething</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> String</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="典型应用场景" tabindex="-1"><strong>典型应用场景</strong> <a class="header-anchor" href="#典型应用场景" aria-hidden="true">#</a></h3><ol><li><strong>AOP（面向切面编程）</strong><ul><li>Spring AOP使用动态代理实现事务管理、安全控制等横切关注点。</li></ul></li><li><strong>RPC框架</strong><ul><li>Dubbo、gRPC等通过动态代理隐藏远程调用细节（如序列化/网络传输）。</li></ul></li><li><strong>测试框架</strong><ul><li>Mockito利用动态代理创建模拟对象。</li></ul></li><li><strong>装饰器模式增强</strong><ul><li>动态添加日志记录、性能监控等非业务功能。</li></ul></li></ol><hr><h3 id="对比静态代理" tabindex="-1"><strong>对比静态代理</strong> <a class="header-anchor" href="#对比静态代理" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>动态代理</strong></th><th><strong>静态代理</strong></th></tr></thead><tbody><tr><td>代码编写</td><td>无需手动编写代理类</td><td>需为每个接口编写代理类</td></tr><tr><td>可维护性</td><td>修改代理逻辑只需调整<code>InvocationHandler</code></td><td>需修改所有代理类源码</td></tr><tr><td>接口变化适应性</td><td>自动适配接口新增方法</td><td>需同步修改代理类</td></tr><tr><td>性能</td><td>反射调用有轻微开销</td><td>直接调用，无额外开销</td></tr></tbody></table><hr><h3 id="示例代码" tabindex="-1"><strong>示例代码</strong> <a class="header-anchor" href="#示例代码" aria-hidden="true">#</a></h3><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 1. 定义接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Calculator</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">b</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 2. 目标实现类</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">CalculatorImpl</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Calculator</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">b</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 3. 调用处理器</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">DebugHandler</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">InvocationHandler</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> target</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">DebugHandler</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">target</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">target </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> target</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">invoke</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">proxy</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Method</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">method</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">printf</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">调用方法: %s，参数: %s%n</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> method</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getName</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> Arrays</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">toString</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">args</span><span style="color:#89DDFF;">));</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> result </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> method</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">invoke</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> args</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 反射调用目标方法</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">结果: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> result</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> result</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 4. 客户端使用</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Demo</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Calculator</span><span style="color:#A6ACCD;"> target </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">CalculatorImpl</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Calculator</span><span style="color:#A6ACCD;"> proxy </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Calculator</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> Proxy</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newProxyInstance</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">                target</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getClass</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">getClassLoader</span><span style="color:#89DDFF;">(),</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Class</span><span style="color:#89DDFF;">[]{</span><span style="color:#A6ACCD;">Calculator</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">DebugHandler</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span></span>
<span class="line"><span style="color:#A6ACCD;">        proxy</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 输出调试日志并计算结果</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><strong>输出</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">调用方法: add，参数: [2, 3]</span></span>
<span class="line"><span style="color:#A6ACCD;">结果: 5</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><hr><h3 id="总结-1" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结-1" aria-hidden="true">#</a></h3><p>Java动态代理的本质是利用<strong>运行时生成字节码技术</strong> + <strong>方法调用委派机制</strong> + <strong>反射API</strong>，在接口级别实现代理模式。其核心价值在于：</p><ul><li><strong>解耦</strong>：将代理逻辑从业务代码中剥离。</li><li><strong>动态性</strong>：运行时灵活生成代理对象。</li><li><strong>可扩展性</strong>：通过<code>InvocationHandler</code>支持多样化的增强逻辑。 但需注意其局限于接口代理，对类代理需依赖第三方字节码库（如CGLib）。</li></ul><hr><h1 id="java中int和integer的区别" tabindex="-1">java中int和Integer的区别？ <a class="header-anchor" href="#java中int和integer的区别" aria-hidden="true">#</a></h1><p>在 Java 中，<code>int</code> 和 <code>Integer</code> 都用于表示整数值，但它们有本质区别：</p><h3 id="🧱-1-核心类型不同" tabindex="-1">🧱 1. <strong>核心类型不同</strong> <a class="header-anchor" href="#🧱-1-核心类型不同" aria-hidden="true">#</a></h3><ul><li><strong><code>int</code></strong>：<strong>原始数据类型</strong>（Primitive Type），直接存储数据值（栈内存）。</li><li><strong><code>Integer</code></strong>：<strong>引用类型</strong>（类类型），是 <code>int</code> 的包装类（Object），存储的是对象的引用（堆内存）。</li></ul><h3 id="📊-2-内存与性能" tabindex="-1">📊 2. <strong>内存与性能</strong> <a class="header-anchor" href="#📊-2-内存与性能" aria-hidden="true">#</a></h3><table><thead><tr><th>特性</th><th><code>int</code></th><th><code>Integer</code></th></tr></thead><tbody><tr><td><strong>内存占用</strong></td><td>固定 4 字节</td><td>额外对象开销（约 16 字节）</td></tr><tr><td><strong>性能</strong></td><td>更高（无对象创建开销）</td><td>较低（涉及对象操作）</td></tr></tbody></table><h3 id="⚙️-3-自动装箱-autoboxing-与拆箱-unboxing" tabindex="-1">⚙️ 3. <strong>自动装箱（Autoboxing）与拆箱（Unboxing）</strong> <a class="header-anchor" href="#⚙️-3-自动装箱-autoboxing-与拆箱-unboxing" aria-hidden="true">#</a></h3><p>Java 5 开始引入自动转换机制：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 自动装箱：int → Integer</span></span>
<span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> boxed </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 等价于 Integer.valueOf(10)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 自动拆箱：Integer → int</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> unboxed </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> boxed</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 等价于 boxed.intValue()</span></span>
<span class="line"></span></code></pre></div><h3 id="🗃️-4-默认值" tabindex="-1">🗃️ 4. <strong>默认值</strong> <a class="header-anchor" href="#🗃️-4-默认值" aria-hidden="true">#</a></h3><ul><li><strong><code>int</code></strong>：默认值为 <code>0</code>。</li><li><strong><code>Integer</code></strong>：默认值为 <code>null</code>（可表示缺失值）。</li></ul><blockquote><p>💡 关键区别：<code>int</code> 无法为 <code>null</code>，<code>Integer</code> 可以表达数字缺失的逻辑（如数据库中的空字段）。</p></blockquote><h3 id="📦-5-缓存机制-flyweight-pattern" tabindex="-1">📦 5. <strong>缓存机制（Flyweight Pattern）</strong> <a class="header-anchor" href="#📦-5-缓存机制-flyweight-pattern" aria-hidden="true">#</a></h3><ul><li><strong><code>Integer</code></strong> 在 <code>-128 到 127</code> 范围内缓存对象：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">127</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">127</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// true，同一缓存对象</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> c </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">128</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> d </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">128</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">c </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> d</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// false，超出缓存，新建对象</span></span>
<span class="line"></span></code></pre></div></li><li><code>new Integer()</code> <strong>强制创建新对象</strong>（不推荐使用，已废弃）。</li></ul><h3 id="🔧-6-方法与功能" tabindex="-1">🔧 6. <strong>方法与功能</strong> <a class="header-anchor" href="#🔧-6-方法与功能" aria-hidden="true">#</a></h3><ul><li><strong><code>int</code></strong>：无方法（原始类型）。</li><li><strong><code>Integer</code></strong>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 实用方法</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> max </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Integer</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">MAX_VALUE</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// 最大值 2^31-1</span></span>
<span class="line"><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> s </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">123</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> num </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Integer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">parseInt</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">s</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 字符串转 int</span></span>
<span class="line"><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> hex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Integer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">toHexString</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">255</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 转为16进制 &quot;ff&quot;</span></span>
<span class="line"></span></code></pre></div></li></ul><h3 id="🧰-7-使用场景" tabindex="-1">🧰 7. <strong>使用场景</strong> <a class="header-anchor" href="#🧰-7-使用场景" aria-hidden="true">#</a></h3><table><thead><tr><th>场景</th><th>推荐类型</th><th>原因说明</th></tr></thead><tbody><tr><td>高频计算/循环</td><td><code>int</code></td><td>避免对象开销，性能最优</td></tr><tr><td>集合类存储</td><td><code>Integer</code></td><td>泛型要求对象类型（如 <code>List&lt;Integer&gt;</code>）</td></tr><tr><td>需表达 <code>null</code></td><td><code>Integer</code></td><td><code>int</code> 无法为 <code>null</code></td></tr><tr><td>反射/泛型</td><td><code>Integer</code></td><td>仅支持对象类型</td></tr></tbody></table><h3 id="✅-总结对比表" tabindex="-1">✅ 总结对比表 <a class="header-anchor" href="#✅-总结对比表" aria-hidden="true">#</a></h3><table><thead><tr><th>特性</th><th><code>int</code></th><th><code>Integer</code></th></tr></thead><tbody><tr><td><strong>类型</strong></td><td>原始类型（Primitive）</td><td>包装类（Object）</td></tr><tr><td><strong>内存</strong></td><td>栈内存（4字节）</td><td>堆内存 + 额外对象开销</td></tr><tr><td><strong>默认值</strong></td><td><code>0</code></td><td><code>null</code></td></tr><tr><td><strong>比较</strong></td><td><code>==</code> 比较值</td><td><code>equals()</code> 比较值，<code>==</code> 比较引用</td></tr><tr><td><strong>可空性（Null）</strong></td><td>❌ 不允许</td><td>✅ 允许</td></tr><tr><td><strong>方法</strong></td><td>无</td><td>提供丰富工具方法（如转换、计算）</td></tr><tr><td><strong>集合/泛型支持</strong></td><td>❌ 不支持</td><td>✅ 支持</td></tr></tbody></table><h3 id="⚠️-注意事项" tabindex="-1">⚠️ 注意事项 <a class="header-anchor" href="#⚠️-注意事项" aria-hidden="true">#</a></h3><ol><li><strong>空指针风险</strong>：<code>Integer</code> 为 <code>null</code> 时拆箱会抛出 <code>NullPointerException</code>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> num </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> value </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> num</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 抛出 NullPointerException!</span></span>
<span class="line"></span></code></pre></div></li><li><strong>比较陷阱</strong>：优先使用 <code>equals()</code> 而非 <code>==</code> 比较 <code>Integer</code> 值：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> x </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">200</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> y </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">200</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">x </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> y</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">      </span><span style="color:#676E95;font-style:italic;">// false（超出缓存范围）</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">x</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equals</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">y</span><span style="color:#89DDFF;">));</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"></span></code></pre></div></li></ol><h3 id="💻-代码示例" tabindex="-1">💻 代码示例 <a class="header-anchor" href="#💻-代码示例" aria-hidden="true">#</a></h3><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Main</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 原始类型 vs 包装类</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> primitive </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> wrapper </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 自动装箱与拆箱</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> autoBoxed </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> primitive</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 自动装箱</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> autoUnboxed </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> wrapper</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">      </span><span style="color:#676E95;font-style:italic;">// 自动拆箱</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 空值处理</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> nullable </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// int risk = nullable;       // 运行时抛 NullPointerException</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 用法示例</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Integer 转二进制: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> Integer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">toBinaryString</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">));</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 1010</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">解析字符串: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> Integer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">parseInt</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">FF</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">16</span><span style="color:#89DDFF;">));</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 255</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h3 id="📌-设计哲学" tabindex="-1">📌 设计哲学 <a class="header-anchor" href="#📌-设计哲学" aria-hidden="true">#</a></h3><ul><li><strong>原始类型 <code>int</code></strong>：追求极致性能的计算场景。</li><li><strong>包装类 <code>Integer</code></strong>：对象化处理，解决泛型支持、空值表达等系统级扩展需求。</li></ul><p>根据需求灵活选择二者，是写出高效 Java 代码的关键之一！🚀</p><hr><h1 id="对比vector-arraylist-linkedlist有何区别" tabindex="-1">对比Vector ArrayList LinkedList有何区别 <a class="header-anchor" href="#对比vector-arraylist-linkedlist有何区别" aria-hidden="true">#</a></h1><p>在Java中，<code>Vector</code>、<code>ArrayList</code>和<code>LinkedList</code>都是实现<code>List</code>接口的集合类，但在底层实现、性能特性和线程安全性上有显著差异。以下是详细对比：</p><hr><h3 id="_1-底层数据结构" tabindex="-1"><strong>1. 底层数据结构</strong> <a class="header-anchor" href="#_1-底层数据结构" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>类</strong></th><th><strong>数据结构</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong><code>Vector</code></strong></td><td>动态数组（数组）</td><td>基于可扩容的数组实现。初始容量默认为10，扩容后为 <strong>原容量的2倍</strong>（可通过构造器调整增量）。</td></tr><tr><td><strong><code>ArrayList</code></strong></td><td>动态数组（数组）</td><td>基于可扩容的数组实现。初始容量默认为10，扩容后为 <strong>原容量的1.5倍</strong>（<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>）。</td></tr><tr><td><strong><code>LinkedList</code></strong></td><td>双向链表</td><td>每个元素作为节点（<code>Node</code>）存储，包含前驱、后继引用和数据。</td></tr></tbody></table><hr><h3 id="_2-线程安全性" tabindex="-1"><strong>2. 线程安全性</strong> <a class="header-anchor" href="#_2-线程安全性" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>类</strong></th><th><strong>线程安全</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><strong><code>Vector</code></strong></td><td><strong>是</strong> (线程安全)</td><td>所有方法均通过<code>synchronized</code>同步锁实现，但并发效率低！</td></tr><tr><td><strong><code>ArrayList</code></strong></td><td>否 (非线程安全)</td><td>无同步机制。多线程操作需手动同步（如<code>Collections.synchronizedList()</code>）。</td></tr><tr><td><strong><code>LinkedList</code></strong></td><td>否 (非线程安全)</td><td>同上。</td></tr></tbody></table><blockquote><p>⚠️ <strong>提示</strong>：在高并发场景中，优先使用<code>CopyOnWriteArrayList</code>（读多写少）或<code>ConcurrentLinkedQueue</code>（高并发队列）。</p></blockquote><hr><h3 id="_3-性能关键点对比" tabindex="-1"><strong>3. 性能关键点对比</strong> <a class="header-anchor" href="#_3-性能关键点对比" aria-hidden="true">#</a></h3><h4 id="_1-随机访问-根据索引获取元素" tabindex="-1"><strong>(1) 随机访问（根据索引获取元素）</strong> <a class="header-anchor" href="#_1-随机访问-根据索引获取元素" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>类</strong></th><th><strong>时间复杂度</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><strong><code>Vector</code></strong></td><td><strong>O(1)</strong></td><td>数组支持直接下标访问（<code>elementData[index]</code>）。</td></tr><tr><td><strong><code>ArrayList</code></strong></td><td><strong>O(1)</strong></td><td>同上（物理内存连续）。</td></tr><tr><td><strong><code>LinkedList</code></strong></td><td><strong>O(n)</strong></td><td>需要从头/尾遍历链表定位节点（最坏情况需遍历整个链表）。</td></tr></tbody></table><blockquote><p>✅ <strong>场景选择</strong>：需频繁随机访问时，优先选<code>ArrayList</code>或<code>Vector</code>。</p></blockquote><h4 id="_2-插入-删除操作" tabindex="-1"><strong>(2) 插入/删除操作</strong> <a class="header-anchor" href="#_2-插入-删除操作" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>操作位置</strong></th><th><strong><code>Vector/ArrayList</code></strong></th><th><strong><code>LinkedList</code></strong></th></tr></thead><tbody><tr><td><strong>尾部操作</strong></td><td>O(1) 摊销时间</td><td>O(1)</td></tr><tr><td><strong>头部/中间操作</strong></td><td>O(n)（需移动后续元素）</td><td><strong>O(1)</strong>（仅修改节点引用，但需O(n)定位节点）</td></tr></tbody></table><blockquote><p>✅ <strong>场景选择</strong>：</p><ul><li>频繁在头部/中间插入/删除：<strong><code>LinkedList</code> 更优</strong>（如实现栈、队列或双向队列）。</li><li><code>ArrayList</code>尾部操作高效，但中间插入可能触发频繁扩容和元素拷贝。</li></ul></blockquote><h4 id="_3-内存占用" tabindex="-1"><strong>(3) 内存占用</strong> <a class="header-anchor" href="#_3-内存占用" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>类</strong></th><th><strong>空间开销</strong></th></tr></thead><tbody><tr><td><strong><code>Vector</code></strong></td><td>数组结构（连续内存），存在预留容量空间（扩容后旧数组被GC回收）。</td></tr><tr><td><strong><code>ArrayList</code></strong></td><td>同上（空间效率比<code>Vector</code>略高，因扩容因子1.5 vs 2）。</td></tr><tr><td><strong><code>LinkedList</code></strong></td><td><strong>更高</strong>：每个节点需存储前驱/后继引用（占12-16字节额外内存 + 节点对象开销）。</td></tr></tbody></table><hr><h3 id="_4-扩容机制" tabindex="-1"><strong>4. 扩容机制</strong> <a class="header-anchor" href="#_4-扩容机制" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>类</strong></th><th><strong>扩容逻辑</strong></th></tr></thead><tbody><tr><td><strong><code>Vector</code></strong></td><td>扩容因子可指定（构造器<code>public Vector(int initialCapacity, int capacityIncrement)</code>），默认增量为<strong>原容量×2</strong>。</td></tr><tr><td><strong><code>ArrayList</code></strong></td><td>固定增量 <strong>原容量×1.5</strong>（无法自定义）。</td></tr><tr><td><strong><code>LinkedList</code></strong></td><td><strong>无需扩容</strong>（链表动态添加节点）。</td></tr></tbody></table><blockquote><p>⚠️ 频繁插入时，<code>ArrayList</code>的扩容会带来内存拷贝开销（<code>System.arraycopy()</code>）。</p></blockquote><hr><h3 id="_5-额外功能" tabindex="-1"><strong>5. 额外功能</strong> <a class="header-anchor" href="#_5-额外功能" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>类</strong></th><th><strong>特有功能</strong></th></tr></thead><tbody><tr><td><strong><code>Vector</code></strong></td><td>支持通过枚举器遍历（<code>Enumeration&lt;E&gt; elements()</code>），遗留方法且效率低于迭代器。</td></tr><tr><td><strong><code>LinkedList</code></strong></td><td>实现<code>Deque</code>接口，支持双端队列操作（<code>addFirst()</code>, <code>pollLast()</code>, <code>offer()</code>等）。</td></tr></tbody></table><hr><h3 id="_6-继承体系" tabindex="-1"><strong>6. 继承体系</strong> <a class="header-anchor" href="#_6-继承体系" aria-hidden="true">#</a></h3><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Vector</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Vector</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">AbstractList</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">List</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">RandomAccess</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Cloneable</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> java.io.</span><span style="color:#FFCB6B;">Serializable</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// ArrayList</span></span>
<span class="line"><span style="color:#A6ACCD;">public class </span><span style="color:#FFCB6B;">ArrayList</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">AbstractList</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">List</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">RandomAccess</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Cloneable</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> java.io.</span><span style="color:#FFCB6B;">Serializable</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// LinkedList</span></span>
<span class="line"><span style="color:#A6ACCD;">public class </span><span style="color:#FFCB6B;">LinkedList</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">AbstractSequentialList</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">List</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Deque</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Cloneable</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> java.io.</span><span style="color:#FFCB6B;">Serializable</span></span>
<span class="line"></span></code></pre></div><ul><li><strong><code>RandomAccess</code></strong>: <code>Vector</code>和<code>ArrayList</code>标记支持高效随机访问。</li><li><strong><code>Deque</code></strong>: <code>LinkedList</code>额外支持队列操作。</li></ul><hr><h3 id="总结-如何选择" tabindex="-1"><strong>总结：如何选择？</strong> <a class="header-anchor" href="#总结-如何选择" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐类</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td>读多写少，需随机访问</td><td><code>ArrayList</code></td><td>内存紧凑、访问快速，避免线程安全开销。</td></tr><tr><td>多线程环境</td><td>- 需同步：<code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code> <br> - 高并发写：<code>CopyOnWriteArrayList</code></td><td><code>Vector</code>不推荐（性能差，遗留类）。</td></tr><tr><td>频繁在任意位置插入/删除元素</td><td><code>LinkedList</code></td><td>链式结构修改高效，避免数组拷贝开销。</td></tr><tr><td>实现队列/双端队列</td><td><code>LinkedList</code></td><td>天然支持<code>Deque</code>接口（<code>PriorityQueue</code>等其他队列可替代）。</td></tr><tr><td>遗留系统兼容性</td><td><code>Vector</code></td><td>新代码不再建议使用。</td></tr></tbody></table><blockquote><p>💡 <strong>最佳实践</strong>：</p><ul><li><strong>首选<code>ArrayList</code></strong>：大部分场景性能最优（90%以上）。</li><li>避免在多线程中直接使用<code>ArrayList/LinkedList</code>（需手动同步）。</li><li><code>LinkedList</code>仅在对链表特性有明确需求时使用（如中间频繁修改或用作队列）。</li></ul></blockquote><hr><h1 id="对比hashtable-hashmap-treemap-有什么不同" tabindex="-1">对比Hashtable HashMap TreeMap 有什么不同 <a class="header-anchor" href="#对比hashtable-hashmap-treemap-有什么不同" aria-hidden="true">#</a></h1><p>在 Java 中，<code>Hashtable</code>、<code>HashMap</code> 和 <code>TreeMap</code> 都是实现 <code>Map</code> 接口的键值对集合类，但它们在设计、性能和线程安全方面有显著区别。以下是详细对比：</p><hr><h3 id="_1-线程安全性" tabindex="-1">1. <strong>线程安全性</strong> <a class="header-anchor" href="#_1-线程安全性" aria-hidden="true">#</a></h3><ul><li><strong><code>Hashtable</code></strong>：<strong>线程安全</strong>。所有方法通过 <code>synchronized</code> 关键字实现同步（悲观锁），适合多线程环境，但性能较低。<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Map</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Integer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> hashtable </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Hashtable</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 多线程操作安全</span></span>
<span class="line"></span></code></pre></div></li><li><strong><code>HashMap</code></strong>：<strong>非线程安全</strong>。未同步，多线程操作需手动同步（如 <code>Collections.synchronizedMap</code> 或 <code>ConcurrentHashMap</code>）。<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Map</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Integer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> hashMap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">HashMap</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 多线程操作需额外同步</span></span>
<span class="line"></span></code></pre></div></li><li><strong><code>TreeMap</code></strong>：<strong>非线程安全</strong>。未同步，多线程需手动处理（类似 <code>HashMap</code>）。</li></ul><hr><h3 id="_2-是否允许-null-键-值" tabindex="-1">2. <strong>是否允许 null 键/值</strong> <a class="header-anchor" href="#_2-是否允许-null-键-值" aria-hidden="true">#</a></h3><ul><li><strong><code>Hashtable</code></strong>：<strong>不允许</strong> null 键或值（抛出 <code>NullPointerException</code>）。<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">hashtable</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(null,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">      </span><span style="color:#676E95;font-style:italic;">// 抛出 NPE</span></span>
<span class="line"><span style="color:#A6ACCD;">hashtable</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">key</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null);</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 抛出 NPE</span></span>
<span class="line"></span></code></pre></div></li><li><strong><code>HashMap</code></strong>：<strong>允许</strong> 1 个 null 键和多个 null 值。<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">hashMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(null,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">       </span><span style="color:#676E95;font-style:italic;">// 允许</span></span>
<span class="line"><span style="color:#A6ACCD;">hashMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">key</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null);</span><span style="color:#A6ACCD;">   </span><span style="color:#676E95;font-style:italic;">// 允许</span></span>
<span class="line"></span></code></pre></div></li><li><strong><code>TreeMap</code></strong>：<strong>不允许 null 键</strong>（因需排序），但允许 null 值（取决于比较器）。<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(null,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">       </span><span style="color:#676E95;font-style:italic;">// 抛出 NPE</span></span>
<span class="line"><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">key</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null);</span><span style="color:#A6ACCD;">   </span><span style="color:#676E95;font-style:italic;">// 允许（若比较器支持）</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h3 id="_3-元素顺序" tabindex="-1">3. <strong>元素顺序</strong> <a class="header-anchor" href="#_3-元素顺序" aria-hidden="true">#</a></h3><ul><li><strong><code>Hashtable</code></strong> 和 <strong><code>HashMap</code></strong>：<strong>不保证顺序</strong>（迭代顺序可能随时间变化）。</li><li><strong><code>TreeMap</code></strong>：<strong>严格按键排序</strong>（自然顺序或自定义 <code>Comparator</code>）。<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">TreeMap</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Integer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> treeMap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">TreeMap</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">c</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">b</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 输出顺序：a=1, b=2, c=3</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h3 id="_4-底层实现" tabindex="-1">4. <strong>底层实现</strong> <a class="header-anchor" href="#_4-底层实现" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>实现类</strong></th><th><strong>数据结构</strong></th><th><strong>冲突解决</strong></th><th><strong>扩容机制</strong></th></tr></thead><tbody><tr><td><code>Hashtable</code></td><td><strong>数组 + 链表</strong></td><td>单链表</td><td>默认容量 11，负载因子 0.75</td></tr><tr><td><code>HashMap</code></td><td><strong>数组 + 链表/红黑树</strong></td><td>链表长度 ≥8 转红黑树</td><td>默认容量 16，负载因子 0.75</td></tr><tr><td><code>TreeMap</code></td><td><strong>红黑树</strong></td><td>树状结构自动平衡</td><td>无需扩容</td></tr></tbody></table><hr><h3 id="_5-性能对比" tabindex="-1">5. <strong>性能对比</strong> <a class="header-anchor" href="#_5-性能对比" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>操作</strong></th><th><strong>Hashtable</strong></th><th><strong>HashMap</strong></th><th><strong>TreeMap</strong></th></tr></thead><tbody><tr><td><strong><code>get()</code>/<code>put()</code></strong></td><td>O(1)（平均，冲突少）</td><td>O(1)（平均，冲突少）</td><td><strong>O(log n)</strong>（红黑树搜索）</td></tr><tr><td><strong>排序操作</strong></td><td>不支持</td><td>不支持</td><td><strong>高效</strong>（<code>firstKey()</code>, <code>subMap()</code>）</td></tr><tr><td><strong>线程安全开销</strong></td><td><strong>高</strong>（同步锁）</td><td>无（需手动同步）</td><td>无（需手动同步）</td></tr></tbody></table><ul><li><strong><code>HashMap</code></strong>：在哈希冲突少时性能最佳（平均 O(1)）。</li><li><strong><code>TreeMap</code></strong>：适合需要有序遍历的场景（如范围查询），但操作成本 O(log n)。</li></ul><hr><h3 id="_6-适用场景" tabindex="-1">6. <strong>适用场景</strong> <a class="header-anchor" href="#_6-适用场景" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>实现类</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><code>Hashtable</code></td><td><strong>遗留代码</strong>或不需高并发的多线程场景（推荐改用 <code>ConcurrentHashMap</code>）。</td></tr><tr><td><code>HashMap</code></td><td><strong>单线程</strong> 或 <strong>手动同步的多线程</strong> 环境（优先选择）。</td></tr><tr><td><code>TreeMap</code></td><td>需 <strong>键排序</strong> 或 <strong>范围查询</strong>（如 <code>keySet().subSet(from, to)</code>）。</td></tr></tbody></table><hr><h3 id="_7-额外特性" tabindex="-1">7. <strong>额外特性</strong> <a class="header-anchor" href="#_7-额外特性" aria-hidden="true">#</a></h3><ul><li><strong><code>HashMap</code></strong>： <ul><li>可指定初始容量和负载因子（优化性能）。</li><li>允许 fail-fast 迭代器（快速失败机制）。</li></ul></li><li><strong><code>TreeMap</code></strong>： <ul><li>实现 <code>NavigableMap</code> 接口，提供导航方法（如 <code>ceilingKey()</code>, <code>floorKey()</code>）。</li><li>支持自定义排序（通过 <code>Comparator</code>）。</li></ul></li></ul><hr><h3 id="代码示例" tabindex="-1">代码示例 <a class="header-anchor" href="#代码示例" aria-hidden="true">#</a></h3><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// HashMap 示例（允许 null）</span></span>
<span class="line"><span style="color:#C792EA;">Map</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Integer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> hashMap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">HashMap</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#A6ACCD;">hashMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">A</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">hashMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(null,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">      </span><span style="color:#676E95;font-style:italic;">// 允许</span></span>
<span class="line"><span style="color:#A6ACCD;">hashMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">B</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null);</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// 允许</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// TreeMap 示例（排序）</span></span>
<span class="line"><span style="color:#C792EA;">TreeMap</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Integer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> treeMap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">TreeMap</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Z</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">A</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">keySet</span><span style="color:#89DDFF;">());</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 输出 [A, Z]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Hashtable 示例（线程安全）</span></span>
<span class="line"><span style="color:#C792EA;">Map</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Integer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> hashtable </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Hashtable</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#A6ACCD;">hashtable</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">C</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// hashtable.put(null, 4); // 抛出 NPE</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="总结对比表" tabindex="-1">总结对比表 <a class="header-anchor" href="#总结对比表" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>特性</strong></th><th><code>Hashtable</code></th><th><code>HashMap</code></th><th><code>TreeMap</code></th></tr></thead><tbody><tr><td><strong>线程安全</strong></td><td>✅（同步方法）</td><td>❌</td><td>❌</td></tr><tr><td><strong>Null 键/值</strong></td><td>❌/❌</td><td>✅/✅</td><td>❌（键）/✅（值）</td></tr><tr><td><strong>数据顺序</strong></td><td>❌</td><td>❌</td><td>✅（按键排序）</td></tr><tr><td><strong>底层结构</strong></td><td>数组+链表</td><td>数组+链表/红黑树</td><td>红黑树</td></tr><tr><td><strong>时间复杂度</strong></td><td>O(1)（平均）</td><td>O(1)（平均）</td><td>O(log n)</td></tr><tr><td><strong>排序支持</strong></td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td><strong>迭代器</strong></td><td>Enumerator</td><td>Iterator（fail-fast）</td><td>Iterator（基于树）</td></tr><tr><td><strong>推荐使用场景</strong></td><td>遗留多线程代码</td><td>通用键值对存储</td><td>需排序或范围查询</td></tr></tbody></table><blockquote><p><strong>推荐实践</strong>：</p><ul><li>优先使用 <code>HashMap</code>（单线程）或 <code>ConcurrentHashMap</code>（多线程）。</li><li>需要排序时选择 <code>TreeMap</code>。</li><li>避免在新代码中使用 <code>Hashtable</code>（遗留类）。</li></ul></blockquote><hr><h1 id="如何保证集合是线程安全的-concurenthashmap-如何实现高效地线程安全" tabindex="-1">如何保证集合是线程安全的 ConcurentHashMap 如何实现高效地线程安全 <a class="header-anchor" href="#如何保证集合是线程安全的-concurenthashmap-如何实现高效地线程安全" aria-hidden="true">#</a></h1><p>在Java中确保集合的线程安全性可以通过多种方式实现，以下是关键方法和原理，并以 <strong>ConcurrentHashMap 的高效线程安全实现</strong> 为核心进行详解：</p><hr><h3 id="一、保证集合线程安全的常见方法" tabindex="-1"><strong>一、保证集合线程安全的常见方法</strong> <a class="header-anchor" href="#一、保证集合线程安全的常见方法" aria-hidden="true">#</a></h3><ol><li><p><strong>互斥同步 (Synchronized Wrappers)</strong> 使用 <code>Collections.synchronizedXXX()</code> 包装集合，所有操作通过 <strong>对象级锁</strong>（如 <code>synchronized (mutex)</code>）实现线程安全：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Map</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> syncMap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Collections</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">synchronizedMap</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">HashMap</span><span style="color:#89DDFF;">&lt;&gt;());</span></span>
<span class="line"></span></code></pre></div><ul><li><strong>优点</strong>：实现简单。</li><li><strong>缺点</strong>：所有操作串行化，<strong>全局锁导致高并发性能低下</strong>。</li></ul></li><li><p><strong>并发集合 (java.util.concurrent)</strong> 使用 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等专为并发设计的容器：</p><ul><li><strong>无锁读操作</strong>：读取通常<strong>不需要加锁</strong>（依赖内存可见性保障）。</li><li><strong>细粒度锁/CAS</strong>：写入时仅锁定部分数据，高并发下性能优异。</li></ul></li></ol><hr><h3 id="二、concurrenthashmap-如何实现高效线程安全" tabindex="-1"><strong>二、ConcurrentHashMap 如何实现高效线程安全</strong> <a class="header-anchor" href="#二、concurrenthashmap-如何实现高效线程安全" aria-hidden="true">#</a></h3><p>以 <strong>JDK 8 后的实现</strong> 为例，核心设计如下：</p><h4 id="_1-底层结构优化" tabindex="-1"><strong>1. 底层结构优化</strong> <a class="header-anchor" href="#_1-底层结构优化" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>组成</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>Node 数组 (table)</strong></td><td>存放键值对的基础数组，长度始终为 2 的幂（方便位运算定位桶）。</td></tr><tr><td><strong>链表 → 红黑树</strong></td><td>单个桶（Bucket）内：链表长度超过阈值（默认8）时转化为树，优化查询效率。</td></tr><tr><td><strong>volatile 修饰</strong></td><td>数组元素 <code>Node.val</code> 和 <code>Node.next</code> 为 <code>volatile</code>，保证内存可见性。</td></tr></tbody></table><h4 id="_2-并发控制机制" tabindex="-1"><strong>2. 并发控制机制</strong> <a class="header-anchor" href="#_2-并发控制机制" aria-hidden="true">#</a></h4><ul><li><strong>CAS (Compare-And-Swap) 操作</strong> 对<strong>桶为空</strong>的情况直接通过 CAS 写入（如 <code>tabAt(tab, i)</code> 和 <code>casTabAt()</code>），避免加锁。</li><li><strong>桶级锁 (Segment-Free)</strong> 对<strong>非空的桶</strong>，使用 <code>synchronized</code> 锁定桶的头节点（精细锁粒度，如锁定链表头或树的根节点）：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">f</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// f 是桶头节点</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">tabAt</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">tab</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> f</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 操作链表或树</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul><h4 id="_3-高效并发操作示例" tabindex="-1"><strong>3. 高效并发操作示例</strong> <a class="header-anchor" href="#_3-高效并发操作示例" aria-hidden="true">#</a></h4><ul><li><strong><code>get(Object key)</code></strong> 无需锁，遍历链表/树（依赖 <code>volatile</code> 变量保障数据可见性）。</li><li><strong><code>put(K key, V value)</code></strong><ol><li>计算哈希，定位桶位置 <code>i</code>。</li><li>若桶为空 → <strong>CAS 插入</strong>。</li><li>若桶非空 → <strong>同步锁头节点</strong> → 插入链表/树。</li><li>若链表超长 → 树化（树节点复用 <code>TreeNode</code>，减少对象开销）。</li></ol></li></ul><h4 id="_4-扩容策略-multi-threaded-transfer" tabindex="-1"><strong>4. 扩容策略 (Multi-Threaded Transfer)</strong> <a class="header-anchor" href="#_4-扩容策略-multi-threaded-transfer" aria-hidden="true">#</a></h4><ul><li><strong>并发扩容迁移</strong> 线程在插入时若检测到 <code>table</code> 在扩容，可<strong>协助迁移数据</strong>（<code>helpTransfer()</code>）。</li><li><strong>分段迁移桶</strong> 将原数组划分为多个区间，不同线程负责不同区间的迁移（迁移完成后标记为 <code>ForwardingNode</code>）。</li><li><strong>非阻塞性</strong> 读操作在迁移过程中可访问旧数组或新数组，无阻塞；写操作参与扩容。</li></ul><h4 id="_5-计数实现-counter-cells" tabindex="-1"><strong>5. 计数实现 (Counter Cells)</strong> <a class="header-anchor" href="#_5-计数实现-counter-cells" aria-hidden="true">#</a></h4><ul><li><strong>LongAdder 思想</strong> 使用 <code>CounterCell[]</code> 分散计数，解决 <code>size()</code> 的原子性瓶颈。</li><li><strong>求和逻辑</strong><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">long</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">sumCount</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">CounterCell</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> cs </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> counterCells</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">long</span><span style="color:#A6ACCD;"> sum </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> baseCount</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">cs </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">CounterCell</span><span style="color:#A6ACCD;"> cell </span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> cs</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">            sum </span><span style="color:#89DDFF;">+=</span><span style="color:#A6ACCD;"> cell</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 分段累加减少冲突</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> sum</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h3 id="三、concurrenthashmap-的优势总结" tabindex="-1"><strong>三、ConcurrentHashMap 的优势总结</strong> <a class="header-anchor" href="#三、concurrenthashmap-的优势总结" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>技术</strong></th><th><strong>解决的问题</strong></th><th><strong>性能影响</strong></th></tr></thead><tbody><tr><td><strong>CAS + 桶锁</strong></td><td>锁粒度从整个表 → 单个桶</td><td>冲突减少 99%（理想情况）</td></tr><tr><td><strong>链表转红黑树</strong></td><td>避免哈希冲突导致的长链表查询退化</td><td>查询复杂度 O(1) → O(log n)</td></tr><tr><td><strong>并发扩容</strong></td><td>多线程协作迁移数据，避免单点性能瓶颈</td><td>扩容期间仍能响应读写请求</td></tr><tr><td><strong>分段计数</strong></td><td>原子计数分摊到多个 Cell，避免自旋阻塞</td><td><code>size()</code> 调用接近常数时间</td></tr></tbody></table><blockquote><p><strong>注</strong>：JDK 7 的分段锁（<code>Segment</code>）因不够灵活已被弃用，JDK 8 的设计实现了更高并发度。</p></blockquote><hr><h3 id="四、与其他线程安全方案的对比" tabindex="-1"><strong>四、与其他线程安全方案的对比</strong> <a class="header-anchor" href="#四、与其他线程安全方案的对比" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>方案</strong></th><th><strong>写入性能</strong></th><th><strong>读取性能</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><code>Collections.synchronizedMap</code></td><td>低（全局锁）</td><td>低（锁竞争）</td><td>简单应用，低并发</td></tr><tr><td><code>Hashtable</code></td><td>低（全局锁）</td><td>低（锁竞争）</td><td>已废弃，不推荐使用</td></tr><tr><td><strong><code>ConcurrentHashMap</code></strong></td><td><strong>高</strong></td><td><strong>极高</strong></td><td>高并发读写</td></tr><tr><td><code>CopyOnWriteArrayList</code></td><td>极低（复制全量数据）</td><td>极高（无锁）</td><td>读多写极少场景</td></tr></tbody></table><hr><h3 id="总结-2" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结-2" aria-hidden="true">#</a></h3><p><strong>ConcurrentHashMap 的高效性源于：</strong> ✅ <strong>桶锁粒度</strong>：仅锁定冲突桶（而非全局）。 ✅ <strong>CAS 无锁写入</strong>：无冲突时直接更新。 ✅ <strong>并发扩容设计</strong>：迁移任务分摊给多个线程。 ✅ <strong>数据结构优化</strong>：红黑树减少哈希冲突导致的性能抖动。</p><p>在实际开发中，对高并发 Map 操作，推荐<strong>始终选择 <code>ConcurrentHashMap</code></strong>，而非基于全表锁的同步包装类。</p><hr><h1 id="java提供了哪些io方式-nio如何实现多路复用" tabindex="-1">java提供了哪些IO方式？NIO如何实现多路复用？ <a class="header-anchor" href="#java提供了哪些io方式-nio如何实现多路复用" aria-hidden="true">#</a></h1><p>Java 提供了多种 I/O 模型以适应不同场景需求，主要分为三类：<strong>BIO（Blocking I/O）</strong>、<strong>NIO（Non-blocking I/O 或 New I/O）</strong> 和 <strong>AIO（Asynchronous I/O）</strong>。</p><hr><h3 id="一、java-提供的-i-o-方式" tabindex="-1"><strong>一、Java 提供的 I/O 方式</strong> <a class="header-anchor" href="#一、java-提供的-i-o-方式" aria-hidden="true">#</a></h3><h4 id="_1-bio-blocking-i-o" tabindex="-1">1. <strong>BIO（Blocking I/O）</strong> <a class="header-anchor" href="#_1-bio-blocking-i-o" aria-hidden="true">#</a></h4><ul><li><strong>特点</strong>：同步阻塞模型，一个连接一个线程。</li><li><strong>工作流程</strong>： <ul><li>当线程调用 <code>read()</code> 或 <code>write()</code> 时，会被阻塞直到数据准备就绪或完成传输。</li></ul></li><li><strong>适用场景</strong>： <ul><li>低并发、连接数较少的场景（如内部系统）。</li></ul></li><li><strong>核心类</strong>： <ul><li><code>InputStream</code> / <code>OutputStream</code>（字节流）</li><li><code>Reader</code> / <code>Writer</code>（字符流）</li><li><code>Socket</code> / <code>ServerSocket</code>（网络通信）</li></ul></li><li><strong>缺点</strong>： <ul><li>线程资源消耗大，高并发时可能导致线程耗尽。</li></ul></li></ul><h4 id="_2-nio-non-blocking-i-o" tabindex="-1">2. <strong>NIO（Non-blocking I/O）</strong> <a class="header-anchor" href="#_2-nio-non-blocking-i-o" aria-hidden="true">#</a></h4><ul><li><strong>特点</strong>：同步非阻塞模型，基于<strong>多路复用（Multiplexing）</strong>，一个线程处理多个连接。</li><li><strong>工作流程</strong>： <ul><li>通道（Channel）注册到选择器（Selector），由 Selector 轮询就绪事件。</li><li>线程不会被 I/O 操作阻塞。</li></ul></li><li><strong>适用场景</strong>： <ul><li>高并发、大量连接但数据量较小的场景（如聊天服务器、网关）。</li></ul></li><li><strong>核心组件</strong>： <ul><li><strong>Buffer（缓冲区）</strong>：<code>ByteBuffer</code> 等，用于数据存储。</li><li><strong>Channel（通道）</strong>：<code>SocketChannel</code>、<code>ServerSocketChannel</code>，支持非阻塞读写。</li><li><strong>Selector（选择器）</strong>：核心多路复用器，监听多个 Channel 的事件。</li></ul></li><li><strong>优点</strong>：减少线程数量，提高资源利用率。</li></ul><h4 id="_3-aio-asynchronous-i-o" tabindex="-1">3. <strong>AIO（Asynchronous I/O）</strong> <a class="header-anchor" href="#_3-aio-asynchronous-i-o" aria-hidden="true">#</a></h4><ul><li><strong>特点</strong>：异步非阻塞模型，基于回调或 Future 通知。</li><li><strong>工作流程</strong>： <ul><li>应用发起 I/O 操作后立即返回，操作系统完成操作后主动回调通知。</li></ul></li><li><strong>适用场景</strong>： <ul><li>高并发且数据量大的场景（如文件操作、长连接）。</li></ul></li><li><strong>核心类</strong>： <ul><li><code>AsynchronousSocketChannel</code> / <code>AsynchronousServerSocketChannel</code></li><li><code>CompletionHandler</code>（回调处理器）</li></ul></li><li><strong>优点</strong>：彻底解放线程，但编程模型较复杂。</li></ul><hr><h3 id="二、nio-多路复用的实现原理" tabindex="-1"><strong>二、NIO 多路复用的实现原理</strong> <a class="header-anchor" href="#二、nio-多路复用的实现原理" aria-hidden="true">#</a></h3><p>多路复用的核心是通过 <strong>Selector</strong> 监控多个 Channel 的 I/O 事件（如连接、读、写），使单线程能够高效管理多个连接。</p><h4 id="关键实现步骤" tabindex="-1">关键实现步骤： <a class="header-anchor" href="#关键实现步骤" aria-hidden="true">#</a></h4><ol><li><p><strong>创建 Selector</strong> 通过静态方法创建选择器：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Selector</span><span style="color:#A6ACCD;"> selector </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Selector</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">open</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>配置 Channel 为非阻塞模式</strong> 将 Channel 设置为非阻塞（必须）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ServerSocketChannel</span><span style="color:#A6ACCD;"> serverChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ServerSocketChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">open</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">serverChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">configureBlocking</span><span style="color:#89DDFF;">(false);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 关键！</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>注册 Channel 到 Selector</strong> 指定要监听的事件（如 <code>OP_ACCEPT</code>、<code>OP_READ</code>）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">serverChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">register</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">selector</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> SelectionKey</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">OP_ACCEPT</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>轮询就绪事件</strong> 调用 <code>select()</code> 阻塞等待事件发生（可设置超时）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(true)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    selector</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">select</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 阻塞直到有就绪事件</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Set</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">SelectionKey</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> keys </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> selector</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">selectedKeys</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Iterator</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">SelectionKey</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> iter </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> keys</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">iterator</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">iter</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hasNext</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">SelectionKey</span><span style="color:#A6ACCD;"> key </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> iter</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">next</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        iter</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">remove</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 移除已处理事件</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 处理事件...</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>处理不同类型的事件</strong> 根据 <code>SelectionKey</code> 的事件类型执行操作：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isAcceptable</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 接受新连接</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">SocketChannel</span><span style="color:#A6ACCD;"> clientChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> serverChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">accept</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    clientChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">configureBlocking</span><span style="color:#89DDFF;">(false);</span></span>
<span class="line"><span style="color:#A6ACCD;">    clientChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">register</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">selector</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> SelectionKey</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">OP_READ</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isReadable</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 读取客户端数据</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">SocketChannel</span><span style="color:#A6ACCD;"> channel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">SocketChannel</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">channel</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">ByteBuffer</span><span style="color:#A6ACCD;"> buffer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ByteBuffer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">allocate</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1024</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    channel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">read</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">buffer</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 处理数据...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isWritable</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 写数据（通常只在需要时才注册写事件）</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ol><hr><h3 id="三、操作系统层面的多路复用机制" tabindex="-1"><strong>三、操作系统层面的多路复用机制</strong> <a class="header-anchor" href="#三、操作系统层面的多路复用机制" aria-hidden="true">#</a></h3><p>Selector 的底层依赖于操作系统的 I/O 多路复用技术：</p><ul><li><strong>Linux</strong>：基于 <strong>epoll</strong>（高效的红黑树 + 事件驱动）</li><li><strong>Windows</strong>：基于 <strong>IOCP</strong>（I/O Completion Port）</li><li><strong>macOS/BSD</strong>：基于 <strong>kqueue</strong></li></ul><p>以 Linux 的 epoll 为例：</p><ol><li><strong>创建 epoll 实例</strong><code>epoll_create()</code> 初始化一个事件表。</li><li><strong>注册文件描述符（FD）</strong><code>epoll_ctl()</code> 将 Socket FD 加入 epoll，监听事件（EPOLLIN/EPOLLOUT）。</li><li><strong>等待事件就绪</strong><code>epoll_wait()</code> 阻塞直到有 FD 就绪，返回就绪的 FD 列表。</li><li><strong>处理事件</strong> 遍历就绪列表进行读写操作（非阻塞）。</li></ol><blockquote><p><strong>Java NIO 与 epoll 的关系</strong> 当调用 <code>Selector.open()</code> 时，Java 默认使用 <code>EPollSelectorProvider</code>（Linux）创建 epoll 实例，最终通过 <code>native</code> 方法调用操作系统 API。</p></blockquote><hr><h3 id="四、多路复用的优势与局限性" tabindex="-1"><strong>四、多路复用的优势与局限性</strong> <a class="header-anchor" href="#四、多路复用的优势与局限性" aria-hidden="true">#</a></h3><h4 id="优势" tabindex="-1"><strong>优势</strong>： <a class="header-anchor" href="#优势" aria-hidden="true">#</a></h4><ol><li><strong>高并发支撑</strong> 单线程可处理数万连接，避免 BIO 的线程爆炸问题。</li><li><strong>资源高效</strong> 减少线程上下文切换和内存占用。</li><li><strong>延迟优化</strong> 事件就绪时才触发操作，响应速度更快。</li></ol><h4 id="局限性" tabindex="-1"><strong>局限性</strong>： <a class="header-anchor" href="#局限性" aria-hidden="true">#</a></h4><ol><li><strong>编程复杂</strong> 需处理缓冲区、事件状态等细节。</li><li><strong>数据量小时高效</strong> 长连接处理大文件时仍可能阻塞（需配合线程池）。</li><li><strong>平台差异</strong> 不同操作系统的实现存在性能差异（epoll 最优）。</li></ol><hr><h3 id="总结-3" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结-3" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>I/O 模型</strong></th><th>阻塞方式</th><th>线程要求</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>BIO</strong></td><td>同步阻塞</td><td>一连接一线程</td><td>低并发、简单应用</td></tr><tr><td><strong>NIO</strong></td><td>同步非阻塞</td><td>多路复用单/少线程</td><td>高并发、短连接（如 Web）</td></tr><tr><td><strong>AIO</strong></td><td>异步非阻塞</td><td>回调/Future</td><td>高吞吐、长连接（如文件）</td></tr></tbody></table><p>多路复用是 NIO 的核心，通过 <strong>Selector + Channel + Buffer</strong> 组合，结合操作系统的 epoll/kqueue/IOCP 机制，实现高效的 I/O 管理。尽管编程模型复杂，但在高并发场景下优势显著，是构建高性能网络服务的基石。</p><hr><h1 id="java提供了哪些io方式-nio如何实现多路复用-1" tabindex="-1">java提供了哪些IO方式？NIO如何实现多路复用？ <a class="header-anchor" href="#java提供了哪些io方式-nio如何实现多路复用-1" aria-hidden="true">#</a></h1><p>Java 提供了多种 I/O 模型以适应不同场景需求，主要分为三类：<strong>BIO（Blocking I/O）</strong>、<strong>NIO（Non-blocking I/O 或 New I/O）</strong> 和 <strong>AIO（Asynchronous I/O）</strong>。</p><hr><h3 id="一、java-提供的-i-o-方式-1" tabindex="-1"><strong>一、Java 提供的 I/O 方式</strong> <a class="header-anchor" href="#一、java-提供的-i-o-方式-1" aria-hidden="true">#</a></h3><h4 id="_1-bio-blocking-i-o-1" tabindex="-1">1. <strong>BIO（Blocking I/O）</strong> <a class="header-anchor" href="#_1-bio-blocking-i-o-1" aria-hidden="true">#</a></h4><ul><li><strong>特点</strong>：同步阻塞模型，一个连接一个线程。</li><li><strong>工作流程</strong>： <ul><li>当线程调用 <code>read()</code> 或 <code>write()</code> 时，会被阻塞直到数据准备就绪或完成传输。</li></ul></li><li><strong>适用场景</strong>： <ul><li>低并发、连接数较少的场景（如内部系统）。</li></ul></li><li><strong>核心类</strong>： <ul><li><code>InputStream</code> / <code>OutputStream</code>（字节流）</li><li><code>Reader</code> / <code>Writer</code>（字符流）</li><li><code>Socket</code> / <code>ServerSocket</code>（网络通信）</li></ul></li><li><strong>缺点</strong>： <ul><li>线程资源消耗大，高并发时可能导致线程耗尽。</li></ul></li></ul><h4 id="_2-nio-non-blocking-i-o-1" tabindex="-1">2. <strong>NIO（Non-blocking I/O）</strong> <a class="header-anchor" href="#_2-nio-non-blocking-i-o-1" aria-hidden="true">#</a></h4><ul><li><strong>特点</strong>：同步非阻塞模型，基于<strong>多路复用（Multiplexing）</strong>，一个线程处理多个连接。</li><li><strong>工作流程</strong>： <ul><li>通道（Channel）注册到选择器（Selector），由 Selector 轮询就绪事件。</li><li>线程不会被 I/O 操作阻塞。</li></ul></li><li><strong>适用场景</strong>： <ul><li>高并发、大量连接但数据量较小的场景（如聊天服务器、网关）。</li></ul></li><li><strong>核心组件</strong>： <ul><li><strong>Buffer（缓冲区）</strong>：<code>ByteBuffer</code> 等，用于数据存储。</li><li><strong>Channel（通道）</strong>：<code>SocketChannel</code>、<code>ServerSocketChannel</code>，支持非阻塞读写。</li><li><strong>Selector（选择器）</strong>：核心多路复用器，监听多个 Channel 的事件。</li></ul></li><li><strong>优点</strong>：减少线程数量，提高资源利用率。</li></ul><h4 id="_3-aio-asynchronous-i-o-1" tabindex="-1">3. <strong>AIO（Asynchronous I/O）</strong> <a class="header-anchor" href="#_3-aio-asynchronous-i-o-1" aria-hidden="true">#</a></h4><ul><li><strong>特点</strong>：异步非阻塞模型，基于回调或 Future 通知。</li><li><strong>工作流程</strong>： <ul><li>应用发起 I/O 操作后立即返回，操作系统完成操作后主动回调通知。</li></ul></li><li><strong>适用场景</strong>： <ul><li>高并发且数据量大的场景（如文件操作、长连接）。</li></ul></li><li><strong>核心类</strong>： <ul><li><code>AsynchronousSocketChannel</code> / <code>AsynchronousServerSocketChannel</code></li><li><code>CompletionHandler</code>（回调处理器）</li></ul></li><li><strong>优点</strong>：彻底解放线程，但编程模型较复杂。</li></ul><hr><h3 id="二、nio-多路复用的实现原理-1" tabindex="-1"><strong>二、NIO 多路复用的实现原理</strong> <a class="header-anchor" href="#二、nio-多路复用的实现原理-1" aria-hidden="true">#</a></h3><p>多路复用的核心是通过 <strong>Selector</strong> 监控多个 Channel 的 I/O 事件（如连接、读、写），使单线程能够高效管理多个连接。</p><h4 id="关键实现步骤-1" tabindex="-1">关键实现步骤： <a class="header-anchor" href="#关键实现步骤-1" aria-hidden="true">#</a></h4><ol><li><p><strong>创建 Selector</strong> 通过静态方法创建选择器：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Selector</span><span style="color:#A6ACCD;"> selector </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Selector</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">open</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>配置 Channel 为非阻塞模式</strong> 将 Channel 设置为非阻塞（必须）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ServerSocketChannel</span><span style="color:#A6ACCD;"> serverChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ServerSocketChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">open</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">serverChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">configureBlocking</span><span style="color:#89DDFF;">(false);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 关键！</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>注册 Channel 到 Selector</strong> 指定要监听的事件（如 <code>OP_ACCEPT</code>、<code>OP_READ</code>）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">serverChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">register</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">selector</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> SelectionKey</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">OP_ACCEPT</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>轮询就绪事件</strong> 调用 <code>select()</code> 阻塞等待事件发生（可设置超时）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(true)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    selector</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">select</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 阻塞直到有就绪事件</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Set</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">SelectionKey</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> keys </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> selector</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">selectedKeys</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Iterator</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">SelectionKey</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> iter </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> keys</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">iterator</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">iter</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hasNext</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">SelectionKey</span><span style="color:#A6ACCD;"> key </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> iter</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">next</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        iter</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">remove</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 移除已处理事件</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 处理事件...</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>处理不同类型的事件</strong> 根据 <code>SelectionKey</code> 的事件类型执行操作：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isAcceptable</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 接受新连接</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">SocketChannel</span><span style="color:#A6ACCD;"> clientChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> serverChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">accept</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    clientChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">configureBlocking</span><span style="color:#89DDFF;">(false);</span></span>
<span class="line"><span style="color:#A6ACCD;">    clientChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">register</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">selector</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> SelectionKey</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">OP_READ</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isReadable</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 读取客户端数据</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">SocketChannel</span><span style="color:#A6ACCD;"> channel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">SocketChannel</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">channel</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">ByteBuffer</span><span style="color:#A6ACCD;"> buffer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ByteBuffer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">allocate</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1024</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    channel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">read</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">buffer</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 处理数据...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isWritable</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 写数据（通常只在需要时才注册写事件）</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ol><hr><h3 id="三、操作系统层面的多路复用机制-1" tabindex="-1"><strong>三、操作系统层面的多路复用机制</strong> <a class="header-anchor" href="#三、操作系统层面的多路复用机制-1" aria-hidden="true">#</a></h3><p>Selector 的底层依赖于操作系统的 I/O 多路复用技术：</p><ul><li><strong>Linux</strong>：基于 <strong>epoll</strong>（高效的红黑树 + 事件驱动）</li><li><strong>Windows</strong>：基于 <strong>IOCP</strong>（I/O Completion Port）</li><li><strong>macOS/BSD</strong>：基于 <strong>kqueue</strong></li></ul><p>以 Linux 的 epoll 为例：</p><ol><li><strong>创建 epoll 实例</strong><code>epoll_create()</code> 初始化一个事件表。</li><li><strong>注册文件描述符（FD）</strong><code>epoll_ctl()</code> 将 Socket FD 加入 epoll，监听事件（EPOLLIN/EPOLLOUT）。</li><li><strong>等待事件就绪</strong><code>epoll_wait()</code> 阻塞直到有 FD 就绪，返回就绪的 FD 列表。</li><li><strong>处理事件</strong> 遍历就绪列表进行读写操作（非阻塞）。</li></ol><blockquote><p><strong>Java NIO 与 epoll 的关系</strong> 当调用 <code>Selector.open()</code> 时，Java 默认使用 <code>EPollSelectorProvider</code>（Linux）创建 epoll 实例，最终通过 <code>native</code> 方法调用操作系统 API。</p></blockquote><hr><h3 id="四、多路复用的优势与局限性-1" tabindex="-1"><strong>四、多路复用的优势与局限性</strong> <a class="header-anchor" href="#四、多路复用的优势与局限性-1" aria-hidden="true">#</a></h3><h4 id="优势-1" tabindex="-1"><strong>优势</strong>： <a class="header-anchor" href="#优势-1" aria-hidden="true">#</a></h4><ol><li><strong>高并发支撑</strong> 单线程可处理数万连接，避免 BIO 的线程爆炸问题。</li><li><strong>资源高效</strong> 减少线程上下文切换和内存占用。</li><li><strong>延迟优化</strong> 事件就绪时才触发操作，响应速度更快。</li></ol><h4 id="局限性-1" tabindex="-1"><strong>局限性</strong>： <a class="header-anchor" href="#局限性-1" aria-hidden="true">#</a></h4><ol><li><strong>编程复杂</strong> 需处理缓冲区、事件状态等细节。</li><li><strong>数据量小时高效</strong> 长连接处理大文件时仍可能阻塞（需配合线程池）。</li><li><strong>平台差异</strong> 不同操作系统的实现存在性能差异（epoll 最优）。</li></ol><hr><h3 id="总结-4" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结-4" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>I/O 模型</strong></th><th>阻塞方式</th><th>线程要求</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>BIO</strong></td><td>同步阻塞</td><td>一连接一线程</td><td>低并发、简单应用</td></tr><tr><td><strong>NIO</strong></td><td>同步非阻塞</td><td>多路复用单/少线程</td><td>高并发、短连接（如 Web）</td></tr><tr><td><strong>AIO</strong></td><td>异步非阻塞</td><td>回调/Future</td><td>高吞吐、长连接（如文件）</td></tr></tbody></table><p>多路复用是 NIO 的核心，通过 <strong>Selector + Channel + Buffer</strong> 组合，结合操作系统的 epoll/kqueue/IOCP 机制，实现高效的 I/O 管理。尽管编程模型复杂，但在高并发场景下优势显著，是构建高性能网络服务的基石。</p><hr><h1 id="java中有几种文件拷贝方式-那种最高效" tabindex="-1">java中有几种文件拷贝方式？那种最高效？ <a class="header-anchor" href="#java中有几种文件拷贝方式-那种最高效" aria-hidden="true">#</a></h1><p>在Java中，实现文件拷贝主要有以下几种方式，效率从低到高排列：</p><h3 id="_1-传统的流-java-io包" tabindex="-1">1. <strong>传统的流（<code>java.io</code>包）</strong> <a class="header-anchor" href="#_1-传统的流-java-io包" aria-hidden="true">#</a></h3><ul><li>使用<code>FileInputStream</code> + <code>FileOutputStream</code></li><li>使用 <strong>缓冲流</strong>（<code>BufferedInputStream</code> + <code>BufferedOutputStream</code>）</li><li><strong>优点</strong>：兼容性好（Java 1.0+）</li><li><strong>缺点</strong>：多级缓冲可能带来额外开销</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">InputStream</span><span style="color:#A6ACCD;"> is </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">BufferedInputStream</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">FileInputStream</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">source.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">));</span></span>
<span class="line"><span style="color:#A6ACCD;">     </span><span style="color:#C792EA;">OutputStream</span><span style="color:#A6ACCD;"> os </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">BufferedOutputStream</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">FileOutputStream</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">target.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">byte</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> buffer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">byte</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">8192</span><span style="color:#89DDFF;">];</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 8KB缓冲区</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> len</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">((</span><span style="color:#A6ACCD;">len </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> is</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">read</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">buffer</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        os</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">write</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">buffer</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> len</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="_2-nio-的-filechannel" tabindex="-1">2. <strong>NIO 的 <code>FileChannel</code></strong> <a class="header-anchor" href="#_2-nio-的-filechannel" aria-hidden="true">#</a></h3><ul><li>使用<code>transferTo()</code>或<code>transferFrom()</code> <strong>（效率最高）</strong></li><li><strong>优点</strong>：利用操作系统零拷贝（zero-copy），减少内核态与用户态切换</li><li><strong>适用场景</strong>：大文件拷贝</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">FileChannel</span><span style="color:#A6ACCD;"> srcChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">FileInputStream</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">source.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">getChannel</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">     </span><span style="color:#C792EA;">FileChannel</span><span style="color:#A6ACCD;"> destChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">FileOutputStream</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">target.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">getChannel</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    srcChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">transferTo</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> srcChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">size</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> destChannel</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 或 destChannel.transferFrom(srcChannel, 0, srcChannel.size());</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="_3-files-copy-工具方法-推荐" tabindex="-1">3. <strong><code>Files.copy()</code> 工具方法（推荐）</strong> <a class="header-anchor" href="#_3-files-copy-工具方法-推荐" aria-hidden="true">#</a></h3><ul><li>Java 7+ <code>java.nio.file.Files</code></li><li><strong>内部优化</strong>：自动选择<code>FileChannel</code>或流（根据不同操作系统）</li><li><strong>优点</strong>：代码简洁高效</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Path</span><span style="color:#A6ACCD;"> source </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Paths</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">source.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#C792EA;">Path</span><span style="color:#A6ACCD;"> target </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Paths</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">target.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">Files</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">copy</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">source</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> StandardCopyOption</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">REPLACE_EXISTING</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="_4-内存映射文件-mappedbytebuffer" tabindex="-1">4. <strong>内存映射文件（MappedByteBuffer）</strong> <a class="header-anchor" href="#_4-内存映射文件-mappedbytebuffer" aria-hidden="true">#</a></h3><ul><li>适用于频繁读写时，但<strong>拷贝场景不常用</strong></li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">RandomAccessFile</span><span style="color:#A6ACCD;"> srcFile </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">RandomAccessFile</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">source.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">r</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">     </span><span style="color:#C792EA;">RandomAccessFile</span><span style="color:#A6ACCD;"> destFile </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">RandomAccessFile</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">target.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">rw</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">FileChannel</span><span style="color:#A6ACCD;"> srcChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> srcFile</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getChannel</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">FileChannel</span><span style="color:#A6ACCD;"> destChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> destFile</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getChannel</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">MappedByteBuffer</span><span style="color:#A6ACCD;"> srcBuffer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> srcChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">map</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">FileChannel</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">MapMode</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">READ_ONLY</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> srcChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">size</span><span style="color:#89DDFF;">());</span></span>
<span class="line"><span style="color:#A6ACCD;">    destChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">write</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">srcBuffer</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="✅-效率终极排行-大文件场景" tabindex="-1">✅ 效率终极排行（大文件场景） <a class="header-anchor" href="#✅-效率终极排行-大文件场景" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>方式</strong></th><th><strong>效率</strong></th><th><strong>推荐指数</strong></th><th>特点</th></tr></thead><tbody><tr><td><code>FileChannel.transferTo()</code></td><td>⭐⭐⭐⭐⭐</td><td>最高</td><td>零拷贝优化，内核层直接操作</td></tr><tr><td><code>Files.copy()</code></td><td>⭐⭐⭐⭐</td><td>首选</td><td>内部优化，简洁可靠</td></tr><tr><td>缓冲流（带缓冲区）</td><td>⭐⭐⭐</td><td>一般</td><td>兼容性强</td></tr><tr><td>普通I/O流</td><td>⭐⭐</td><td>不推荐</td><td>未缓冲，性能差</td></tr><tr><td><code>MappedByteBuffer</code></td><td>⭐⭐⭐</td><td>非拷贝首选</td><td>适合随机访问</td></tr></tbody></table><hr><h3 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-hidden="true">#</a></h3><ul><li><p><strong>最高效的方式</strong>：<strong><code>FileChannel.transferTo()</code></strong> 或 <strong><code>transferFrom()</code></strong> （利用操作系统零拷贝，减少用户态-内核态切换，尤其适合大文件）</p></li><li><p><strong>日常开发推荐</strong>：<strong><code>Files.copy()</code></strong> （API简洁，内置优化，无需手动管理缓冲区和流）</p></li></ul><blockquote><p>💡 <strong>性能对比</strong>（实际测试参考）：</p><ul><li>对于数GB级大文件，<code>FileChannel</code>比传统流快 20%~50%</li><li><code>Files.copy()</code> 在多数JDK中自动调用 <code>FileChannel</code>，几乎等效</li></ul></blockquote><p>建议：优先使用 <strong><code>Files.copy()</code></strong>，需要极致性能时手动使用 <strong><code>FileChannel</code></strong>。</p><hr><h1 id="谈谈接口和抽象类有什么区别" tabindex="-1">谈谈接口和抽象类有什么区别？ <a class="header-anchor" href="#谈谈接口和抽象类有什么区别" aria-hidden="true">#</a></h1><p>在Java中，接口（<code>interface</code>）和抽象类（<code>abstract class</code>）都是实现抽象和多态的关键机制，但它们在使用场景和特性上有显著区别。以下是核心区别对比：</p><hr><h3 id="_1-继承与实现" tabindex="-1"><strong>1. 继承与实现</strong> <a class="header-anchor" href="#_1-继承与实现" aria-hidden="true">#</a></h3><ul><li><p><strong>抽象类</strong>：</p><ul><li>子类通过 <code>extends</code> <strong>继承</strong>，<strong>单继承</strong>（Java不支持多继承）。</li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Animal</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*...*/</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Dog</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Animal</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*...*/</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong>接口</strong>：</p><ul><li>类通过 <code>implements</code> <strong>实现</strong>，<strong>支持多实现</strong>。</li><li>接口可通过 <code>extends</code> <strong>继承其他接口</strong>（支持多继承）。</li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Flyable</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">fly</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Swimmable</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">swim</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Duck</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Flyable</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Swimmable</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*...*/</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 多实现</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><hr><h3 id="_2-构造方法" tabindex="-1"><strong>2. 构造方法</strong> <a class="header-anchor" href="#_2-构造方法" aria-hidden="true">#</a></h3><ul><li><p><strong>抽象类</strong>：</p><ul><li><strong>可以包含构造方法</strong>（用于初始化成员变量）。</li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Shape</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> color</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Shape</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">color</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">color </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> color</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 构造方法</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong>接口</strong>：</p><ul><li><strong>不允许有构造方法</strong>（不能被实例化）。</li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Usb</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 不能有构造方法 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><hr><h3 id="_3-成员变量" tabindex="-1"><strong>3. 成员变量</strong> <a class="header-anchor" href="#_3-成员变量" aria-hidden="true">#</a></h3><ul><li><p><strong>抽象类</strong>：</p><ul><li>可以包含<strong>任意类型成员变量</strong>（<code>private</code>/<code>protected</code>/<code>public</code>）。</li><li>变量可以是<strong>非静态</strong>、<strong>非final</strong>的。</li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Animal</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">protected</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> age</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 非final变量</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong>接口</strong>：</p><ul><li>变量<strong>默认是 <code>public static final</code></strong>（常量）。</li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Constants</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> DEFAULT_NAME </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">UNKNOWN</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 等同于 public static final</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><hr><h3 id="_4-方法实现" tabindex="-1"><strong>4. 方法实现</strong> <a class="header-anchor" href="#_4-方法实现" aria-hidden="true">#</a></h3><ul><li><p><strong>抽象类</strong>：</p><ul><li>可以包含： <ul><li><strong>抽象方法</strong>（无实现）。</li><li><strong>具体方法</strong>（有实现）。</li><li><strong>静态方法</strong>。</li><li><strong>private方法</strong>（Java 9+）。</li></ul></li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Vehicle</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 抽象方法</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">stop</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">           </span><span style="color:#676E95;font-style:italic;">// 具体方法</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Stopped.</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong>接口</strong>：</p><ul><li><strong>Java 8前</strong>：只能有抽象方法。</li><li><strong>Java 8+</strong>： <ul><li><strong>默认方法</strong>（<code>default</code>修饰，提供默认实现）。</li><li><strong>静态方法</strong>（有实现）。</li><li><strong>私有方法</strong>（Java 9+）。</li></ul></li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Logger</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">log</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">msg</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">          </span><span style="color:#676E95;font-style:italic;">// 抽象方法</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">logError</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">msg</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 默认方法</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ERROR: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> msg</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getVersion</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">   </span><span style="color:#676E95;font-style:italic;">// 静态方法</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1.0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><hr><h3 id="_5-设计目的" tabindex="-1"><strong>5. 设计目的</strong> <a class="header-anchor" href="#_5-设计目的" aria-hidden="true">#</a></h3><ul><li><p><strong>抽象类</strong>：</p><ul><li><strong>描述“是什么”（is-a关系）</strong>：聚焦<strong>本质抽象</strong>（如 <code>Animal</code> 是 <code>Dog</code> 的抽象）。</li><li>适合<strong>共享代码逻辑</strong>（子类复用父类的具体方法）。</li></ul></li><li><p><strong>接口</strong>：</p><ul><li><strong>描述“能做什么”（has-a关系）</strong>：聚焦<strong>行为抽象</strong>（如 <code>Flyable</code> 定义飞行能力）。</li><li>实现<strong>解耦</strong>与<strong>多态扩展</strong>，避免单继承限制。</li></ul></li></ul><hr><h3 id="_6-实际应用场景" tabindex="-1"><strong>6. 实际应用场景</strong> <a class="header-anchor" href="#_6-实际应用场景" aria-hidden="true">#</a></h3><ul><li><p><strong>使用抽象类</strong>：</p><ul><li>需要定义<strong>部分具体实现</strong>（如模板方法模式）。</li><li>多个类有<strong>共享状态或代码</strong>（如 <code>GameCharacter</code> 抽象类包含公共的 <code>health</code> 属性和 <code>render()</code> 方法）。</li></ul></li><li><p><strong>使用接口</strong>：</p><ul><li><strong>定义行为契约</strong>（如 <code>Comparable&lt;T&gt;</code> 实现对象比较）。</li><li><strong>实现多态扩展</strong>（如 <code>List</code> 接口有 <code>ArrayList</code>/<code>LinkedList</code> 等不同实现）。</li><li><strong>解决多重继承问题</strong>（类可实现多个接口）。</li></ul></li></ul><hr><h3 id="总结对比表-1" tabindex="-1"><strong>总结对比表</strong> <a class="header-anchor" href="#总结对比表-1" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>抽象类</strong></th><th><strong>接口</strong></th></tr></thead><tbody><tr><td>继承方式</td><td><code>extends</code>（单继承）</td><td><code>implements</code>（多实现）</td></tr><tr><td>构造方法</td><td>✅ 有</td><td>❌ 无</td></tr><tr><td>成员变量</td><td>✅ 任意类型</td><td>❌ 只能是 <code>public static final</code> 常量</td></tr><tr><td>方法实现</td><td>✅ 可含具体方法、抽象方法</td><td>✅ Java 8+ 支持 <code>default</code>/静态方法</td></tr><tr><td>多继承</td><td>❌ Java不支持</td><td>✅ 接口可多继承其他接口</td></tr><tr><td>设计目标</td><td><strong>代码复用 + 部分抽象</strong></td><td><strong>行为抽象 + 解耦</strong></td></tr><tr><td>关系</td><td>子类是父类的具体类型（<strong>is-a</strong>）</td><td>实现类具有某种能力（<strong>like-a</strong>）</td></tr></tbody></table><hr><h3 id="何时选择" tabindex="-1"><strong>何时选择？</strong> <a class="header-anchor" href="#何时选择" aria-hidden="true">#</a></h3><ul><li><p><strong>优先选接口</strong>： 需要定义行为契约、实现多态解耦，或类已有父类但需扩展能力（如 <code>Dog extends Animal implements GuardDog</code>）。</p></li><li><p><strong>选抽象类</strong>： 多个类需复用公共代码/状态，且逻辑是紧密相关的同一类实体（如不同 <code>PaymentMethod</code> 共享支付验证逻辑）。</p></li></ul><blockquote><p>💡 <strong>行业实践</strong>： 现代Java开发中，接口更常用（尤其是配合<code>default</code>方法），仅在需要共享代码或状态时使用抽象类。</p></blockquote><hr><h1 id="java中谈谈你知道的设计模式" tabindex="-1">java中谈谈你知道的设计模式？ <a class="header-anchor" href="#java中谈谈你知道的设计模式" aria-hidden="true">#</a></h1><h2 id="java中的设计模式-程序员的必修课" tabindex="-1">Java中的设计模式：程序员的必修课 <a class="header-anchor" href="#java中的设计模式-程序员的必修课" aria-hidden="true">#</a></h2><p>在Java开发中，设计模式（Design Pattern）是经过反复实践、被多数人知晓、并经过分类编目的优秀代码设计经验的总结。它并非一种具体的技术或代码，而是一种在特定情境下解决常见问题的通用、可复用的解决方案。熟练掌握和运用设计模式，可以显著提升代码的可重用性、可读性、可维护性和健壮性，是衡量一位程序员内功是否深厚的重要指标。</p><p>这些模式的“圣经”通常指的是由Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides四位作者（被称为“四人帮”，Gang of Four，简称GoF）合著的《设计模式：可复用面向对象软件的基础》一书，书中详细描述了23种经典的设计模式。</p><p>这些设计模式通常被分为三大类：<strong>创建型（Creational）</strong>、<strong>结构型（Structural）</strong> 和 <strong>行为型（Behavioral）</strong>。</p><hr><h3 id="一、-创建型模式-creational-patterns" tabindex="-1">一、 创建型模式 (Creational Patterns) <a class="header-anchor" href="#一、-创建型模式-creational-patterns" aria-hidden="true">#</a></h3><p>创建型模式的核心在于<strong>对象的创建</strong>，它们将对象的创建和使用过程解耦，使得系统在创建对象时能有更大的灵活性。</p><h4 id="_1-单例模式-singleton" tabindex="-1">1. 单例模式 (Singleton) <a class="header-anchor" href="#_1-单例模式-singleton" aria-hidden="true">#</a></h4><p><strong>核心思想：</strong> 保证一个类只有一个实例，并提供一个全局访问点。</p><p><strong>应用场景：</strong> 当系统中某个类只需要一个实例时，例如线程池、缓存、日志对象、数据库连接池等。</p><p><strong>实现方式：</strong></p><ul><li><p><strong>饿汉式 (Eager Initialization):</strong> 类加载时就立即创建实例，线程安全，但可能造成资源浪费。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Singleton</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Singleton</span><span style="color:#A6ACCD;"> INSTANCE </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Singleton</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Singleton</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Singleton</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getInstance</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> INSTANCE</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>懒汉式 (Lazy Initialization):</strong> 第一次调用<code>getInstance()</code>时才创建实例。需要处理多线程同步问题。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Singleton</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">volatile</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Singleton</span><span style="color:#A6ACCD;"> instance</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// volatile保证可见性</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Singleton</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Singleton</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getInstance</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">instance </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Singleton</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">instance </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                    instance </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Singleton</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> instance</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><em>上述为双重检查锁定（Double-Checked Locking）实现，是懒汉式中推荐的写法。</em></p></li></ul><h4 id="_2-工厂方法模式-factory-method" tabindex="-1">2. 工厂方法模式 (Factory Method) <a class="header-anchor" href="#_2-工厂方法模式-factory-method" aria-hidden="true">#</a></h4><p><strong>核心思想：</strong> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p><p><strong>应用场景：</strong> 当一个类不知道它所需要的对象的类时，或者当一个类希望由它的子类来指定它所创建的对象时。例如，Java中的<code>java.util.Calendar#getInstance()</code>。</p><p><strong>结构：</strong></p><ul><li><strong>Product (产品接口):</strong> 定义了工厂方法所创建的对象的接口。</li><li><strong>ConcreteProduct (具体产品):</strong> 实现Product接口。</li><li><strong>Factory (工厂接口):</strong> 声明工厂方法，该方法返回一个Product类型的对象。</li><li><strong>ConcreteFactory (具体工厂):</strong> 实现Factory接口，覆盖工厂方法以返回一个ConcreteProduct实例。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 产品接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Logger</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">log</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">message</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 具体产品</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FileLogger</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Logger</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">log</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">message</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 写入文件 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">DatabaseLogger</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Logger</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">log</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">message</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 写入数据库 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 工厂接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">LoggerFactory</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Logger</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createLogger</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 具体工厂</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FileLoggerFactory</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">LoggerFactory</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Logger</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createLogger</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">FileLogger</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">DatabaseLoggerFactory</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">LoggerFactory</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Logger</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createLogger</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">DatabaseLogger</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h4 id="_3-抽象工厂模式-abstract-factory" tabindex="-1">3. 抽象工厂模式 (Abstract Factory) <a class="header-anchor" href="#_3-抽象工厂模式-abstract-factory" aria-hidden="true">#</a></h4><p><strong>核心思想：</strong> 提供一个接口，用于创建<strong>一系列相关或相互依赖的对象</strong>，而无需指定它们具体的类。</p><p><strong>应用场景：</strong> 当系统需要独立于其产品的创建、组合和表示时。例如，更换UI主题（一套按钮、文本框等）。</p><p><strong>与工厂方法的区别：</strong> 工厂方法模式针对的是一个产品等级结构，而抽象工厂模式针对的是多个产品等级结构（一个产品族）。</p><hr><h3 id="二、-结构型模式-structural-patterns" tabindex="-1">二、 结构型模式 (Structural Patterns) <a class="header-anchor" href="#二、-结构型模式-structural-patterns" aria-hidden="true">#</a></h3><p>结构型模式关注<strong>类和对象的组合</strong>，通过继承、组合等方式形成更大的结构，以适应更复杂的业务需求。</p><h4 id="_1-适配器模式-adapter" tabindex="-1">1. 适配器模式 (Adapter) <a class="header-anchor" href="#_1-适配器模式-adapter" aria-hidden="true">#</a></h4><p><strong>核心思想：</strong> 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>应用场景：</strong> 在系统中使用一个已经存在的类，而它的接口不符合系统的需要时。例如，<code>java.io.InputStreamReader</code> 将 <code>InputStream</code> (字节流) 适配成 <code>Reader</code> (字符流)。</p><p><strong>实现方式：</strong></p><ul><li><strong>类适配器：</strong> 通过继承实现。</li><li><strong>对象适配器：</strong> 通过组合（持有被适配对象的引用）实现，更为常用和灵活。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 目标接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Target</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">request</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 被适配的类</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Adaptee</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">specificRequest</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">被适配类的特殊请求。</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 对象适配器</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Adapter</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Target</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Adaptee</span><span style="color:#A6ACCD;"> adaptee</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Adapter</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Adaptee</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">adaptee</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">adaptee </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> adaptee</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">request</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        adaptee</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">specificRequest</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h4 id="_2-装饰器模式-decorator" tabindex="-1">2. 装饰器模式 (Decorator) <a class="header-anchor" href="#_2-装饰器模式-decorator" aria-hidden="true">#</a></h4><p><strong>核心思想：</strong> 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p><strong>应用场景：</strong> 需要在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。例如，Java IO中的各种输入输出流，如 <code>BufferedInputStream</code> 装饰了 <code>FileInputStream</code> 增加了缓冲功能。</p><p><strong>结构：</strong></p><ul><li><strong>Component (组件接口):</strong> 定义一个对象接口。</li><li><strong>ConcreteComponent (具体组件):</strong> 定义了一个具体的对象，也可以给这个对象添加一些职责。</li><li><strong>Decorator (装饰器):</strong> 持有一个Component对象的引用，并定义一个与Component接口一致的接口。</li><li><strong>ConcreteDecorator (具体装饰器):</strong> 负责给组件对象添加职责。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 组件接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Coffee</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">double</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getCost</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getDescription</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 具体组件</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SimpleCoffee</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Coffee</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">double</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getCost</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getDescription</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">简单咖啡</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 装饰器</span></span>
<span class="line"><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">CoffeeDecorator</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Coffee</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">protected</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Coffee</span><span style="color:#A6ACCD;"> decoratedCoffee</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">CoffeeDecorator</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Coffee</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">coffee</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">decoratedCoffee </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> coffee</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">double</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getCost</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> decoratedCoffee</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getCost</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getDescription</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> decoratedCoffee</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getDescription</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 具体装饰器</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">WithMilk</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">CoffeeDecorator</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">WithMilk</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Coffee</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">c</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> super</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">c</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">double</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getCost</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> super</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getCost</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getDescription</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> super</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getDescription</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">, 加牛奶</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h4 id="_3-代理模式-proxy" tabindex="-1">3. 代理模式 (Proxy) <a class="header-anchor" href="#_3-代理模式-proxy" aria-hidden="true">#</a></h4><p><strong>核心思想：</strong> 为其他对象提供一种代理以控制对这个对象的访问。</p><p><strong>应用场景：</strong> 当需要控制对一个对象的访问时，可以增加一些额外的处理，如权限控制、懒加载、日志记录等。例如，Spring AOP的实现就大量用到了代理模式。</p><p><strong>分类：</strong></p><ul><li><strong>静态代理：</strong> 代理类和被代理类在编译期就确定下来。</li><li><strong>动态代理：</strong> 在运行时动态生成代理类。Java中主要通过 <code>java.lang.reflect.Proxy</code> (基于接口) 和 CGLIB (基于子类) 实现。</li></ul><hr><h3 id="三、-行为型模式-behavioral-patterns" tabindex="-1">三、 行为型模式 (Behavioral Patterns) <a class="header-anchor" href="#三、-行为型模式-behavioral-patterns" aria-hidden="true">#</a></h3><p>行为型模式关注<strong>对象之间的通信和职责分配</strong>，旨在使对象之间的协作更加灵活、高效。</p><h4 id="_1-观察者模式-observer" tabindex="-1">1. 观察者模式 (Observer) <a class="header-anchor" href="#_1-观察者模式-observer" aria-hidden="true">#</a></h4><p><strong>核心思想：</strong> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知并自动更新。</p><p><strong>应用场景：</strong> 当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象有待改变时。例如，GUI中的事件监听（<code>ActionListener</code>），消息队列的发布/订阅模型。</p><p><strong>结构：</strong></p><ul><li><strong>Subject (主题/被观察者):</strong> 维护了一个观察者列表，提供了添加、删除和通知观察者的方法。</li><li><strong>Observer (观察者):</strong> 定义了一个更新接口，当被观察者状态改变时，该接口被调用。</li><li><strong>ConcreteSubject (具体主题):</strong> 实现了主题接口，并在自身状态改变时通知所有注册的观察者。</li><li><strong>ConcreteObserver (具体观察者):</strong> 实现了观察者接口，以在接收到通知时更新自身状态。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 观察者接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Observer</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">update</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">message</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 被观察者接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Subject</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">registerObserver</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Observer</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">o</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">removeObserver</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Observer</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">o</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">notifyObservers</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 具体被观察者</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">WeatherStation</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Subject</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">List</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Observer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> observers </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ArrayList</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> weather</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">setWeather</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">newWeather</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">weather </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> newWeather</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">notifyObservers</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// ... 实现 register, remove, notify ...</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">notifyObservers</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Observer</span><span style="color:#A6ACCD;"> observer </span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> observers</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            observer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">update</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">weather</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h4 id="_2-策略模式-strategy" tabindex="-1">2. 策略模式 (Strategy) <a class="header-anchor" href="#_2-策略模式-strategy" aria-hidden="true">#</a></h4><p><strong>核心思想：</strong> 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p><p><strong>应用场景：</strong> 如果在一个系统中有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。例如，电商网站的支付方式（支付宝、微信支付、银行卡支付）。</p><p><strong>结构：</strong></p><ul><li><strong>Context (上下文):</strong> 维护一个对Strategy对象的引用。</li><li><strong>Strategy (策略接口):</strong> 定义所有支持的算法的公共接口。</li><li><strong>ConcreteStrategy (具体策略):</strong> 封装了具体的算法或行为。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 策略接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">PaymentStrategy</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">pay</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">amount</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 具体策略</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">AlipayStrategy</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">PaymentStrategy</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">pay</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">amount</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 支付宝支付逻辑 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">WechatPayStrategy</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">PaymentStrategy</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">pay</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">amount</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 微信支付逻辑 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 上下文</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ShoppingCart</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">PaymentStrategy</span><span style="color:#A6ACCD;"> paymentStrategy</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">setPaymentStrategy</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">PaymentStrategy</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">paymentStrategy</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">paymentStrategy </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> paymentStrategy</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">checkout</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">amount</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        paymentStrategy</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pay</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">amount</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h4 id="_3-模板方法模式-template-method" tabindex="-1">3. 模板方法模式 (Template Method) <a class="header-anchor" href="#_3-模板方法模式-template-method" aria-hidden="true">#</a></h4><p><strong>核心思想：</strong> 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>应用场景：</strong> 当多个子类有共有的方法，并且这些方法逻辑相同时，可以将其抽取到父类的模板方法中。例如，<code>java.io.InputStream</code> 中的 <code>read(byte b[], int off, int len)</code> 方法就是一个模板方法。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Game</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">initialize</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">startPlay</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">endPlay</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 模板方法，被final修饰，防止被重写</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">play</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">initialize</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">startPlay</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">endPlay</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Cricket</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Game</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">initialize</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">板球游戏初始化！</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">startPlay</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">板球游戏开始！</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">endPlay</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">板球游戏结束！</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h3 id="总结-5" tabindex="-1">总结 <a class="header-anchor" href="#总结-5" aria-hidden="true">#</a></h3><p>设计模式是前人智慧的结晶，是解决软件设计问题的“良方”。学习设计模式的重点在于理解其背后的设计原则（如单一职责原则、开闭原则、里氏替换原则等），并能够在合适的场景下灵活运用。一开始可能会觉得生搬硬套，但随着项目经验的积累，你会逐渐体会到设计模式带来的巨大好处，并能够写出更加优雅、健壮和易于维护的Java代码。</p><hr><h1 id="java中synchronized和reentrantlock有什么区别" tabindex="-1">java中synchronized和ReentrantLock有什么区别？ <a class="header-anchor" href="#java中synchronized和reentrantlock有什么区别" aria-hidden="true">#</a></h1><p>在Java中，<code>synchronized</code>关键字和<code>ReentrantLock</code>类都用于实现线程同步，解决多线程竞争问题。它们的核心区别如下：</p><h3 id="_1-设计层面" tabindex="-1">1. <strong>设计层面</strong> <a class="header-anchor" href="#_1-设计层面" aria-hidden="true">#</a></h3><ul><li><strong><code>synchronized</code></strong> Java语言级关键字，隐式锁机制，用法简单（JVM管理锁的获取与释放）。</li><li><strong><code>ReentrantLock</code></strong> JDK提供的显式锁类（<code>java.util.concurrent.locks</code>包），需手动加锁/释放锁。</li></ul><h3 id="_2-锁的公平性" tabindex="-1">2. <strong>锁的公平性</strong> <a class="header-anchor" href="#_2-锁的公平性" aria-hidden="true">#</a></h3><ul><li><strong><code>synchronized</code></strong> 仅支持<strong>非公平锁</strong>（竞争线程随机获取锁）。</li><li><strong><code>ReentrantLock</code></strong> 可自由选择：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 公平锁（按等待时间分配）</span></span>
<span class="line"><span style="color:#C792EA;">ReentrantLock</span><span style="color:#A6ACCD;"> fairLock </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ReentrantLock</span><span style="color:#89DDFF;">(true);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 非公平锁（默认）</span></span>
<span class="line"><span style="color:#C792EA;">ReentrantLock</span><span style="color:#A6ACCD;"> unfairLock </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ReentrantLock</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span></code></pre></div></li></ul><h3 id="_3-锁获取的灵活性" tabindex="-1">3. <strong>锁获取的灵活性</strong> <a class="header-anchor" href="#_3-锁获取的灵活性" aria-hidden="true">#</a></h3><ul><li><strong><code>synchronized</code></strong> 线程若未获锁，将<strong>一直阻塞</strong>直到成功，无法中途取消。</li><li><strong><code>ReentrantLock</code></strong> 提供灵活控制： <ul><li><strong>尝试锁</strong>：失败立即返回<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">tryLock</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 非阻塞尝试</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 业务逻辑 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unlock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><strong>超时锁</strong>：指定等待时间<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">tryLock</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> TimeUnit</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">SECONDS</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 最大等待5秒</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 业务逻辑 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unlock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><strong>可中断锁</strong>：等待中响应中断<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">lockInterruptibly</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 阻塞时若被中断，抛出InterruptedException</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><h3 id="_4-条件变量-condition" tabindex="-1">4. <strong>条件变量（Condition）</strong> <a class="header-anchor" href="#_4-条件变量-condition" aria-hidden="true">#</a></h3><ul><li><strong><code>synchronized</code></strong> 仅通过<code>wait()</code>/<code>notifyAll()</code>实现一个条件队列，无法细化等待条件。</li><li><strong><code>ReentrantLock</code></strong> 支持<strong>多个条件队列</strong>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Condition</span><span style="color:#A6ACCD;"> notFull </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newCondition</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 条件1：队列未满</span></span>
<span class="line"><span style="color:#C792EA;">Condition</span><span style="color:#A6ACCD;"> notEmpty </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newCondition</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 条件2：队列非空</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 生产线程</span></span>
<span class="line"><span style="color:#A6ACCD;">lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">lock</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isFull</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> notFull</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">await</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 等待&quot;未满&quot;条件</span></span>
<span class="line"><span style="color:#A6ACCD;">  queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">  notEmpty</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">signal</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 唤醒&quot;非空&quot;等待者</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unlock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 消费线程</span></span>
<span class="line"><span style="color:#A6ACCD;">lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">lock</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isEmpty</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> notEmpty</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">await</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 等待&quot;非空&quot;条件</span></span>
<span class="line"><span style="color:#A6ACCD;">  queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">take</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">  notFull</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">signal</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 唤醒&quot;未满&quot;等待者</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unlock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul><h3 id="_5-锁的实现机制" tabindex="-1">5. <strong>锁的实现机制</strong> <a class="header-anchor" href="#_5-锁的实现机制" aria-hidden="true">#</a></h3><ul><li><strong><code>synchronized</code></strong> 基于JVM底层优化，如： <ul><li><strong>偏向锁</strong>：无竞争时减少开销</li><li><strong>轻量级锁</strong>：短时竞争通过CAS解决</li><li><strong>锁消除/粗化</strong>：编译器优化</li></ul></li><li><strong><code>ReentrantLock</code></strong> 基于AQS（AbstractQueuedSynchronizer）实现，纯Java代码控制同步队列。</li></ul><h3 id="_6-性能差异" tabindex="-1">6. <strong>性能差异</strong> <a class="header-anchor" href="#_6-性能差异" aria-hidden="true">#</a></h3><ul><li>早期版本（如Java 5）中，<code>ReentrantLock</code>性能显著优于<code>synchronized</code>。</li><li><strong>Java 6+</strong>：JVM大幅优化<code>synchronized</code>后，两者在无竞争场景下性能相近；高竞争时<code>ReentrantLock</code>仍有优势。</li></ul><h3 id="_7-使用场景推荐" tabindex="-1">7. <strong>使用场景推荐</strong> <a class="header-anchor" href="#_7-使用场景推荐" aria-hidden="true">#</a></h3><table><thead><tr><th>场景</th><th>推荐方式</th></tr></thead><tbody><tr><td>简单同步需求</td><td>✅ <code>synchronized</code></td></tr><tr><td>需要公平锁</td><td>✅ <code>ReentrantLock</code></td></tr><tr><td>细粒度条件控制（多个等待条件）</td><td>✅ <code>ReentrantLock</code></td></tr><tr><td>尝试锁/超时锁/可中断锁需求</td><td>✅ <code>ReentrantLock</code></td></tr><tr><td>避免锁泄漏</td><td>✅ <code>synchronized</code>（自动释放）</td></tr></tbody></table><h3 id="示例代码对比" tabindex="-1">示例代码对比 <a class="header-anchor" href="#示例代码对比" aria-hidden="true">#</a></h3><p><code>synchronized</code>实现：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SyncCounter</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> count</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        count</span><span style="color:#89DDFF;">++;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 自动加锁/释放锁</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><code>ReentrantLock</code>实现：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">LockCounter</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ReentrantLock</span><span style="color:#A6ACCD;"> lock </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ReentrantLock</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> count</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">lock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 显式加锁</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            count</span><span style="color:#89DDFF;">++;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unlock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 必须finally释放！</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h3 id="总结-6" tabindex="-1">总结 <a class="header-anchor" href="#总结-6" aria-hidden="true">#</a></h3><table><thead><tr><th>特性</th><th><code>synchronized</code></th><th><code>ReentrantLock</code></th></tr></thead><tbody><tr><td>锁类型</td><td>隐式锁</td><td>显式锁</td></tr><tr><td>公平性</td><td>仅非公平</td><td>支持公平/非公平（默认非公平）</td></tr><tr><td>条件变量</td><td>单一条件</td><td>多个条件（<code>newCondition()</code>）</td></tr><tr><td>尝试锁/超时锁</td><td>❌ 不支持</td><td>✅ <code>tryLock()</code>, <code>tryLock(time)</code></td></tr><tr><td>可中断锁</td><td>❌ 阻塞不可中断</td><td>✅ <code>lockInterruptibly()</code></td></tr><tr><td>锁释放</td><td>自动释放（方法/块结束）</td><td>需手动<code>unlock()</code>（易遗漏！）</td></tr><tr><td>代码复杂度</td><td>简洁</td><td>需模板代码（<code>try-finally</code>）</td></tr><tr><td>锁优化机制</td><td>✅ JVM内置优化（偏向锁等）</td><td>❌ 纯Java实现</td></tr></tbody></table><p><strong>优先选择<code>synchronized</code></strong>：简洁安全，适合大多数同步场景。 <strong>选择<code>ReentrantLock</code></strong>：当需要公平锁、条件变量、锁中断等高级特性时使用。</p><hr><h1 id="synchronized底层是如何实现的-什么是锁的升级和降级" tabindex="-1">synchronized底层是如何实现的？什么是锁的升级和降级 <a class="header-anchor" href="#synchronized底层是如何实现的-什么是锁的升级和降级" aria-hidden="true">#</a></h1><h1 id="synchronized底层实现与锁升级机制" tabindex="-1"><code>synchronized</code>底层实现与锁升级机制 <a class="header-anchor" href="#synchronized底层实现与锁升级机制" aria-hidden="true">#</a></h1><h2 id="synchronized底层实现" tabindex="-1"><code>synchronized</code>底层实现 <a class="header-anchor" href="#synchronized底层实现" aria-hidden="true">#</a></h2><p><code>synchronized</code>关键字的底层实现涉及JVM的内置机制和对象的内存布局：</p><ol><li><strong>对象头机制</strong>： <ul><li>每个Java对象在堆中存储时都有一个对象头，其中包含Mark Word（标记字）</li><li>Mark Word存储对象的运行时信息：哈希码、GC分代年龄、锁标志位等</li><li>Mark Word长度在32位JVM中是32位，64位JVM中是64位</li></ul></li></ol><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Java对象在内存中的布局</span></span>
<span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Instance</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">对象实例</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Mark</span><span style="color:#A6ACCD;"> Word</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// 锁信息的核心存储区</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Class</span><span style="color:#A6ACCD;"> Pointer </span><span style="color:#676E95;font-style:italic;">// 指向类元数据的指针</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Instance</span><span style="color:#A6ACCD;"> Data </span><span style="color:#676E95;font-style:italic;">// 对象实际数据</span></span>
<span class="line"><span style="color:#A6ACCD;">    Padding       </span><span style="color:#676E95;font-style:italic;">// 对齐填充</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ol start="2"><li><p><strong>Mark Word结构</strong>：</p><ul><li>不同锁状态下的Mark Word结构不同：</li></ul><table><thead><tr><th>锁状态</th><th>存储内容</th><th>标志位</th></tr></thead><tbody><tr><td>无锁</td><td>对象hashCode + 分代年龄</td><td>01</td></tr><tr><td>偏向锁</td><td>偏向线程ID + Epoch + 分代年龄</td><td>01</td></tr><tr><td>轻量级锁</td><td>指向栈中锁记录的指针</td><td>00</td></tr><tr><td>重量级锁</td><td>指向互斥量（monitor）的指针</td><td>10</td></tr><tr><td>GC标记</td><td>空</td><td>11</td></tr></tbody></table></li><li><p><strong>Monitor对象</strong>：</p><ul><li>JVM为每个对象关联一个ObjectMonitor对象（监视器）</li><li>结构关键字段：<div class="language-c++"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">ObjectMonitor {</span></span>
<span class="line"><span style="color:#A6ACCD;">    _header;      // Mark Word的存储位置</span></span>
<span class="line"><span style="color:#A6ACCD;">    _owner;       // 持有锁的线程</span></span>
<span class="line"><span style="color:#A6ACCD;">    _count;       // 锁的重入次数</span></span>
<span class="line"><span style="color:#A6ACCD;">    _WaitSet;     // 等待队列（调用wait()的线程）</span></span>
<span class="line"><span style="color:#A6ACCD;">    _EntryList;   // 锁阻塞队列</span></span>
<span class="line"><span style="color:#A6ACCD;">    _cxq;         // 竞争队列</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div></li><li>当线程尝试获取锁时： <ol><li>通过CAS操作修改Mark Word</li><li>成功则获取锁，失败则进入阻塞队列</li></ol></li></ul></li></ol><h2 id="锁的升级过程-锁膨胀" tabindex="-1">锁的升级过程 (锁膨胀) <a class="header-anchor" href="#锁的升级过程-锁膨胀" aria-hidden="true">#</a></h2><p>锁升级是JVM针对不同并发场景进行的优化，共有4个阶段：</p><div class="language-mermaid"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">graph</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">TD</span></span>
<span class="line"><span style="color:#A6ACCD;">    A</span><span style="color:#89DDFF;font-style:italic;">[</span><span style="color:#C3E88D;">无锁状态</span><span style="color:#89DDFF;font-style:italic;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">--&gt;|</span><span style="color:#C3E88D;">首次访问</span><span style="color:#89DDFF;font-style:italic;">|</span><span style="color:#A6ACCD;"> B</span><span style="color:#89DDFF;font-style:italic;">[</span><span style="color:#C3E88D;">偏向锁</span><span style="color:#89DDFF;font-style:italic;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">    B </span><span style="color:#89DDFF;font-style:italic;">--&gt;|</span><span style="color:#C3E88D;">竞争出现</span><span style="color:#89DDFF;font-style:italic;">|</span><span style="color:#A6ACCD;"> C</span><span style="color:#89DDFF;font-style:italic;">[</span><span style="color:#C3E88D;">轻量级锁</span><span style="color:#89DDFF;font-style:italic;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">    C </span><span style="color:#89DDFF;font-style:italic;">--&gt;|</span><span style="color:#C3E88D;">自旋失败</span><span style="color:#89DDFF;font-style:italic;">|</span><span style="color:#A6ACCD;"> D</span><span style="color:#89DDFF;font-style:italic;">[</span><span style="color:#C3E88D;">重量级锁</span><span style="color:#89DDFF;font-style:italic;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">    D </span><span style="color:#89DDFF;font-style:italic;">--&gt;|</span><span style="color:#C3E88D;">锁释放</span><span style="color:#89DDFF;font-style:italic;">|</span><span style="color:#A6ACCD;"> A</span></span>
<span class="line"></span></code></pre></div><h3 id="_1-偏向锁-biased-locking" tabindex="-1">1. 偏向锁 (Biased Locking) <a class="header-anchor" href="#_1-偏向锁-biased-locking" aria-hidden="true">#</a></h3><ul><li><strong>目的</strong>：无竞争环境优化</li><li><strong>原理</strong>： <ul><li>当线程第一次访问同步块时，在对象头存储偏向线程ID</li><li>后续该线程进入同步块无需任何同步操作（只需检查线程ID）</li></ul></li><li><strong>触发场景</strong>：单线程重复访问同步块</li><li><strong>优势</strong>：加锁/解锁无任何代价</li><li><strong>图示实现</strong>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">对象锁状态 </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> 无锁 </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> 支持偏向锁</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    使用CAS记录线程ID到Mark </span><span style="color:#C792EA;">Word</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">成功</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        对象进入偏向锁状态</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul><h3 id="_2-轻量级锁-lightweight-locking" tabindex="-1">2. 轻量级锁 (Lightweight Locking) <a class="header-anchor" href="#_2-轻量级锁-lightweight-locking" aria-hidden="true">#</a></h3><ul><li><strong>目的</strong>：多线程交替执行优化</li><li><strong>原理</strong>： <ol><li>在栈帧中创建Lock Record</li><li>将对象头的Mark Word复制到锁记录（Displaced Mark Word）</li><li>尝试用CAS将对象头指向锁记录</li><li>成功则获锁，失败则锁膨胀</li></ol></li><li><strong>触发场景</strong>：多线程交替访问（非竞争）</li><li><strong>优势</strong>：避免线程阻塞（使用自旋）</li><li><strong>升级条件</strong>： <ul><li>CAS失败（表示有竞争）</li><li>自旋超过阈值（自适应自旋）</li></ul></li></ul><h3 id="_3-重量级锁-heavyweight-locking" tabindex="-1">3. 重量级锁 (Heavyweight Locking) <a class="header-anchor" href="#_3-重量级锁-heavyweight-locking" aria-hidden="true">#</a></h3><ul><li><strong>最终状态</strong>：真正OS级锁</li><li><strong>实现机制</strong>： <ul><li>通过操作系统的互斥量(mutex)实现</li><li>未获取锁的线程进入阻塞队列（上下文切换）</li></ul></li><li><strong>触发方式</strong>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">lock</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(!</span><span style="color:#A6ACCD;">尝试轻量级加锁</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        膨胀为重量级锁</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        阻塞当前线程</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><strong>开销</strong>：涉及上下文切换（10-100微秒级开销）</li></ul><h3 id="_4-锁降级" tabindex="-1">4. 锁降级？ <a class="header-anchor" href="#_4-锁降级" aria-hidden="true">#</a></h3><ul><li><strong>Java标准锁体系不支持主动降级</strong></li><li>特殊情况： <ul><li>GC过程扫描发现无锁竞争，可能重置为无锁状态</li><li>偏向锁超时（默认15秒）自动重置</li><li>JVM安全点中清理</li></ul></li><li><strong>重要</strong>：锁升级是<strong>单向过程</strong>（不可逆，除非完全释放后重新获取）</li></ul><h2 id="性能优化特点" tabindex="-1">性能优化特点 <a class="header-anchor" href="#性能优化特点" aria-hidden="true">#</a></h2><ol><li><p><strong>自适应自旋</strong>：</p><ul><li>JVM动态调整自旋次数（根据历史成功率）</li><li>避免固定自旋造成的CPU浪费</li></ul></li><li><p><strong>锁消除</strong>：</p><ul><li>通过逃逸分析如果发现对象不可能共享</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">method</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> lock </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 局部对象</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">synchronized</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lock</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">        </span><span style="color:#676E95;font-style:italic;">// 同步被消除</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 操作</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>锁粗化</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 优化前</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">synchronized</span><span style="color:#89DDFF;">(this)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 操作</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 优化后</span></span>
<span class="line"><span style="color:#C792EA;">synchronized</span><span style="color:#89DDFF;">(this)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 操作</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ol><h2 id="实践建议" tabindex="-1">实践建议 <a class="header-anchor" href="#实践建议" aria-hidden="true">#</a></h2><ol><li><p><strong>优先使用<code>synchronized</code></strong></p><ul><li>简单场景选择<code>synchronized</code>（自动维护锁升级）</li><li>Java 6+版本性能与<code>ReentrantLock</code>相当</li></ul></li><li><p><strong>关注同步范围</strong></p><ul><li>最小化同步代码块</li><li>避免在循环内加锁</li></ul></li><li><p><strong>选择合适锁对象</strong></p><ul><li>避免使用String或基础类型包装类</li><li>最好创建专用的锁对象：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> lock </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ol><p>锁升级机制充分体现了Java对&quot;渐进式优化&quot;理念的贯彻，让开发者享受&quot;傻瓜式&quot;同步的同时，获得接近手动优化的性能。</p><hr><h1 id="一个线程两次调用start-方法会出现什么情况" tabindex="-1">一个线程两次调用start()方法会出现什么情况 <a class="header-anchor" href="#一个线程两次调用start-方法会出现什么情况" aria-hidden="true">#</a></h1><p>在Java中，一个线程实例<strong>不允许被多次启动</strong>。当你尝试第二次调用同一个线程对象的<code>start()</code>方法时，Java虚拟机会抛出<code>IllegalThreadStateException</code>异常。以下是详细说明：</p><hr><h3 id="_1-线程的生命周期状态" tabindex="-1">1. <strong>线程的生命周期状态</strong> <a class="header-anchor" href="#_1-线程的生命周期状态" aria-hidden="true">#</a></h3><p>Java线程的状态（通过<code>getState()</code>方法查看）包括：</p><ul><li><strong>NEW</strong>：新建状态（尚未调用<code>start()</code>）</li><li><strong>RUNNABLE</strong>：可运行状态（已调用<code>start()</code>）</li><li><strong>TERMINATED</strong>：终止状态（线程执行完毕）</li></ul><p><strong>关键点</strong>：一个线程只能从<strong>NEW状态</strong>进入<strong>RUNNABLE状态</strong>。一旦启动（即第一次调用<code>start()</code>），它的状态就不再是<code>NEW</code>。后续再调用<code>start()</code>会检查线程状态，如果非<code>NEW</code>则抛出异常。</p><hr><h3 id="_2-异常抛出的机制" tabindex="-1">2. <strong>异常抛出的机制</strong> <a class="header-anchor" href="#_2-异常抛出的机制" aria-hidden="true">#</a></h3><p><code>Thread.start()</code>方法的源代码中有明确的检查：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">threadStatus </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 0 代表NEW状态</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">throw</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">IllegalThreadStateException</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// ... 启动线程的实际逻辑</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>当线程状态 <code>threadStatus != 0</code>（即非<code>NEW</code>状态）时，直接抛出异常。</li><li>无论线程当前是<code>RUNNABLE</code>、<code>TERMINATED</code>还是其他状态（如<code>BLOCKED</code>），第二次调用<code>start()</code>均会触发异常。</li></ul><hr><h3 id="_3-示例代码验证" tabindex="-1">3. <strong>示例代码验证</strong> <a class="header-anchor" href="#_3-示例代码验证" aria-hidden="true">#</a></h3><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Main</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Thread</span><span style="color:#A6ACCD;"> thread </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Thread</span><span style="color:#89DDFF;">(()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Thread is running...</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">        thread</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 第一次启动成功</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            Thread</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sleep</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">2000</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 等待线程执行结束（进入TERMINATED状态）</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">InterruptedException</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            e</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">printStackTrace</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 第二次尝试启动（失败）</span></span>
<span class="line"><span style="color:#A6ACCD;">        thread</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 抛出IllegalThreadStateException</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><strong>输出</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">Thread is running...</span></span>
<span class="line"><span style="color:#A6ACCD;">Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException</span></span>
<span class="line"><span style="color:#A6ACCD;">    at java.lang.Thread.start(Thread.java:708)</span></span>
<span class="line"><span style="color:#A6ACCD;">    at Main.main(Main.java:13)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><hr><h3 id="_4-常见问题场景" tabindex="-1">4. <strong>常见问题场景</strong> <a class="header-anchor" href="#_4-常见问题场景" aria-hidden="true">#</a></h3><ul><li><strong>重复启动线程对象</strong>：无论线程是否已结束（<code>TERMINATED</code>），只要调用过<code>start()</code>，第二次调用就会失败。</li><li><strong>延迟启动线程</strong>：若线程尚未执行完（仍处于<code>RUNNABLE</code>状态），此时再次调用<code>start()</code>同样触发异常。</li></ul><hr><h3 id="_5-正确做法-重用任务而非线程" tabindex="-1">5. <strong>正确做法：重用任务而非线程</strong> <a class="header-anchor" href="#_5-正确做法-重用任务而非线程" aria-hidden="true">#</a></h3><p>若要多次执行相同任务，应<strong>重用任务对象</strong>而非线程：</p><ul><li>创建一个实现了<code>Runnable</code>的任务对象。</li><li>通过<strong>新线程实例</strong>或<strong>线程池</strong>执行任务：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Runnable</span><span style="color:#A6ACCD;"> task </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Task running</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 每次启动用新线程</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Thread</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">task</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 第一次</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Thread</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">task</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 第二次（允许）</span></span>
<span class="line"></span></code></pre></div></li><li>使用线程池（推荐）：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ExecutorService</span><span style="color:#A6ACCD;"> executor </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Executors</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newFixedThreadPool</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">executor</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">submit</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">task</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 多次提交无问题</span></span>
<span class="line"><span style="color:#A6ACCD;">executor</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">submit</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">task</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h3 id="总结-7" tabindex="-1">总结 <a class="header-anchor" href="#总结-7" aria-hidden="true">#</a></h3><table><thead><tr><th>调用次数</th><th>状态变化</th><th>结果</th></tr></thead><tbody><tr><td>第1次</td><td><code>NEW</code> → <code>RUNNABLE</code></td><td>线程正常启动</td></tr><tr><td>第2次</td><td>任何非<code>NEW</code>状态（如<code>RUNNABLE</code>/<code>TERMINATED</code>）</td><td>抛出<code>IllegalThreadStateException</code></td></tr></tbody></table><p><strong>结论</strong>：一个线程实例只能调用一次<code>start()</code>方法。多次启动的本质问题是违反了线程状态机规则，JVM通过强制抛出异常确保线程生命周期的正确性。</p><hr><h1 id="什么情况下java程序会产生死锁-如何定位-修复" tabindex="-1">什么情况下java程序会产生死锁，如何定位 修复？ <a class="header-anchor" href="#什么情况下java程序会产生死锁-如何定位-修复" aria-hidden="true">#</a></h1><p>在 Java 中，死锁发生在多个线程相互等待对方持有的资源，导致所有线程永久阻塞。以下是产生死锁的条件、定位方法和修复方案：</p><hr><h3 id="死锁产生的必要条件-需同时满足" tabindex="-1"><strong>死锁产生的必要条件（需同时满足）：</strong> <a class="header-anchor" href="#死锁产生的必要条件-需同时满足" aria-hidden="true">#</a></h3><ol><li><strong>互斥使用</strong>：资源一次只能被一个线程持有</li><li><strong>持有并等待</strong>：线程持有资源且不释放，同时等待其他资源</li><li><strong>不可剥夺</strong>：线程持有的资源不能被强制抢占</li><li><strong>循环等待</strong>：线程之间形成环形等待链（如 T1 等待 T2 的资源，T2 等待 T1 的资源）</li></ol><h3 id="常见引发场景" tabindex="-1"><strong>常见引发场景</strong> <a class="header-anchor" href="#常见引发场景" aria-hidden="true">#</a></h3><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 经典死锁示例：两个线程以不同顺序获取锁</span></span>
<span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> lockA </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> lockB </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">Thread</span><span style="color:#A6ACCD;"> t1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Thread</span><span style="color:#89DDFF;">(()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockA</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">          </span><span style="color:#676E95;font-style:italic;">// 1. 先获取 lockA</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockB</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 3. 等待 lockB（被t2持有）</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">Thread</span><span style="color:#A6ACCD;"> t2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Thread</span><span style="color:#89DDFF;">(()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockB</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">          </span><span style="color:#676E95;font-style:italic;">// 2. 先获取 lockB</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockA</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 4. 等待 lockA（被t1持有）→ 死锁</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">});</span></span>
<span class="line"><span style="color:#A6ACCD;">t1</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> t2</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="定位死锁" tabindex="-1"><strong>定位死锁</strong> <a class="header-anchor" href="#定位死锁" aria-hidden="true">#</a></h3><h4 id="_1-jstack-工具-命令行" tabindex="-1"><strong>1. jstack 工具（命令行）</strong> <a class="header-anchor" href="#_1-jstack-工具-命令行" aria-hidden="true">#</a></h4><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;"># 1. 查看 Java 进程 PID</span></span>
<span class="line"><span style="color:#FFCB6B;">jps</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 2. 分析线程栈</span></span>
<span class="line"><span style="color:#FFCB6B;">jstack</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">PI</span><span style="color:#A6ACCD;">D</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><ul><li>在输出中搜索 <code>deadlock</code>，会明确标注发现的死锁及阻塞线程的堆栈信息</li></ul><h4 id="_2-jconsole-visualvm-图形化工具" tabindex="-1"><strong>2. JConsole / VisualVM（图形化工具）</strong> <a class="header-anchor" href="#_2-jconsole-visualvm-图形化工具" aria-hidden="true">#</a></h4><ul><li>打开工具并连接到目标 JVM</li><li>在&quot;线程&quot;选项卡中检测死锁（会直接标记死锁线程）</li></ul><h4 id="_3-代码检测-threadmxbean" tabindex="-1"><strong>3. 代码检测 ThreadMXBean</strong> <a class="header-anchor" href="#_3-代码检测-threadmxbean" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ThreadMXBean</span><span style="color:#A6ACCD;"> mxBean </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ManagementFactory</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getThreadMXBean</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#C792EA;">long</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> deadlockedThreads </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> mxBean</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">findDeadlockedThreads</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 返回死锁线程ID</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">deadlockedThreads </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Deadlock detected!</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="修复死锁的策略" tabindex="-1"><strong>修复死锁的策略</strong> <a class="header-anchor" href="#修复死锁的策略" aria-hidden="true">#</a></h3><h4 id="_1-保证锁顺序一致-破坏循环等待" tabindex="-1"><strong>1. 保证锁顺序一致（破坏循环等待）</strong> <a class="header-anchor" href="#_1-保证锁顺序一致-破坏循环等待" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 解决方案：全局约定获取锁的顺序（如先 lockA 后 lockB）</span></span>
<span class="line"><span style="color:#C792EA;">Thread</span><span style="color:#A6ACCD;"> t2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Thread</span><span style="color:#89DDFF;">(()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockA</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 改为先获取 lockA</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockB</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">});</span></span>
<span class="line"></span></code></pre></div><h4 id="_2-使用-trylock-超时机制-破坏持有等待" tabindex="-1"><strong>2. 使用 tryLock 超时机制（破坏持有等待）</strong> <a class="header-anchor" href="#_2-使用-trylock-超时机制-破坏持有等待" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Lock</span><span style="color:#A6ACCD;"> lockA </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ReentrantLock</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#C792EA;">Lock</span><span style="color:#A6ACCD;"> lockB </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ReentrantLock</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">Thread</span><span style="color:#A6ACCD;"> t1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Thread</span><span style="color:#89DDFF;">(()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(true)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockA</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">tryLock</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> TimeUnit</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">MILLISECONDS</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockB</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">tryLock</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> TimeUnit</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">MILLISECONDS</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 操作资源 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> lockB</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unlock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> lockA</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unlock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        Thread</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sleep</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 避免活锁</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">});</span></span>
<span class="line"></span></code></pre></div><h4 id="_3-减小锁粒度" tabindex="-1"><strong>3. 减小锁粒度</strong> <a class="header-anchor" href="#_3-减小锁粒度" aria-hidden="true">#</a></h4><ul><li>使用细粒度锁（如 <code>ConcurrentHashMap</code> 分段锁）</li><li>避免在方法上使用 <code>synchronized</code>（改用同步代码块）</li></ul><h4 id="_4-设计无锁结构" tabindex="-1"><strong>4. 设计无锁结构</strong> <a class="header-anchor" href="#_4-设计无锁结构" aria-hidden="true">#</a></h4><ul><li>使用线程安全类：<code>ConcurrentLinkedQueue</code>, <code>AtomicLong</code> 等</li><li>采用 Actor 模型（如 Akka 框架）或消息队列</li></ul><hr><h3 id="预防死锁的最佳实践" tabindex="-1"><strong>预防死锁的最佳实践</strong> <a class="header-anchor" href="#预防死锁的最佳实践" aria-hidden="true">#</a></h3><ol><li><strong>始终按固定顺序获取锁</strong>（如通过资源 ID 排序）</li><li><strong>设置锁超时</strong>：<code>ReentrantLock.tryLock(timeout)</code></li><li><strong>避免嵌套锁</strong>：重构代码减少所需的锁数量</li><li><strong>使用高级并发工具</strong>： <ul><li><code>Semaphore</code> (信号量)</li><li><code>CountDownLatch</code>/<code>CyclicBarrier</code></li><li><code>java.util.concurrent</code> 包中的锁机制</li></ul></li></ol><blockquote><p><strong>关键提示</strong>：死锁是设计问题而非实现细节，应在架构阶段考虑并发安全。通过代码审查和压力测试可提前暴露问题。</p></blockquote><hr><h1 id="java并发包提供了哪些并发工具类" tabindex="-1">Java并发包提供了哪些并发工具类？ <a class="header-anchor" href="#java并发包提供了哪些并发工具类" aria-hidden="true">#</a></h1><p>Java并发包（<code>java.util.concurrent</code>）提供了强大的工具类来简化并发编程，主要分为以下几类：</p><hr><h3 id="一、锁-locks" tabindex="-1">一、<strong>锁（Locks）</strong> <a class="header-anchor" href="#一、锁-locks" aria-hidden="true">#</a></h3><p>解决<code>synchronized</code>的局限性：</p><ol><li><strong><code>ReentrantLock</code></strong><ul><li>可重入互斥锁，支持公平锁/非公平锁。</li><li>示例：替代<code>synchronized</code>，支持<code>tryLock()</code>超时获取锁。</li></ul></li><li><strong><code>ReentrantReadWriteLock</code></strong><ul><li>读写分离锁：读锁共享，写锁互斥，提升读多写少场景性能。</li></ul></li><li><strong><code>StampedLock</code></strong>（Java 8） <ul><li>优化读写锁：支持乐观读（不阻塞写操作），避免写饥饿。</li></ul></li></ol><hr><h3 id="二、原子变量-atomic-classes" tabindex="-1">二、<strong>原子变量（Atomic Classes）</strong> <a class="header-anchor" href="#二、原子变量-atomic-classes" aria-hidden="true">#</a></h3><p>无锁线程安全操作：</p><ul><li><strong>基础类型</strong>：<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code></li><li><strong>引用类型</strong>：<code>AtomicReference</code>、<code>AtomicStampedReference</code>（解决ABA问题）</li><li><strong>数组</strong>：<code>AtomicIntegerArray</code>、<code>AtomicLongArray</code></li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">AtomicInteger</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">AtomicInteger</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">incrementAndGet</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 线程安全自增</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="三、并发集合-concurrent-collections" tabindex="-1">三、<strong>并发集合（Concurrent Collections）</strong> <a class="header-anchor" href="#三、并发集合-concurrent-collections" aria-hidden="true">#</a></h3><p>高并发场景下的数据结构：</p><ol><li><strong><code>ConcurrentHashMap</code></strong><ul><li>分段锁（Java 7）或CAS+synchronized（Java 8+），高性能并发Map。</li></ul></li><li><strong>阻塞队列（BlockingQueue）</strong><ul><li><code>ArrayBlockingQueue</code>：数组实现的有界队列。</li><li><code>LinkedBlockingQueue</code>：链表实现的可选有界队列。</li><li><code>PriorityBlockingQueue</code>：支持优先级的无界队列。</li></ul></li><li><strong>其他</strong><ul><li><code>CopyOnWriteArrayList</code>：读多写少场景的线程安全List（写时复制）。</li><li><code>ConcurrentSkipListMap</code>：跳表实现的有序并发Map。</li></ul></li></ol><hr><h3 id="四、同步器-synchronizers" tabindex="-1">四、<strong>同步器（Synchronizers）</strong> <a class="header-anchor" href="#四、同步器-synchronizers" aria-hidden="true">#</a></h3><p>控制线程协作：</p><ol><li><strong><code>CountDownLatch</code></strong><ul><li>倒计数器：等待指定数量线程完成。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">CountDownLatch</span><span style="color:#A6ACCD;"> latch </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">CountDownLatch</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">latch</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">await</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 阻塞直到计数器归零</span></span>
<span class="line"><span style="color:#A6ACCD;">latch</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">countDown</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 任务完成时调用</span></span>
<span class="line"></span></code></pre></div></li><li><strong><code>CyclicBarrier</code></strong><ul><li>循环栅栏：多线程相互等待，到达屏障后继续执行（可重用）。</li></ul></li><li><strong><code>Semaphore</code></strong><ul><li>信号量：控制同时访问资源的线程数（限流）。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Semaphore</span><span style="color:#A6ACCD;"> semaphore </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Semaphore</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 允许5个线程同时访问</span></span>
<span class="line"><span style="color:#A6ACCD;">semaphore</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">acquire</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 获取许可</span></span>
<span class="line"><span style="color:#A6ACCD;">semaphore</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">release</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 释放许可</span></span>
<span class="line"></span></code></pre></div></li><li><strong><code>Phaser</code></strong>（Java 7） <ul><li>灵活的阶段同步器，支持动态调整参与线程数。</li></ul></li></ol><hr><h3 id="五、线程池框架-executor-framework" tabindex="-1">五、<strong>线程池框架（Executor Framework）</strong> <a class="header-anchor" href="#五、线程池框架-executor-framework" aria-hidden="true">#</a></h3><p>管理线程生命周期：</p><ol><li><strong>核心接口</strong><ul><li><code>Executor</code>：执行任务的接口。</li><li><code>ExecutorService</code>：扩展<code>Executor</code>，支持任务提交和生命周期管理。</li><li><code>ScheduledExecutorService</code>：支持延时/周期性任务。</li></ul></li><li><strong>工厂类</strong><ul><li><code>Executors</code>：创建常见线程池（需注意资源耗尽风险）。</li></ul></li><li><strong>实现类</strong><ul><li><code>ThreadPoolExecutor</code>：可自定义核心参数（核心线程数、队列等）。</li><li><code>ForkJoinPool</code>：分治任务模型，配合<code>ForkJoinTask</code>使用。</li></ul></li></ol><hr><h3 id="六、异步任务-future-completablefuture" tabindex="-1">六、<strong>异步任务（Future &amp; CompletableFuture）</strong> <a class="header-anchor" href="#六、异步任务-future-completablefuture" aria-hidden="true">#</a></h3><p>异步编程支持：</p><ol><li><strong><code>Future</code>接口</strong><ul><li>表示异步计算结果（需手动轮询结果）。</li></ul></li><li><strong><code>CompletableFuture</code></strong>（Java 8） <ul><li>组合式异步编程：链式调用、异常处理、合并结果等。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">CompletableFuture</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">supplyAsync</span><span style="color:#89DDFF;">(()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">thenApply</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">s </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> s </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;"> World!</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">thenAccept</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;font-style:italic;">::</span><span style="color:#A6ACCD;">println</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div></li></ol><hr><h3 id="七、其他工具" tabindex="-1">七、<strong>其他工具</strong> <a class="header-anchor" href="#七、其他工具" aria-hidden="true">#</a></h3><ol><li><strong><code>ThreadLocalRandom</code></strong><ul><li>线程安全的随机数生成器（替代<code>Random</code>）。</li></ul></li><li><strong><code>Exchanger</code></strong><ul><li>线程间交换数据的同步点。</li></ul></li></ol><hr><h3 id="总结-8" tabindex="-1">总结 <a class="header-anchor" href="#总结-8" aria-hidden="true">#</a></h3><ul><li><strong>锁机制</strong>：<code>ReentrantLock</code>、<code>StampedLock</code></li><li><strong>原子操作</strong>：<code>AtomicInteger</code>、<code>AtomicReference</code></li><li><strong>并发集合</strong>：<code>ConcurrentHashMap</code>、<code>BlockingQueue</code></li><li><strong>同步器</strong>：<code>CountDownLatch</code>、<code>Semaphore</code>、<code>CyclicBarrier</code></li><li><strong>线程池</strong>：<code>ExecutorService</code>、<code>ThreadPoolExecutor</code></li><li><strong>异步编程</strong>：<code>CompletableFuture</code></li></ul><p>正确使用这些工具类可有效提升并发性能、避免死锁、简化代码逻辑。</p><hr><h1 id="并发包中的concurentlinkedqueue和linkedblockingqueue有什么区别" tabindex="-1">并发包中的ConcurentLinkedQueue和LinkedBlockingQueue有什么区别？ <a class="header-anchor" href="#并发包中的concurentlinkedqueue和linkedblockingqueue有什么区别" aria-hidden="true">#</a></h1>`,688),t=[p];function e(r,c,y,D,i,A){return a(),n("div",null,t)}const d=s(o,[["render",e]]);export{F as __pageData,d as default};
