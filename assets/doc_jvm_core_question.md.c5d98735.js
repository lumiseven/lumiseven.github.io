import{_ as s,c as n,o as a,a as l}from"./app.bd26c8cd.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"doc/jvm/core_question.md","lastUpdated":1752545571000}'),o={name:"doc/jvm/core_question.md"},t=l(`<h2 id="谈谈你对java平台的理解" tabindex="-1">谈谈你对Java平台的理解 <a class="header-anchor" href="#谈谈你对java平台的理解" aria-hidden="true">#</a></h2><p>作为一名常年与 Java 打交道的研究者，我对 Java 平台的理解可以用 <strong>“一个由虚拟机推动的巨大开发者生态”</strong> 来概括。它不是单一技术，而是一个<strong>多层次、高度标准化的计算平台和生态体系</strong>，核心围绕着 <strong>跨平台性、稳定性、安全性、高性能和庞大的社区</strong>。下面尽可能详细地阐述其关键组成部分和特性：</p><h3 id="一、核心基石-java-虚拟机" tabindex="-1">一、核心基石：Java 虚拟机 <a class="header-anchor" href="#一、核心基石-java-虚拟机" aria-hidden="true">#</a></h3><ul><li><strong>引擎与运行环境：</strong> JVM 是 Java 平台的灵魂。它提供<strong>运行时环境</strong>让平台无关的 Java 字节码能执行（即<code>.class</code>文件）。</li><li><strong>关键职责：</strong><ul><li><strong>类加载：</strong> 通过高效类加载器（Bootstrap、Extension、System/Application 等）实现动态加载，搭配“双亲委派”机制确保安全。</li><li><strong>字节码执行：</strong><ul><li><strong>解释器：</strong> 即时翻译执行字节码（启动快）。</li><li><strong>即时编译器：</strong> JIT（如 C1、C2/GraalVM）在运行时编译热点代码为本地机器码（运行快）。</li><li><strong>AOT 编译器：</strong> 如 GraalVM Native Image，在编译时直接将字节码编译为本地可执行文件（启动极快，占用资源减少）。</li></ul></li><li><strong>内存管理（GC）：</strong><ul><li><strong>自动垃圾回收：</strong> JVM 通过复杂的垃圾回收器回收内存（如 Serial、Parallel Scavenge/Old、CMS、G1、ZGC、Shenandoah），大幅减少开发者负担。</li><li><strong>内存模型：</strong> 如堆（Heap）、栈（Stack）、方法区/元空间（Metaspace）等定义。</li></ul></li><li><strong>运行时优化：</strong> 持续优化字节码执行效率（如内联、逃逸分析和即时编译）。</li></ul></li><li><strong>跨平台特性：</strong> “一次编写，随处运行”的关键基础就是 JVM，各平台有对应实现。</li></ul><h3 id="二、核心库-api" tabindex="-1">二、核心库 API <a class="header-anchor" href="#二、核心库-api" aria-hidden="true">#</a></h3><ul><li><strong>基础设施支持：</strong> 提供强大且标准化的功能支撑核心开发： <ul><li><strong>基础类库：</strong> <code>java.lang</code>（如 Object, String, Class 等）、<code>java.util</code>（容器如 List， Map， 时间处理等）、<code>java.io</code>/<code>java.nio</code>（IO/NIO）。</li><li><strong>并发包：</strong> <code>java.util.concurrent</code>（线程池如 ExecutorService、并发容器、Lock 和 AQS）。</li><li><strong>工具类：</strong> 数学计算（<code>java.math</code>）、反射（<code>java.lang.reflect</code>）、注解、函数式接口（java.util.function）等。</li><li><strong>安全管理：</strong> <code>java.security</code> （访问控制、证书等）。</li></ul></li><li><strong>标准扩展 API：</strong><ul><li><strong>数据库访问：</strong> JDBC（<code>java.sql</code>, <code>javax.sql</code>）。</li><li><strong>网络通信：</strong> 套接字、HTTP 客户端（HTTPURLConnection、HttpClient JDK 11+）。</li><li><strong>XML 处理：</strong> JAXP。</li><li><strong>日志：</strong> <code>java.util.logging</code>（SLF4J/Logback 等更常用，但也在平台内或上层生态内）。</li></ul></li></ul><h3 id="三、java-语言本身" tabindex="-1">三、Java 语言本身 <a class="header-anchor" href="#三、java-语言本身" aria-hidden="true">#</a></h3><ul><li><strong>面向对象设计：</strong> 封装、继承、多态是其核心支柱。</li><li><strong>强类型和相对安全：</strong> 编译期类型检查有效减少运行时错误。</li><li><strong>相对简单：</strong> 无指针、内存自动管理等提升开发体验。</li><li><strong>稳健发展：</strong><ul><li><strong>持续演进：</strong> JDK 5（泛型、枚举、注解）、JDK 8（Lambda、Stream API）、JDK 9（模块系统）、JDK 11（LTS 主力）、JDK 17/21（新 LTS）。</li><li><strong>项目推进：</strong> Valhalla（值类型）、Panama（FFI）、Loom（虚拟线程）等持续优化语言性能和表现力。</li></ul></li></ul><h3 id="四、工具集-支撑全开发周期" tabindex="-1">四、工具集：支撑全开发周期 <a class="header-anchor" href="#四、工具集-支撑全开发周期" aria-hidden="true">#</a></h3><ul><li><strong>JDK：</strong> 包含 JRE、编译器（javac）、调试器（jdb）、监控工具（jconsole, jvisualvm）、打包工具（jar）等。</li><li><strong>诊断与调优工具：</strong><ul><li>命令行（jps, jstat, jmap, jstack）</li><li>图形化（VisualVM, JMC）</li><li>第三方（Arthas, YourKit）</li></ul></li></ul><h3 id="五、生态体系-平台的真正实力" tabindex="-1">五、生态体系：平台的真正实力 <a class="header-anchor" href="#五、生态体系-平台的真正实力" aria-hidden="true">#</a></h3><ul><li><strong>构建工具：</strong> Maven、Gradle（标准化依赖管理和构建）。</li><li><strong>主流框架：</strong><ul><li>综合：Spring Framework（包括 Spring Boot、Spring Cloud、Spring Security 等）</li><li>Web：Jakarta EE（前 Java EE）、Play、Dropwizard</li><li>ORM：Hibernate、MyBatis</li></ul></li><li><strong>测试工具：</strong> JUnit、TestNG、Mockito、JaCoCo 等完整测试生态。</li><li><strong>应用服务器：</strong> Tomcat、Jetty、WildFly、GlassFish、WebLogic、WebSphere（部署企业级解决方案）。</li><li><strong>微服务支持：</strong> Netflix OSS、Spring Cloud 等实现现代化分布式架构。</li><li><strong>大数据技术：</strong> Apache Hadoop/Spark/Flink/Kafka 多以 JVM 平台为基础。</li></ul><h3 id="六、java-平台的核心价值主张" tabindex="-1">六、Java 平台的核心价值主张 <a class="header-anchor" href="#六、java-平台的核心价值主张" aria-hidden="true">#</a></h3><ul><li><strong>跨平台可移植性：</strong> 在绝大多数操作系统上均可运行。</li><li><strong>高性能与可扩展：</strong> JVM 持续优化和即时编译确保高性能，GC 技术成熟支撑大规模应用。</li><li><strong>高安全性：</strong> 字节码校验、安全管理器、沙箱机制和类加载机制提供多维度保障。</li><li><strong>成熟的开发体验：</strong> 丰富的文档、IDE（IntelliJ IDEA/Eclipse）强大支持、异常处理清晰。</li><li><strong>蓬勃的生态圈：</strong> 社区支持强大、开源库覆盖全面，持续解决复杂场景问题。</li><li><strong>稳健与成熟度高：</strong> 经过 20 多年验证的架构使其成为企业级应用的首选。</li><li><strong>与时俱进：</strong> 不断拥抱新技术范式（云原生、函数式编程、服务网格等）。</li></ul><hr><h3 id="核心概念总结" tabindex="-1">核心概念总结 <a class="header-anchor" href="#核心概念总结" aria-hidden="true">#</a></h3><table><thead><tr><th>概念</th><th>作用</th><th>关键技术示例</th></tr></thead><tbody><tr><td><strong>JVM</strong></td><td>代码执行环境</td><td>类加载器、垃圾回收器、JIT/HotSpot</td></tr><tr><td><strong>字节码</strong></td><td>跨平台中间格式</td><td>.class 文件、JVM指令集</td></tr><tr><td><strong>核心库</strong></td><td>提供基础API</td><td>java.lang、java.util、java.io、java.nio</td></tr><tr><td><strong>Java SE/EE</strong></td><td>平台标准规范</td><td>SE 基础API、EE企业级扩展</td></tr><tr><td><strong>工具链</strong></td><td>开发者支持</td><td>JDK工具、Maven/Gradle、JUnit</td></tr><tr><td><strong>生态系统</strong></td><td>扩展平台能力</td><td>Spring框架、Hibernate、Tomcat服务</td></tr></tbody></table><h3 id="我眼中的-java-平台关键特征" tabindex="-1">我眼中的 Java 平台关键特征 <a class="header-anchor" href="#我眼中的-java-平台关键特征" aria-hidden="true">#</a></h3><ol><li><strong>虚拟机为中心</strong>：JVM 是跨平台基石，性能优化核心。</li><li><strong>强类型 OOP 语言+函数式扩展</strong>：Java 语言持续进化，兼顾传统与现代编程范式。</li><li><strong>丰富核心库</strong>：提供现代软件开发所需的基础构建块。</li><li><strong>成熟内存管理系统</strong>：自动 GC 和多种优化策略显著提升开发者效率。</li><li><strong>生态驱动价值</strong>：从 Maven 到 Spring，整个生态解决了现实世界开发中的各种难题。</li><li><strong>企业级稳健性</strong>：经过大规模实践验证的架构使其长期担当关键业务支撑。</li><li><strong>开放性标准与开源动力</strong>：JCP 等标准化组织与强大的开源社区持续推动进化。</li></ol><hr><p><strong>总而言之，Java 平台是一个以 JVM 为核心驱动、拥有强大核心库支撑、以 Java 语言为主要开发语言、配套成熟工具链、并被庞大开源生态和商业应用所包围的高度成功的计算平台。其核心价值在于跨平台能力、高性能保障、成熟的开发体验和极其丰富的生态系统支撑</strong>。它既是技术体系，更是一种开发文化，始终在适应新挑战的同时保持着强大的生命力。这正是 Java 长盛不衰的根本原因——不仅是工具，更是完整的解决方案生态系统。</p><hr><h2 id="java中的exception和error有什么区别" tabindex="-1">java中的exception和error有什么区别 <a class="header-anchor" href="#java中的exception和error有什么区别" aria-hidden="true">#</a></h2><p>在Java中，<code>Error</code> 和 <code>Exception</code> 都是 <code>Throwable</code> 类的子类，但它们代表了不同性质的问题，处理方式也有显著区别。以下是主要区别的总结：</p><hr><h4 id="🚨-1-根本区别" tabindex="-1">🚨 <strong>1. 根本区别</strong> <a class="header-anchor" href="#🚨-1-根本区别" aria-hidden="true">#</a></h4><table><thead><tr><th></th><th><strong><code>Exception</code></strong></th><th><strong><code>Error</code></strong></th></tr></thead><tbody><tr><td><strong>本质</strong></td><td><strong>应用程序级问题</strong></td><td><strong>系统级严重问题</strong></td></tr><tr><td><strong>可恢复性</strong></td><td>多数可被捕获并恢复</td><td><strong>通常不可恢复</strong>（如内存耗尽）</td></tr><tr><td><strong>责任方</strong></td><td>程序员编写的代码</td><td>JVM环境或底层资源问题</td></tr></tbody></table><hr><h4 id="🧩-2-类型区分" tabindex="-1">🧩 <strong>2. 类型区分</strong> <a class="header-anchor" href="#🧩-2-类型区分" aria-hidden="true">#</a></h4><ul><li><p><strong><code>Exception</code> (异常)</strong></p><ul><li><strong>受检异常（Checked）</strong>：编译时必须处理（<code>IOException</code>, <code>SQLException</code>等）</li><li><strong>非受检异常（Unchecked）</strong>：运行时异常（<code>NullPointerException</code>, <code>ArrayIndexOutOfBoundsException</code>等）</li></ul></li><li><p><strong><code>Error</code> (错误)</strong> 所有错误都是<strong>非受检</strong>的（如 <code>OutOfMemoryError</code>, <code>StackOverflowError</code>），无需在代码中显式处理。</p></li></ul><hr><h4 id="⚙️-3-典型例子" tabindex="-1">⚙️ <strong>3. 典型例子</strong> <a class="header-anchor" href="#⚙️-3-典型例子" aria-hidden="true">#</a></h4><table><thead><tr><th><strong><code>Exception</code> 示例</strong></th><th><strong><code>Error</code> 示例</strong></th></tr></thead><tbody><tr><td><code>FileNotFoundException</code></td><td><code>OutOfMemoryError</code>（内存耗尽）</td></tr><tr><td><code>ClassNotFoundException</code></td><td><code>StackOverflowError</code>（栈溢出）</td></tr><tr><td><code>InterruptedException</code></td><td><code>NoClassDefFoundError</code>（类加载失败）</td></tr></tbody></table><hr><h4 id="🛠️-4-处理方式建议" tabindex="-1">🛠️ <strong>4. 处理方式建议</strong> <a class="header-anchor" href="#🛠️-4-处理方式建议" aria-hidden="true">#</a></h4><ul><li><p><strong><code>Exception</code> 处理</strong>： 应通过 <code>try-catch</code> 捕获并恢复，或用 <code>throws</code> 声明：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 可能抛出Exception的代码</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">IOException</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 恢复逻辑（如重试或提示用户）</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong><code>Error</code> 处理</strong>： ❌ <strong>禁止主动捕获</strong>！因无法有效恢复，捕获可能掩盖严重问题：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 错误示例！（不要这样写）</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 某些操作</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">OutOfMemoryError</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 无法实际解决内存耗尽问题</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h4 id="📌-关键总结" tabindex="-1">📌 <strong>关键总结</strong> <a class="header-anchor" href="#📌-关键总结" aria-hidden="true">#</a></h4><table><thead><tr><th>特性</th><th><code>Exception</code></th><th><code>Error</code></th></tr></thead><tbody><tr><td><strong>是否可恢复</strong></td><td>✅ 多数可恢复</td><td>❌ 不可恢复</td></tr><tr><td><strong>是否强制处理</strong></td><td>受检异常强制处理</td><td>不强制处理</td></tr><tr><td><strong>来源</strong></td><td>应用程序逻辑问题</td><td>JVM/系统资源崩溃</td></tr><tr><td><strong>是否应被捕获</strong></td><td>✅ 需针对性处理</td><td>❌ 避免捕获（除特殊场景如日志记录）</td></tr></tbody></table><hr><h4 id="🌰-代码示例" tabindex="-1">🌰 代码示例 <a class="header-anchor" href="#🌰-代码示例" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 异常处理（正常流程）</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    Files</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">readString</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Path</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">of</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">missing_file.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">));</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">IOException</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 捕获Exception</span></span>
<span class="line"><span style="color:#A6ACCD;">    System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">err</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">文件不存在：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> e</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getMessage</span><span style="color:#89DDFF;">());</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Error场景：捕获无意义，程序仍会崩溃</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">int</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> arr </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">Integer</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">MAX_VALUE</span><span style="color:#89DDFF;">];</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 触发OutOfMemoryError</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">OutOfMemoryError</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 此处无法真正恢复内存！</span></span>
<span class="line"><span style="color:#A6ACCD;">    System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">err</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">内存耗尽（实际应终止程序）</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><blockquote><p>💡 <strong>最佳实践</strong>：</p><ul><li>对 <code>Exception</code> 编写健壮的恢复逻辑</li><li>对 <code>Error</code> 记录日志后<strong>终止程序</strong>（通常由JVM自动处理）</li><li>永远不要吞掉 <code>Throwable</code>（如 <code>catch (Throwable t)</code>）！</li></ul></blockquote><hr><h2 id="谈谈-java中的-final-finally-finalize-有什么不同" tabindex="-1">谈谈 java中的 final finally finalize 有什么不同？ <a class="header-anchor" href="#谈谈-java中的-final-finally-finalize-有什么不同" aria-hidden="true">#</a></h2><p>在Java中，<code>final</code>、<code>finally</code> 和 <code>finalize</code> 虽然名称相似，但功能和使用场景<strong>完全不同</strong>。以下是详细对比：</p><hr><h4 id="⭐-1-final-关键字" tabindex="-1">⭐ <strong>1. final（关键字）</strong> <a class="header-anchor" href="#⭐-1-final-关键字" aria-hidden="true">#</a></h4><p><strong>核心作用</strong>： <strong>修饰不可变性</strong>，可应用于类、方法、变量。</p><table><thead><tr><th>应用场景</th><th>规则</th><th>示例</th></tr></thead><tbody><tr><td><strong>final变量</strong></td><td>变量值/引用地址不可变（基本类型值不变，引用类型地址不变）</td><td><code>final int x = 10;</code> <br> <code>final List&lt;String&gt; list = new ArrayList&lt;&gt;();</code></td></tr><tr><td><strong>final方法</strong></td><td>禁止子类重写（Override）</td><td><code>public final void doWork() { ... }</code></td></tr><tr><td><strong>final类</strong></td><td>禁止类被继承（不能有子类）</td><td><code>public final class ImmutableClass { ... }</code></td></tr></tbody></table><p><strong>注意事项</strong>：</p><ul><li><code>final</code> 修饰引用类型变量时，<strong>对象内容可变</strong>（如集合可增删元素）。</li><li>常与 <code>static</code> 组合定义常量：<code>public static final double PI = 3.14;</code></li></ul><hr><h4 id="⭐-2-finally-关键字" tabindex="-1">⭐ <strong>2. finally（关键字）</strong> <a class="header-anchor" href="#⭐-2-finally-关键字" aria-hidden="true">#</a></h4><p><strong>核心作用</strong>： <strong>确保资源清理</strong>，必须与 <code>try-catch</code> 块一起使用。</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>必然执行</strong></td><td>无论是否发生异常、<code>return</code> 或 <code>break</code>，都会执行（<em>极端情况除外</em>）</td></tr><tr><td><strong>资源清理</strong></td><td>用于关闭文件流、数据库连接、释放锁等</td></tr><tr><td><strong>避免资源泄漏</strong></td><td>比靠GC回收更及时可靠</td></tr></tbody></table><p><strong>执行逻辑</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 可能抛出异常的代码</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">openFile</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">IOException</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 异常处理</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    file</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">close</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 无论如何都会关闭文件</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><strong>极端不执行场景</strong>：</p><ol><li><code>System.exit(0)</code> 强制退出</li><li>JVM崩溃（如 <code>kill -9</code> 杀掉进程）</li><li>无限循环阻塞 finally 线程</li></ol><hr><h4 id="⭐-3-finalize-方法" tabindex="-1">⭐ <strong>3. finalize（方法）</strong> <a class="header-anchor" href="#⭐-3-finalize-方法" aria-hidden="true">#</a></h4><p><strong>核心作用</strong>： <strong>对象回收前的最后一次清理</strong>（Object类的方法）。</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>不可靠的执行时机</strong></td><td>GC回收前触发，<strong>时机不确定甚至不执行</strong></td></tr><tr><td><strong>已被官方弃用</strong></td><td>Java 9 标记为<code>@Deprecated</code>（实际开发中避免使用）</td></tr><tr><td><strong>潜在风险</strong></td><td>性能问题（减慢GC）<br>资源泄漏（若未执行）<br>僵尸对象复活（可破坏GC）</td></tr></tbody></table><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#C792EA;">protected</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">finalize</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> throws Throwable </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">releaseNativeResource</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 尝试释放JNI资源</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        super</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">finalize</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 调用父类清理</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><strong>替代方案</strong>：</p><ul><li>推荐使用 <strong><code>AutoCloseable</code> 接口 + try-with-resources</strong>（Java 7+）：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">FileInputStream</span><span style="color:#A6ACCD;"> file </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">FileInputStream</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">test.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 自动调用file.close()</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">IOException</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h4 id="🎯-三者的本质区别" tabindex="-1">🎯 <strong>三者的本质区别</strong> <a class="header-anchor" href="#🎯-三者的本质区别" aria-hidden="true">#</a></h4><table><thead><tr><th>特性</th><th>final</th><th>finally</th><th>finalize</th></tr></thead><tbody><tr><td><strong>类型</strong></td><td><strong>关键字</strong></td><td><strong>关键字</strong></td><td><strong>Object的方法</strong></td></tr><tr><td><strong>作用域</strong></td><td>类/方法/变量</td><td>异常处理块</td><td>垃圾回收</td></tr><tr><td><strong>执行时机</strong></td><td>编译/运行时</td><td>异常处理后</td><td>GC前（不确定）</td></tr><tr><td><strong>可靠性</strong></td><td>语言级保证</td><td>非极端场景保证</td><td>不保证执行</td></tr><tr><td><strong>用途</strong></td><td>增强安全/设计约束</td><td>资源清理</td><td>历史遗留清理</td></tr></tbody></table><hr><h4 id="✅-最佳实践建议" tabindex="-1">✅ <strong>最佳实践建议</strong> <a class="header-anchor" href="#✅-最佳实践建议" aria-hidden="true">#</a></h4><ol><li>🛡️ <strong>多用 <code>final</code></strong>：提升代码安全性和设计清晰度（如不可变类）。</li><li>🔁 <strong>资源清理用 <code>finally</code> 或 try-with-resources</strong>：确保100%执行。</li><li>❌ <strong>避免 <code>finalize</code></strong>：使用 <code>Cleaner</code>（Java 9+）或手动资源管理替代。</li></ol><blockquote><p><strong>关键总结</strong>：</p><ul><li><code>final</code> → <strong>设计约束</strong>（不可变）</li><li><code>finally</code> → <strong>资源清理</strong>（必须执行）</li><li><code>finalize</code> → <strong>历史遗留</strong>（弃用机制）</li></ul></blockquote><hr><h2 id="java中的强引用-弱引用-幻象引用-有什么区别" tabindex="-1">java中的强引用 弱引用 幻象引用 有什么区别？ <a class="header-anchor" href="#java中的强引用-弱引用-幻象引用-有什么区别" aria-hidden="true">#</a></h2><p>在Java中，引用类型主要分为<strong>强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和幻象引用（Phantom Reference）</strong>。它们的主要区别在于垃圾回收器（GC）对待这些引用的方式不同，从而影响对象的生命周期和回收机制。</p><hr><h4 id="_1-强引用-strong-reference" tabindex="-1">1. <strong>强引用（Strong Reference）</strong> <a class="header-anchor" href="#_1-强引用-strong-reference" aria-hidden="true">#</a></h4><p><strong>特点</strong>：</p><ul><li><strong>最常见</strong>的引用类型，默认创建的引用都是强引用。</li><li>只要强引用存在，对象<strong>不会被GC回收</strong>（即使内存不足，JVM宁愿抛出<code>OutOfMemoryError</code>）。</li><li>强引用之间的依赖关系可能导致<strong>内存泄漏</strong>（如集合中无用的对象未移除）。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 强引用</span></span>
<span class="line"></span></code></pre></div><p><strong>回收时机</strong>：</p><ul><li>显式设置 <code>obj = null</code> 解除引用后，对象会被回收。</li><li>作用域结束（如局部变量超出作用域）。</li></ul><hr><h4 id="_2-弱引用-weak-reference" tabindex="-1">2. <strong>弱引用（Weak Reference）</strong> <a class="header-anchor" href="#_2-弱引用-weak-reference" aria-hidden="true">#</a></h4><p><strong>特点</strong>：</p><ul><li>通过 <code>java.lang.ref.WeakReference</code> 类实现。</li><li>当<strong>仅存在弱引用</strong>时，对象会在<strong>下一次GC时被回收</strong>（无论内存是否充足）。</li><li>常用于实现<strong>缓存</strong>（如 <code>WeakHashMap</code>），避免因缓存导致内存泄漏。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> weakRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">());</span></span>
<span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 获取对象（若未被回收）</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">gc</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// GC后若对象被回收，则 weakRef.get() 返回 null</span></span>
<span class="line"></span></code></pre></div><p><strong>典型场景</strong>：</p><ul><li><code>WeakHashMap</code> 的键（Key）使用弱引用存储，当键不再被强引用时，对应的键值对会被自动移除。</li></ul><hr><h4 id="_3-幻象引用-phantom-reference" tabindex="-1">3. <strong>幻象引用（Phantom Reference）</strong> <a class="header-anchor" href="#_3-幻象引用-phantom-reference" aria-hidden="true">#</a></h4><p><strong>特点</strong>：</p><ul><li>通过 <code>java.lang.ref.PhantomReference</code> 类实现。</li><li><strong>最弱</strong>的引用类型，无法通过 <code>get()</code> 方法获取到对象（始终返回 <code>null</code>）。</li><li>必须配合 <strong>引用队列（ReferenceQueue）</strong> 使用。</li><li>用于在对象<strong>被回收时收到系统通知</strong>（如清理堆外内存等资源）。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> queue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> phantomRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 对象被GC回收前，phantomRef 会自动加入 queue</span></span>
<span class="line"><span style="color:#C792EA;">Reference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> ref </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">remove</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 阻塞直到有引用入队</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">对象已被回收，资源清理完成</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div><p><strong>回收时机</strong>：</p><ul><li>对象本身被回收后，幻象引用会进入引用队列，通知开发者执行<strong>资源清理</strong>（如关闭文件句柄、释放堆外内存）。</li></ul><hr><h4 id="_4-软引用-soft-reference" tabindex="-1">4. <strong>软引用（Soft Reference）</strong> <a class="header-anchor" href="#_4-软引用-soft-reference" aria-hidden="true">#</a></h4><p><strong>补充说明</strong>：</p><ul><li>虽未提及但需完整对比：通过 <code>SoftReference</code> 类实现。</li><li>当<strong>内存不足</strong>时（即将抛出 <code>OutOfMemoryError</code> 前），GC才会回收仅被软引用的对象。</li><li>适合实现<strong>内存敏感的缓存</strong>（如大图片缓存）。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">SoftReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> softRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">SoftReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">());</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="引用队列-referencequeue" tabindex="-1">引用队列（ReferenceQueue） <a class="header-anchor" href="#引用队列-referencequeue" aria-hidden="true">#</a></h4><ul><li><strong>作用</strong>：在弱引用、软引用或幻象引用关联的对象被回收后，引用对象本身会被加入到队列中。</li><li><strong>典型用法</strong>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> queue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> ref </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 检查对象是否被回收</span></span>
<span class="line"><span style="color:#C792EA;">Reference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> clearedRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">poll</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 非阻塞检查</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h4 id="对比总结" tabindex="-1">对比总结 <a class="header-anchor" href="#对比总结" aria-hidden="true">#</a></h4><table><thead><tr><th>引用类型</th><th>回收时机</th><th><code>get()</code> 返回值</th><th>用途</th><th>实现类</th></tr></thead><tbody><tr><td><strong>强引用</strong></td><td><strong>永不回收</strong>（除非解除）</td><td>对象本身</td><td>常规对象引用</td><td>默认（无特殊类）</td></tr><tr><td><strong>软引用</strong></td><td><strong>内存不足时</strong></td><td>对象本身（若未回收）</td><td>实现内存敏感缓存（如图片缓存）</td><td><code>SoftReference</code></td></tr><tr><td><strong>弱引用</strong></td><td><strong>下一次GC时</strong></td><td>对象本身（若未回收）</td><td>防止缓存导致内存泄漏（如<code>WeakHashMap</code>）</td><td><code>WeakReference</code></td></tr><tr><td><strong>幻象引用</strong></td><td><strong>GC回收后通知</strong></td><td><strong>始终为null</strong></td><td>对象回收的清理工作（如堆外内存）</td><td><code>PhantomReference</code></td></tr></tbody></table><hr><h4 id="关键区别点" tabindex="-1">关键区别点 <a class="header-anchor" href="#关键区别点" aria-hidden="true">#</a></h4><ol><li><p><strong>回收强度</strong>： 强引用 &gt; 软引用 &gt; 弱引用 &gt; 幻象引用 （从左到右，对对象的约束依次减弱，回收可能性增加）</p></li><li><p><strong>实际效果</strong>：</p><ul><li>强引用阻止GC回收对象；</li><li>软引用在内存紧张时被回收；</li><li>弱引用在下次GC时即刻回收；</li><li>幻象引用仅用于接收对象回收的通知。</li></ul></li><li><p><strong>实用场景</strong>：</p><ul><li>强引用：常规对象管理。</li><li>软引用：对象缓存（如 <code>Android</code> 图片加载库）。</li><li>弱引用：自动清理的无干扰缓存（如 <code>WeakHashMap</code>）。</li><li>幻象引用：资源清理（如 <code>DirectByteBuffer</code> 堆外内存释放）。</li></ul></li></ol><hr><h4 id="代码验证示例" tabindex="-1">代码验证示例 <a class="header-anchor" href="#代码验证示例" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">java</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">lang</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">ref</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">*</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ReferenceTest</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">throws</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">InterruptedException</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> queue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 强引用</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> strongObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">强引用对象：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> strongObj</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 弱引用</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> weakRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">弱引用对象（GC前）：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 幻象引用</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> phantomRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">幻象引用对象（始终null）：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> phantomRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 触发GC</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">gc</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        Thread</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sleep</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 给GC时间</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 检查回收结果</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">弱引用对象（GC后）：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">());</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 输出 null</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 从队列中检查回收通知（弱引用和幻象引用都会入队）</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Reference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> ref</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">((</span><span style="color:#A6ACCD;">ref </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">poll</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ref </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">弱引用进入队列 - 对象被回收</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ref </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> phantomRef</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">幻象引用进入队列 - 可执行清理工作</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><strong>输出</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">强引用对象：java.lang.Object@1b6d3586</span></span>
<span class="line"><span style="color:#A6ACCD;">弱引用对象（GC前）：java.lang.Object@4554617c</span></span>
<span class="line"><span style="color:#A6ACCD;">幻象引用对象（始终null）：null</span></span>
<span class="line"><span style="color:#A6ACCD;">弱引用对象（GC后）：null</span></span>
<span class="line"><span style="color:#A6ACCD;">弱引用进入队列 - 对象被回收</span></span>
<span class="line"><span style="color:#A6ACCD;">幻象引用进入队列 - 可执行清理工作</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><hr><p>通过不同引用类型的设计，Java为开发者提供了更精细的内存管理手段，尤其在缓存、监听、资源清理等场景中能有效防止内存泄漏。</p><hr><h2 id="java中的强引用-弱引用-幻象引用-有什么区别-1" tabindex="-1">java中的强引用 弱引用 幻象引用 有什么区别？ <a class="header-anchor" href="#java中的强引用-弱引用-幻象引用-有什么区别-1" aria-hidden="true">#</a></h2><p>在Java中，引用类型主要分为<strong>强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和幻象引用（Phantom Reference）</strong>。它们的主要区别在于垃圾回收器（GC）对待这些引用的方式不同，从而影响对象的生命周期和回收机制。</p><hr><h4 id="_1-强引用-strong-reference-1" tabindex="-1">1. <strong>强引用（Strong Reference）</strong> <a class="header-anchor" href="#_1-强引用-strong-reference-1" aria-hidden="true">#</a></h4><p><strong>特点</strong>：</p><ul><li><strong>最常见</strong>的引用类型，默认创建的引用都是强引用。</li><li>只要强引用存在，对象<strong>不会被GC回收</strong>（即使内存不足，JVM宁愿抛出<code>OutOfMemoryError</code>）。</li><li>强引用之间的依赖关系可能导致<strong>内存泄漏</strong>（如集合中无用的对象未移除）。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 强引用</span></span>
<span class="line"></span></code></pre></div><p><strong>回收时机</strong>：</p><ul><li>显式设置 <code>obj = null</code> 解除引用后，对象会被回收。</li><li>作用域结束（如局部变量超出作用域）。</li></ul><hr><h4 id="_2-弱引用-weak-reference-1" tabindex="-1">2. <strong>弱引用（Weak Reference）</strong> <a class="header-anchor" href="#_2-弱引用-weak-reference-1" aria-hidden="true">#</a></h4><p><strong>特点</strong>：</p><ul><li>通过 <code>java.lang.ref.WeakReference</code> 类实现。</li><li>当<strong>仅存在弱引用</strong>时，对象会在<strong>下一次GC时被回收</strong>（无论内存是否充足）。</li><li>常用于实现<strong>缓存</strong>（如 <code>WeakHashMap</code>），避免因缓存导致内存泄漏。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> weakRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">());</span></span>
<span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 获取对象（若未被回收）</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">gc</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// GC后若对象被回收，则 weakRef.get() 返回 null</span></span>
<span class="line"></span></code></pre></div><p><strong>典型场景</strong>：</p><ul><li><code>WeakHashMap</code> 的键（Key）使用弱引用存储，当键不再被强引用时，对应的键值对会被自动移除。</li></ul><hr><h4 id="_3-幻象引用-phantom-reference-1" tabindex="-1">3. <strong>幻象引用（Phantom Reference）</strong> <a class="header-anchor" href="#_3-幻象引用-phantom-reference-1" aria-hidden="true">#</a></h4><p><strong>特点</strong>：</p><ul><li>通过 <code>java.lang.ref.PhantomReference</code> 类实现。</li><li><strong>最弱</strong>的引用类型，无法通过 <code>get()</code> 方法获取到对象（始终返回 <code>null</code>）。</li><li>必须配合 <strong>引用队列（ReferenceQueue）</strong> 使用。</li><li>用于在对象<strong>被回收时收到系统通知</strong>（如清理堆外内存等资源）。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> queue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> phantomRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 对象被GC回收前，phantomRef 会自动加入 queue</span></span>
<span class="line"><span style="color:#C792EA;">Reference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> ref </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">remove</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 阻塞直到有引用入队</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">对象已被回收，资源清理完成</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div><p><strong>回收时机</strong>：</p><ul><li>对象本身被回收后，幻象引用会进入引用队列，通知开发者执行<strong>资源清理</strong>（如关闭文件句柄、释放堆外内存）。</li></ul><hr><h4 id="_4-软引用-soft-reference-1" tabindex="-1">4. <strong>软引用（Soft Reference）</strong> <a class="header-anchor" href="#_4-软引用-soft-reference-1" aria-hidden="true">#</a></h4><p><strong>补充说明</strong>：</p><ul><li>虽未提及但需完整对比：通过 <code>SoftReference</code> 类实现。</li><li>当<strong>内存不足</strong>时（即将抛出 <code>OutOfMemoryError</code> 前），GC才会回收仅被软引用的对象。</li><li>适合实现<strong>内存敏感的缓存</strong>（如大图片缓存）。</li></ul><p><strong>示例</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">SoftReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> softRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">SoftReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">());</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="引用队列-referencequeue-1" tabindex="-1">引用队列（ReferenceQueue） <a class="header-anchor" href="#引用队列-referencequeue-1" aria-hidden="true">#</a></h4><ul><li><strong>作用</strong>：在弱引用、软引用或幻象引用关联的对象被回收后，引用对象本身会被加入到队列中。</li><li><strong>典型用法</strong>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> queue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> ref </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 检查对象是否被回收</span></span>
<span class="line"><span style="color:#C792EA;">Reference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> clearedRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">poll</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 非阻塞检查</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h4 id="对比总结-1" tabindex="-1">对比总结 <a class="header-anchor" href="#对比总结-1" aria-hidden="true">#</a></h4><table><thead><tr><th>引用类型</th><th>回收时机</th><th><code>get()</code> 返回值</th><th>用途</th><th>实现类</th></tr></thead><tbody><tr><td><strong>强引用</strong></td><td><strong>永不回收</strong>（除非解除）</td><td>对象本身</td><td>常规对象引用</td><td>默认（无特殊类）</td></tr><tr><td><strong>软引用</strong></td><td><strong>内存不足时</strong></td><td>对象本身（若未回收）</td><td>实现内存敏感缓存（如图片缓存）</td><td><code>SoftReference</code></td></tr><tr><td><strong>弱引用</strong></td><td><strong>下一次GC时</strong></td><td>对象本身（若未回收）</td><td>防止缓存导致内存泄漏（如<code>WeakHashMap</code>）</td><td><code>WeakReference</code></td></tr><tr><td><strong>幻象引用</strong></td><td><strong>GC回收后通知</strong></td><td><strong>始终为null</strong></td><td>对象回收的清理工作（如堆外内存）</td><td><code>PhantomReference</code></td></tr></tbody></table><hr><h4 id="关键区别点-1" tabindex="-1">关键区别点 <a class="header-anchor" href="#关键区别点-1" aria-hidden="true">#</a></h4><ol><li><p><strong>回收强度</strong>： 强引用 &gt; 软引用 &gt; 弱引用 &gt; 幻象引用 （从左到右，对对象的约束依次减弱，回收可能性增加）</p></li><li><p><strong>实际效果</strong>：</p><ul><li>强引用阻止GC回收对象；</li><li>软引用在内存紧张时被回收；</li><li>弱引用在下次GC时即刻回收；</li><li>幻象引用仅用于接收对象回收的通知。</li></ul></li><li><p><strong>实用场景</strong>：</p><ul><li>强引用：常规对象管理。</li><li>软引用：对象缓存（如 <code>Android</code> 图片加载库）。</li><li>弱引用：自动清理的无干扰缓存（如 <code>WeakHashMap</code>）。</li><li>幻象引用：资源清理（如 <code>DirectByteBuffer</code> 堆外内存释放）。</li></ul></li></ol><hr><h4 id="代码验证示例-1" tabindex="-1">代码验证示例 <a class="header-anchor" href="#代码验证示例-1" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">java</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">lang</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">ref</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">*</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ReferenceTest</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">throws</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">InterruptedException</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> queue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ReferenceQueue</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 强引用</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> strongObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">强引用对象：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> strongObj</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 弱引用</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> weakRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">WeakReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">弱引用对象（GC前）：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 幻象引用</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> phantomRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">PhantomReference</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">幻象引用对象（始终null）：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> phantomRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 触发GC</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">gc</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        Thread</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sleep</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 给GC时间</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 检查回收结果</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">弱引用对象（GC后）：</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">());</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 输出 null</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 从队列中检查回收通知（弱引用和幻象引用都会入队）</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Reference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> ref</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">((</span><span style="color:#A6ACCD;">ref </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">poll</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ref </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> weakRef</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">弱引用进入队列 - 对象被回收</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ref </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> phantomRef</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">幻象引用进入队列 - 可执行清理工作</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><strong>输出</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">强引用对象：java.lang.Object@1b6d3586</span></span>
<span class="line"><span style="color:#A6ACCD;">弱引用对象（GC前）：java.lang.Object@4554617c</span></span>
<span class="line"><span style="color:#A6ACCD;">幻象引用对象（始终null）：null</span></span>
<span class="line"><span style="color:#A6ACCD;">弱引用对象（GC后）：null</span></span>
<span class="line"><span style="color:#A6ACCD;">弱引用进入队列 - 对象被回收</span></span>
<span class="line"><span style="color:#A6ACCD;">幻象引用进入队列 - 可执行清理工作</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><hr><p>通过不同引用类型的设计，Java为开发者提供了更精细的内存管理手段，尤其在缓存、监听、资源清理等场景中能有效防止内存泄漏。</p><hr><h2 id="java-中-string-stringbuffer-stringbuilder-有什么区别" tabindex="-1">java 中 String StringBuffer StringBuilder 有什么区别？ <a class="header-anchor" href="#java-中-string-stringbuffer-stringbuilder-有什么区别" aria-hidden="true">#</a></h2><p>在Java中，<code>String</code>、<code>StringBuffer</code>和<code>StringBuilder</code>都用于处理字符串，但它们在<strong>可变性、线程安全性和性能</strong>方面有显著区别。以下是详细对比：</p><hr><h4 id="_1-string-不可变" tabindex="-1">1. <strong>String (不可变)</strong> <a class="header-anchor" href="#_1-string-不可变" aria-hidden="true">#</a></h4><ul><li><strong>核心特性</strong>：不可变（Immutable），任何修改操作（如拼接、替换）都会<strong>创建新对象</strong>。</li><li><strong>线程安全</strong>：天然线程安全（因不可变性）。</li><li><strong>内存开销</strong>：频繁修改会产生大量临时对象，影响性能。</li><li><strong>典型场景</strong>：常量字符串、不频繁修改的字符串。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> str </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">str </span><span style="color:#89DDFF;">+=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;"> World</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 隐式创建新对象+垃圾回收</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="_2-stringbuffer-可变-线程安全" tabindex="-1">2. <strong>StringBuffer (可变 + 线程安全)</strong> <a class="header-anchor" href="#_2-stringbuffer-可变-线程安全" aria-hidden="true">#</a></h4><ul><li><strong>核心特性</strong>：可变（Mutable），修改直接在原对象上进行。</li><li><strong>线程安全</strong>：<strong>线程安全</strong>（所有方法用<code>synchronized</code>修饰）。</li><li><strong>性能</strong>：比<code>String</code>高效（减少对象创建），但因同步锁开销，单线程下慢于<code>StringBuilder</code>。</li><li><strong>典型场景</strong>：多线程环境下的字符串修改（如Web应用）。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">StringBuffer</span><span style="color:#A6ACCD;"> sb </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">StringBuffer</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">sb</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">append</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;"> World</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 修改原对象，无新对象产生</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="_3-stringbuilder-可变-非线程安全" tabindex="-1">3. <strong>StringBuilder (可变 + 非线程安全)</strong> <a class="header-anchor" href="#_3-stringbuilder-可变-非线程安全" aria-hidden="true">#</a></h4><ul><li><strong>核心特性</strong>：可变（Mutable），API与<code>StringBuffer</code>兼容（非线程安全版）。</li><li><strong>线程安全</strong>：<strong>非线程安全</strong>（无同步锁）。</li><li><strong>性能</strong>：单线程下<strong>最快</strong>（无同步开销）。</li><li><strong>典型场景</strong>：单线程环境下的高频字符串操作（如循环拼接）。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">StringBuilder</span><span style="color:#A6ACCD;"> sb </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">StringBuilder</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">sb</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">append</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;"> World</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 修改原对象，效率最高（单线程）</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="性能对比-单线程" tabindex="-1">性能对比（单线程） <a class="header-anchor" href="#性能对比-单线程" aria-hidden="true">#</a></h4><table><thead><tr><th>操作</th><th><code>String</code></th><th><code>StringBuffer</code></th><th><code>StringBuilder</code></th></tr></thead><tbody><tr><td>10万次字符串拼接</td><td>慢（约2000ms+）</td><td>中（约5ms）</td><td><strong>快（约3ms）</strong></td></tr><tr><td>内存占用</td><td>高（对象爆炸）</td><td>低</td><td>低</td></tr><tr><td>线程安全</td><td>✅</td><td>✅</td><td>❌</td></tr></tbody></table><hr><h4 id="如何选择" tabindex="-1">如何选择？ <a class="header-anchor" href="#如何选择" aria-hidden="true">#</a></h4><table><thead><tr><th>场景</th><th>推荐类</th></tr></thead><tbody><tr><td>字符串常量、不修改</td><td><code>String</code></td></tr><tr><td><strong>多线程</strong>环境修改字符串</td><td><code>StringBuffer</code></td></tr><tr><td><strong>单线程</strong>环境修改字符串（主流）</td><td><code>StringBuilder</code></td></tr></tbody></table><blockquote><p><strong>最佳实践</strong>：</p><ul><li>JDK 5+开始，编译器会自动将<code>String</code>的<code>+</code>拼接优化为<code>StringBuilder</code>（仅适用于循环外简单拼接）。</li><li>循环内拼接<strong>务必手动使用<code>StringBuilder</code></strong>，避免编译器优化失效：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 正确示例</span></span>
<span class="line"><span style="color:#C792EA;">StringBuilder</span><span style="color:#A6ACCD;"> sb </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">StringBuilder</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    sb</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">append</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 只创建一个对象</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></blockquote><hr><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h4><table><thead><tr><th>特性</th><th><code>String</code></th><th><code>StringBuffer</code></th><th><code>StringBuilder</code></th></tr></thead><tbody><tr><td><strong>可变性</strong></td><td>❌（不可变）</td><td>✅（可变）</td><td>✅（可变）</td></tr><tr><td><strong>线程安全</strong></td><td>✅（天然）</td><td>✅（同步锁）</td><td>❌（无锁）</td></tr><tr><td><strong>性能</strong></td><td>低（频繁修改时）</td><td>中（锁开销）</td><td><strong>高</strong>（单线程首选）</td></tr><tr><td><strong>使用场景</strong></td><td>常量、少量修改</td><td>多线程环境</td><td>单线程高频操作</td></tr></tbody></table><hr><h2 id="java中的动态代理是基于什么原理" tabindex="-1">java中的动态代理是基于什么原理？ <a class="header-anchor" href="#java中的动态代理是基于什么原理" aria-hidden="true">#</a></h2><p>在Java中，动态代理是一种在运行时动态生成代理类对象的机制，它基于以下核心原理：</p><hr><h4 id="核心原理" tabindex="-1"><strong>核心原理</strong> <a class="header-anchor" href="#核心原理" aria-hidden="true">#</a></h4><ol><li><p><strong>运行时字节码生成</strong></p><ul><li>当调用<code>Proxy.newProxyInstance()</code>方法时，JVM会在内存中动态生成一个代理类的字节码（.class文件）。</li><li>生成的代理类继承自<code>java.lang.reflect.Proxy</code>类，并实现用户指定的接口（若接口非public则需同一ClassLoader加载）。</li><li>这一过程由<code>Proxy</code>类的内部逻辑完成，无需手动编写代理类代码。</li></ul></li><li><p><strong>方法调用委派机制</strong></p><ul><li>代理类中所有方法调用都会被重定向到一个统一的处理器：<code>InvocationHandler.invoke()</code>。</li><li>代理类的每个方法内部逻辑如下：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">ReturnType</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">methodName</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Parameters</span><span style="color:#A6ACCD;"> params</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> handler</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">invoke</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this,</span><span style="color:#A6ACCD;">   </span><span style="color:#676E95;font-style:italic;">// 代理对象自身</span></span>
<span class="line"><span style="color:#A6ACCD;">        method</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 目标方法（通过反射获取的Method对象）</span></span>
<span class="line"><span style="color:#A6ACCD;">        args    </span><span style="color:#676E95;font-style:italic;">// 方法参数</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong>反射调用目标方法</strong></p><ul><li>在<code>InvocationHandler.invoke()</code>的实现中，通过反射机制（<code>method.invoke(target, args)</code>）调用被代理对象的实际方法。</li><li>开发者可在<code>invoke()</code>中加入自定义逻辑（如性能监控、事务控制等）。</li></ul></li></ol><hr><h4 id="核心组件" tabindex="-1"><strong>核心组件</strong> <a class="header-anchor" href="#核心组件" aria-hidden="true">#</a></h4><ol><li><p><strong><code>java.lang.reflect.Proxy</code></strong></p><ul><li>入口类，提供静态方法创建代理对象：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Foo</span><span style="color:#A6ACCD;"> proxy </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Foo</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> Proxy</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newProxyInstance</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">    target</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getClass</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">getClassLoader</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 1. 类加载器</span></span>
<span class="line"><span style="color:#A6ACCD;">    target</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getClass</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">getInterfaces</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 2. 代理需实现的接口数组</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">MyInvocationHandler</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// 3. 调用处理器</span></span>
<span class="line"><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong><code>java.lang.reflect.InvocationHandler</code></strong></p><ul><li>单方法接口，定义代理行为的核心逻辑：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">InvocationHandler</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">invoke</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">proxy</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Method</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">method</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">throws</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Throwable</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ol><hr><h4 id="工作流程" tabindex="-1"><strong>工作流程</strong> <a class="header-anchor" href="#工作流程" aria-hidden="true">#</a></h4><div class="language-mermaid"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">sequenceDiagram</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">participant</span><span style="color:#A6ACCD;"> Client </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">客户端</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">participant</span><span style="color:#A6ACCD;"> Proxy </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">动态代理对象</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">participant</span><span style="color:#A6ACCD;"> Handler </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">InvocationHandler</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">participant</span><span style="color:#A6ACCD;"> Target </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">被代理对象</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    Client </span><span style="color:#89DDFF;font-style:italic;">-&gt;&gt;</span><span style="color:#A6ACCD;"> Proxy</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">调用接口方法</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">Note</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">over</span><span style="color:#A6ACCD;"> Proxy</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">自动拦截方法调用</span></span>
<span class="line"><span style="color:#A6ACCD;">    Proxy </span><span style="color:#89DDFF;font-style:italic;">-&gt;&gt;</span><span style="color:#A6ACCD;"> Handler</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">转发调用至invoke()</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">Note</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">over</span><span style="color:#A6ACCD;"> Handler</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">执行前置逻辑(如日志)</span></span>
<span class="line"><span style="color:#A6ACCD;">    Handler </span><span style="color:#89DDFF;font-style:italic;">-&gt;&gt;</span><span style="color:#A6ACCD;"> Target</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">反射调用实际方法(method.invoke())</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">Note</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">over</span><span style="color:#A6ACCD;"> Handler</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">执行后置逻辑(如事务提交)</span></span>
<span class="line"><span style="color:#A6ACCD;">    Target </span><span style="color:#89DDFF;font-style:italic;">--&gt;&gt;</span><span style="color:#A6ACCD;"> Handler</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">返回结果</span></span>
<span class="line"><span style="color:#A6ACCD;">    Handler </span><span style="color:#89DDFF;font-style:italic;">--&gt;&gt;</span><span style="color:#A6ACCD;"> Proxy</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">返回结果</span></span>
<span class="line"><span style="color:#A6ACCD;">    Proxy </span><span style="color:#89DDFF;font-style:italic;">--&gt;&gt;</span><span style="color:#A6ACCD;"> Client</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">返回结果</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="关键特点" tabindex="-1"><strong>关键特点</strong> <a class="header-anchor" href="#关键特点" aria-hidden="true">#</a></h4><ol><li><p><strong>接口代理</strong></p><ul><li>动态代理只能基于接口生成代理（继承<code>Proxy</code>类导致无法再继承其他类）。</li><li>若需代理无接口的类，需使用第三方库（如CGLib或Byte Buddy）。</li></ul></li><li><p><strong>性能开销</strong></p><ul><li>反射调用有性能损耗（JVM优化的<code>MethodHandle</code>可缓解）。</li><li>代理类首次生成后会被缓存复用。</li></ul></li><li><p><strong>动态性</strong></p><ul><li>代理逻辑（<code>InvocationHandler</code>）可在运行时替换，实现高度灵活的AOP编程。</li></ul></li></ol><hr><h4 id="底层实现机制" tabindex="-1"><strong>底层实现机制</strong> <a class="header-anchor" href="#底层实现机制" aria-hidden="true">#</a></h4><ol><li><p><strong>字节码生成过程</strong></p><ul><li><code>sun.misc.ProxyGenerator</code>动态生成代理类字节码。</li><li>通过<code>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</code>可导出.class文件查看：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">$Proxy0.class</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong>代理类示例</strong>（反编译后）</p></li></ol><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">$Proxy0</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Proxy</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Foo</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Method</span><span style="color:#A6ACCD;"> m1</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 目标方法的Method引用</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> $</span><span style="color:#82AAFF;">Proxy0</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">InvocationHandler</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">h</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        super</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">h</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">doSomething</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">arg</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 所有方法调用转发至InvocationHandler</span></span>
<span class="line"><span style="color:#A6ACCD;">        h</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">invoke</span><span style="color:#89DDFF;">(this,</span><span style="color:#A6ACCD;"> m1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">[]{</span><span style="color:#A6ACCD;">arg</span><span style="color:#89DDFF;">});</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        m1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Class</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">forName</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Foo</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">getMethod</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">doSomething</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> String</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="典型应用场景" tabindex="-1"><strong>典型应用场景</strong> <a class="header-anchor" href="#典型应用场景" aria-hidden="true">#</a></h4><ol><li><strong>AOP（面向切面编程）</strong><ul><li>Spring AOP使用动态代理实现事务管理、安全控制等横切关注点。</li></ul></li><li><strong>RPC框架</strong><ul><li>Dubbo、gRPC等通过动态代理隐藏远程调用细节（如序列化/网络传输）。</li></ul></li><li><strong>测试框架</strong><ul><li>Mockito利用动态代理创建模拟对象。</li></ul></li><li><strong>装饰器模式增强</strong><ul><li>动态添加日志记录、性能监控等非业务功能。</li></ul></li></ol><hr><h4 id="对比静态代理" tabindex="-1"><strong>对比静态代理</strong> <a class="header-anchor" href="#对比静态代理" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>特性</strong></th><th><strong>动态代理</strong></th><th><strong>静态代理</strong></th></tr></thead><tbody><tr><td>代码编写</td><td>无需手动编写代理类</td><td>需为每个接口编写代理类</td></tr><tr><td>可维护性</td><td>修改代理逻辑只需调整<code>InvocationHandler</code></td><td>需修改所有代理类源码</td></tr><tr><td>接口变化适应性</td><td>自动适配接口新增方法</td><td>需同步修改代理类</td></tr><tr><td>性能</td><td>反射调用有轻微开销</td><td>直接调用，无额外开销</td></tr></tbody></table><hr><h4 id="示例代码" tabindex="-1"><strong>示例代码</strong> <a class="header-anchor" href="#示例代码" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 1. 定义接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Calculator</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">b</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 2. 目标实现类</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">CalculatorImpl</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Calculator</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">b</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 3. 调用处理器</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">DebugHandler</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">InvocationHandler</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> target</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">DebugHandler</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">target</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">target </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> target</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">invoke</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">proxy</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Method</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">method</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Object</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">printf</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">调用方法: %s，参数: %s%n</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> method</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getName</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> Arrays</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">toString</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">args</span><span style="color:#89DDFF;">));</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> result </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> method</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">invoke</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> args</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 反射调用目标方法</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">结果: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> result</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> result</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 4. 客户端使用</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Demo</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Calculator</span><span style="color:#A6ACCD;"> target </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">CalculatorImpl</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Calculator</span><span style="color:#A6ACCD;"> proxy </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Calculator</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> Proxy</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newProxyInstance</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">                target</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getClass</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">getClassLoader</span><span style="color:#89DDFF;">(),</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Class</span><span style="color:#89DDFF;">[]{</span><span style="color:#A6ACCD;">Calculator</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">DebugHandler</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span></span>
<span class="line"><span style="color:#A6ACCD;">        proxy</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 输出调试日志并计算结果</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><strong>输出</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">调用方法: add，参数: [2, 3]</span></span>
<span class="line"><span style="color:#A6ACCD;">结果: 5</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><hr><h4 id="总结-1" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结-1" aria-hidden="true">#</a></h4><p>Java动态代理的本质是利用<strong>运行时生成字节码技术</strong> + <strong>方法调用委派机制</strong> + <strong>反射API</strong>，在接口级别实现代理模式。其核心价值在于：</p><ul><li><strong>解耦</strong>：将代理逻辑从业务代码中剥离。</li><li><strong>动态性</strong>：运行时灵活生成代理对象。</li><li><strong>可扩展性</strong>：通过<code>InvocationHandler</code>支持多样化的增强逻辑。 但需注意其局限于接口代理，对类代理需依赖第三方字节码库（如CGLib）。</li></ul><hr><h2 id="java中int和integer的区别" tabindex="-1">java中int和Integer的区别？ <a class="header-anchor" href="#java中int和integer的区别" aria-hidden="true">#</a></h2><p>在 Java 中，<code>int</code> 和 <code>Integer</code> 都用于表示整数值，但它们有本质区别：</p><h4 id="🧱-1-核心类型不同" tabindex="-1">🧱 1. <strong>核心类型不同</strong> <a class="header-anchor" href="#🧱-1-核心类型不同" aria-hidden="true">#</a></h4><ul><li><strong><code>int</code></strong>：<strong>原始数据类型</strong>（Primitive Type），直接存储数据值（栈内存）。</li><li><strong><code>Integer</code></strong>：<strong>引用类型</strong>（类类型），是 <code>int</code> 的包装类（Object），存储的是对象的引用（堆内存）。</li></ul><h4 id="📊-2-内存与性能" tabindex="-1">📊 2. <strong>内存与性能</strong> <a class="header-anchor" href="#📊-2-内存与性能" aria-hidden="true">#</a></h4><table><thead><tr><th>特性</th><th><code>int</code></th><th><code>Integer</code></th></tr></thead><tbody><tr><td><strong>内存占用</strong></td><td>固定 4 字节</td><td>额外对象开销（约 16 字节）</td></tr><tr><td><strong>性能</strong></td><td>更高（无对象创建开销）</td><td>较低（涉及对象操作）</td></tr></tbody></table><h4 id="⚙️-3-自动装箱-autoboxing-与拆箱-unboxing" tabindex="-1">⚙️ 3. <strong>自动装箱（Autoboxing）与拆箱（Unboxing）</strong> <a class="header-anchor" href="#⚙️-3-自动装箱-autoboxing-与拆箱-unboxing" aria-hidden="true">#</a></h4><p>Java 5 开始引入自动转换机制：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 自动装箱：int → Integer</span></span>
<span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> boxed </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 等价于 Integer.valueOf(10)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 自动拆箱：Integer → int</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> unboxed </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> boxed</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 等价于 boxed.intValue()</span></span>
<span class="line"></span></code></pre></div><h4 id="🗃️-4-默认值" tabindex="-1">🗃️ 4. <strong>默认值</strong> <a class="header-anchor" href="#🗃️-4-默认值" aria-hidden="true">#</a></h4><ul><li><strong><code>int</code></strong>：默认值为 <code>0</code>。</li><li><strong><code>Integer</code></strong>：默认值为 <code>null</code>（可表示缺失值）。</li></ul><blockquote><p>💡 关键区别：<code>int</code> 无法为 <code>null</code>，<code>Integer</code> 可以表达数字缺失的逻辑（如数据库中的空字段）。</p></blockquote><h4 id="📦-5-缓存机制-flyweight-pattern" tabindex="-1">📦 5. <strong>缓存机制（Flyweight Pattern）</strong> <a class="header-anchor" href="#📦-5-缓存机制-flyweight-pattern" aria-hidden="true">#</a></h4><ul><li><strong><code>Integer</code></strong> 在 <code>-128 到 127</code> 范围内缓存对象：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">127</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">127</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// true，同一缓存对象</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> c </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">128</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> d </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">128</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">c </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> d</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// false，超出缓存，新建对象</span></span>
<span class="line"></span></code></pre></div></li><li><code>new Integer()</code> <strong>强制创建新对象</strong>（不推荐使用，已废弃）。</li></ul><h4 id="🔧-6-方法与功能" tabindex="-1">🔧 6. <strong>方法与功能</strong> <a class="header-anchor" href="#🔧-6-方法与功能" aria-hidden="true">#</a></h4><ul><li><strong><code>int</code></strong>：无方法（原始类型）。</li><li><strong><code>Integer</code></strong>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 实用方法</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> max </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Integer</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">MAX_VALUE</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// 最大值 2^31-1</span></span>
<span class="line"><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> s </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">123</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> num </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Integer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">parseInt</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">s</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 字符串转 int</span></span>
<span class="line"><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> hex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Integer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">toHexString</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">255</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 转为16进制 &quot;ff&quot;</span></span>
<span class="line"></span></code></pre></div></li></ul><h4 id="🧰-7-使用场景" tabindex="-1">🧰 7. <strong>使用场景</strong> <a class="header-anchor" href="#🧰-7-使用场景" aria-hidden="true">#</a></h4><table><thead><tr><th>场景</th><th>推荐类型</th><th>原因说明</th></tr></thead><tbody><tr><td>高频计算/循环</td><td><code>int</code></td><td>避免对象开销，性能最优</td></tr><tr><td>集合类存储</td><td><code>Integer</code></td><td>泛型要求对象类型（如 <code>List&lt;Integer&gt;</code>）</td></tr><tr><td>需表达 <code>null</code></td><td><code>Integer</code></td><td><code>int</code> 无法为 <code>null</code></td></tr><tr><td>反射/泛型</td><td><code>Integer</code></td><td>仅支持对象类型</td></tr></tbody></table><h4 id="✅-总结对比表" tabindex="-1">✅ 总结对比表 <a class="header-anchor" href="#✅-总结对比表" aria-hidden="true">#</a></h4><table><thead><tr><th>特性</th><th><code>int</code></th><th><code>Integer</code></th></tr></thead><tbody><tr><td><strong>类型</strong></td><td>原始类型（Primitive）</td><td>包装类（Object）</td></tr><tr><td><strong>内存</strong></td><td>栈内存（4字节）</td><td>堆内存 + 额外对象开销</td></tr><tr><td><strong>默认值</strong></td><td><code>0</code></td><td><code>null</code></td></tr><tr><td><strong>比较</strong></td><td><code>==</code> 比较值</td><td><code>equals()</code> 比较值，<code>==</code> 比较引用</td></tr><tr><td><strong>可空性（Null）</strong></td><td>❌ 不允许</td><td>✅ 允许</td></tr><tr><td><strong>方法</strong></td><td>无</td><td>提供丰富工具方法（如转换、计算）</td></tr><tr><td><strong>集合/泛型支持</strong></td><td>❌ 不支持</td><td>✅ 支持</td></tr></tbody></table><h4 id="⚠️-注意事项" tabindex="-1">⚠️ 注意事项 <a class="header-anchor" href="#⚠️-注意事项" aria-hidden="true">#</a></h4><ol><li><strong>空指针风险</strong>：<code>Integer</code> 为 <code>null</code> 时拆箱会抛出 <code>NullPointerException</code>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> num </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> value </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> num</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 抛出 NullPointerException!</span></span>
<span class="line"></span></code></pre></div></li><li><strong>比较陷阱</strong>：优先使用 <code>equals()</code> 而非 <code>==</code> 比较 <code>Integer</code> 值：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> x </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">200</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> y </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">200</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">x </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> y</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">      </span><span style="color:#676E95;font-style:italic;">// false（超出缓存范围）</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">x</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equals</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">y</span><span style="color:#89DDFF;">));</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"></span></code></pre></div></li></ol><h4 id="💻-代码示例" tabindex="-1">💻 代码示例 <a class="header-anchor" href="#💻-代码示例" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Main</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 原始类型 vs 包装类</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> primitive </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> wrapper </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 自动装箱与拆箱</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> autoBoxed </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> primitive</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 自动装箱</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> autoUnboxed </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> wrapper</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">      </span><span style="color:#676E95;font-style:italic;">// 自动拆箱</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 空值处理</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> nullable </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// int risk = nullable;       // 运行时抛 NullPointerException</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 用法示例</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Integer 转二进制: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> Integer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">toBinaryString</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">));</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 1010</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">解析字符串: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> Integer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">parseInt</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">FF</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">16</span><span style="color:#89DDFF;">));</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 255</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h4 id="📌-设计哲学" tabindex="-1">📌 设计哲学 <a class="header-anchor" href="#📌-设计哲学" aria-hidden="true">#</a></h4><ul><li><strong>原始类型 <code>int</code></strong>：追求极致性能的计算场景。</li><li><strong>包装类 <code>Integer</code></strong>：对象化处理，解决泛型支持、空值表达等系统级扩展需求。</li></ul><p>根据需求灵活选择二者，是写出高效 Java 代码的关键之一！🚀</p><hr><h2 id="对比vector-arraylist-linkedlist有何区别" tabindex="-1">对比Vector ArrayList LinkedList有何区别 <a class="header-anchor" href="#对比vector-arraylist-linkedlist有何区别" aria-hidden="true">#</a></h2><p>在Java中，<code>Vector</code>、<code>ArrayList</code>和<code>LinkedList</code>都是实现<code>List</code>接口的集合类，但在底层实现、性能特性和线程安全性上有显著差异。以下是详细对比：</p><hr><h4 id="_1-底层数据结构" tabindex="-1"><strong>1. 底层数据结构</strong> <a class="header-anchor" href="#_1-底层数据结构" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>类</strong></th><th><strong>数据结构</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong><code>Vector</code></strong></td><td>动态数组（数组）</td><td>基于可扩容的数组实现。初始容量默认为10，扩容后为 <strong>原容量的2倍</strong>（可通过构造器调整增量）。</td></tr><tr><td><strong><code>ArrayList</code></strong></td><td>动态数组（数组）</td><td>基于可扩容的数组实现。初始容量默认为10，扩容后为 <strong>原容量的1.5倍</strong>（<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>）。</td></tr><tr><td><strong><code>LinkedList</code></strong></td><td>双向链表</td><td>每个元素作为节点（<code>Node</code>）存储，包含前驱、后继引用和数据。</td></tr></tbody></table><hr><h4 id="_2-线程安全性" tabindex="-1"><strong>2. 线程安全性</strong> <a class="header-anchor" href="#_2-线程安全性" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>类</strong></th><th><strong>线程安全</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><strong><code>Vector</code></strong></td><td><strong>是</strong> (线程安全)</td><td>所有方法均通过<code>synchronized</code>同步锁实现，但并发效率低！</td></tr><tr><td><strong><code>ArrayList</code></strong></td><td>否 (非线程安全)</td><td>无同步机制。多线程操作需手动同步（如<code>Collections.synchronizedList()</code>）。</td></tr><tr><td><strong><code>LinkedList</code></strong></td><td>否 (非线程安全)</td><td>同上。</td></tr></tbody></table><blockquote><p>⚠️ <strong>提示</strong>：在高并发场景中，优先使用<code>CopyOnWriteArrayList</code>（读多写少）或<code>ConcurrentLinkedQueue</code>（高并发队列）。</p></blockquote><hr><h4 id="_3-性能关键点对比" tabindex="-1"><strong>3. 性能关键点对比</strong> <a class="header-anchor" href="#_3-性能关键点对比" aria-hidden="true">#</a></h4><h5 id="_1-随机访问-根据索引获取元素" tabindex="-1"><strong>(1) 随机访问（根据索引获取元素）</strong> <a class="header-anchor" href="#_1-随机访问-根据索引获取元素" aria-hidden="true">#</a></h5><table><thead><tr><th><strong>类</strong></th><th><strong>时间复杂度</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><strong><code>Vector</code></strong></td><td><strong>O(1)</strong></td><td>数组支持直接下标访问（<code>elementData[index]</code>）。</td></tr><tr><td><strong><code>ArrayList</code></strong></td><td><strong>O(1)</strong></td><td>同上（物理内存连续）。</td></tr><tr><td><strong><code>LinkedList</code></strong></td><td><strong>O(n)</strong></td><td>需要从头/尾遍历链表定位节点（最坏情况需遍历整个链表）。</td></tr></tbody></table><blockquote><p>✅ <strong>场景选择</strong>：需频繁随机访问时，优先选<code>ArrayList</code>或<code>Vector</code>。</p></blockquote><h5 id="_2-插入-删除操作" tabindex="-1"><strong>(2) 插入/删除操作</strong> <a class="header-anchor" href="#_2-插入-删除操作" aria-hidden="true">#</a></h5><table><thead><tr><th><strong>操作位置</strong></th><th><strong><code>Vector/ArrayList</code></strong></th><th><strong><code>LinkedList</code></strong></th></tr></thead><tbody><tr><td><strong>尾部操作</strong></td><td>O(1) 摊销时间</td><td>O(1)</td></tr><tr><td><strong>头部/中间操作</strong></td><td>O(n)（需移动后续元素）</td><td><strong>O(1)</strong>（仅修改节点引用，但需O(n)定位节点）</td></tr></tbody></table><blockquote><p>✅ <strong>场景选择</strong>：</p><ul><li>频繁在头部/中间插入/删除：<strong><code>LinkedList</code> 更优</strong>（如实现栈、队列或双向队列）。</li><li><code>ArrayList</code>尾部操作高效，但中间插入可能触发频繁扩容和元素拷贝。</li></ul></blockquote><h5 id="_3-内存占用" tabindex="-1"><strong>(3) 内存占用</strong> <a class="header-anchor" href="#_3-内存占用" aria-hidden="true">#</a></h5><table><thead><tr><th><strong>类</strong></th><th><strong>空间开销</strong></th></tr></thead><tbody><tr><td><strong><code>Vector</code></strong></td><td>数组结构（连续内存），存在预留容量空间（扩容后旧数组被GC回收）。</td></tr><tr><td><strong><code>ArrayList</code></strong></td><td>同上（空间效率比<code>Vector</code>略高，因扩容因子1.5 vs 2）。</td></tr><tr><td><strong><code>LinkedList</code></strong></td><td><strong>更高</strong>：每个节点需存储前驱/后继引用（占12-16字节额外内存 + 节点对象开销）。</td></tr></tbody></table><hr><h4 id="_4-扩容机制" tabindex="-1"><strong>4. 扩容机制</strong> <a class="header-anchor" href="#_4-扩容机制" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>类</strong></th><th><strong>扩容逻辑</strong></th></tr></thead><tbody><tr><td><strong><code>Vector</code></strong></td><td>扩容因子可指定（构造器<code>public Vector(int initialCapacity, int capacityIncrement)</code>），默认增量为<strong>原容量×2</strong>。</td></tr><tr><td><strong><code>ArrayList</code></strong></td><td>固定增量 <strong>原容量×1.5</strong>（无法自定义）。</td></tr><tr><td><strong><code>LinkedList</code></strong></td><td><strong>无需扩容</strong>（链表动态添加节点）。</td></tr></tbody></table><blockquote><p>⚠️ 频繁插入时，<code>ArrayList</code>的扩容会带来内存拷贝开销（<code>System.arraycopy()</code>）。</p></blockquote><hr><h4 id="_5-额外功能" tabindex="-1"><strong>5. 额外功能</strong> <a class="header-anchor" href="#_5-额外功能" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>类</strong></th><th><strong>特有功能</strong></th></tr></thead><tbody><tr><td><strong><code>Vector</code></strong></td><td>支持通过枚举器遍历（<code>Enumeration&lt;E&gt; elements()</code>），遗留方法且效率低于迭代器。</td></tr><tr><td><strong><code>LinkedList</code></strong></td><td>实现<code>Deque</code>接口，支持双端队列操作（<code>addFirst()</code>, <code>pollLast()</code>, <code>offer()</code>等）。</td></tr></tbody></table><hr><h4 id="_6-继承体系" tabindex="-1"><strong>6. 继承体系</strong> <a class="header-anchor" href="#_6-继承体系" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Vector</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Vector</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">AbstractList</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">List</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">RandomAccess</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Cloneable</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> java.io.</span><span style="color:#FFCB6B;">Serializable</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// ArrayList</span></span>
<span class="line"><span style="color:#A6ACCD;">public class </span><span style="color:#FFCB6B;">ArrayList</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">AbstractList</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">List</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">RandomAccess</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Cloneable</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> java.io.</span><span style="color:#FFCB6B;">Serializable</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// LinkedList</span></span>
<span class="line"><span style="color:#A6ACCD;">public class </span><span style="color:#FFCB6B;">LinkedList</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">AbstractSequentialList</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">List</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Deque</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">E</span><span style="color:#89DDFF;">&gt;,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Cloneable</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> java.io.</span><span style="color:#FFCB6B;">Serializable</span></span>
<span class="line"></span></code></pre></div><ul><li><strong><code>RandomAccess</code></strong>: <code>Vector</code>和<code>ArrayList</code>标记支持高效随机访问。</li><li><strong><code>Deque</code></strong>: <code>LinkedList</code>额外支持队列操作。</li></ul><hr><h4 id="总结-如何选择" tabindex="-1"><strong>总结：如何选择？</strong> <a class="header-anchor" href="#总结-如何选择" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐类</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td>读多写少，需随机访问</td><td><code>ArrayList</code></td><td>内存紧凑、访问快速，避免线程安全开销。</td></tr><tr><td>多线程环境</td><td>- 需同步：<code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code> <br> - 高并发写：<code>CopyOnWriteArrayList</code></td><td><code>Vector</code>不推荐（性能差，遗留类）。</td></tr><tr><td>频繁在任意位置插入/删除元素</td><td><code>LinkedList</code></td><td>链式结构修改高效，避免数组拷贝开销。</td></tr><tr><td>实现队列/双端队列</td><td><code>LinkedList</code></td><td>天然支持<code>Deque</code>接口（<code>PriorityQueue</code>等其他队列可替代）。</td></tr><tr><td>遗留系统兼容性</td><td><code>Vector</code></td><td>新代码不再建议使用。</td></tr></tbody></table><blockquote><p>💡 <strong>最佳实践</strong>：</p><ul><li><strong>首选<code>ArrayList</code></strong>：大部分场景性能最优（90%以上）。</li><li>避免在多线程中直接使用<code>ArrayList/LinkedList</code>（需手动同步）。</li><li><code>LinkedList</code>仅在对链表特性有明确需求时使用（如中间频繁修改或用作队列）。</li></ul></blockquote><hr><h2 id="对比hashtable-hashmap-treemap-有什么不同" tabindex="-1">对比Hashtable HashMap TreeMap 有什么不同 <a class="header-anchor" href="#对比hashtable-hashmap-treemap-有什么不同" aria-hidden="true">#</a></h2><p>在 Java 中，<code>Hashtable</code>、<code>HashMap</code> 和 <code>TreeMap</code> 都是实现 <code>Map</code> 接口的键值对集合类，但它们在设计、性能和线程安全方面有显著区别。以下是详细对比：</p><hr><h4 id="_1-线程安全性" tabindex="-1">1. <strong>线程安全性</strong> <a class="header-anchor" href="#_1-线程安全性" aria-hidden="true">#</a></h4><ul><li><strong><code>Hashtable</code></strong>：<strong>线程安全</strong>。所有方法通过 <code>synchronized</code> 关键字实现同步（悲观锁），适合多线程环境，但性能较低。<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Map</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Integer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> hashtable </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Hashtable</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 多线程操作安全</span></span>
<span class="line"></span></code></pre></div></li><li><strong><code>HashMap</code></strong>：<strong>非线程安全</strong>。未同步，多线程操作需手动同步（如 <code>Collections.synchronizedMap</code> 或 <code>ConcurrentHashMap</code>）。<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Map</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Integer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> hashMap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">HashMap</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 多线程操作需额外同步</span></span>
<span class="line"></span></code></pre></div></li><li><strong><code>TreeMap</code></strong>：<strong>非线程安全</strong>。未同步，多线程需手动处理（类似 <code>HashMap</code>）。</li></ul><hr><h4 id="_2-是否允许-null-键-值" tabindex="-1">2. <strong>是否允许 null 键/值</strong> <a class="header-anchor" href="#_2-是否允许-null-键-值" aria-hidden="true">#</a></h4><ul><li><strong><code>Hashtable</code></strong>：<strong>不允许</strong> null 键或值（抛出 <code>NullPointerException</code>）。<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">hashtable</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(null,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">      </span><span style="color:#676E95;font-style:italic;">// 抛出 NPE</span></span>
<span class="line"><span style="color:#A6ACCD;">hashtable</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">key</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null);</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 抛出 NPE</span></span>
<span class="line"></span></code></pre></div></li><li><strong><code>HashMap</code></strong>：<strong>允许</strong> 1 个 null 键和多个 null 值。<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">hashMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(null,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">       </span><span style="color:#676E95;font-style:italic;">// 允许</span></span>
<span class="line"><span style="color:#A6ACCD;">hashMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">key</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null);</span><span style="color:#A6ACCD;">   </span><span style="color:#676E95;font-style:italic;">// 允许</span></span>
<span class="line"></span></code></pre></div></li><li><strong><code>TreeMap</code></strong>：<strong>不允许 null 键</strong>（因需排序），但允许 null 值（取决于比较器）。<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(null,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">       </span><span style="color:#676E95;font-style:italic;">// 抛出 NPE</span></span>
<span class="line"><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">key</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null);</span><span style="color:#A6ACCD;">   </span><span style="color:#676E95;font-style:italic;">// 允许（若比较器支持）</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h4 id="_3-元素顺序" tabindex="-1">3. <strong>元素顺序</strong> <a class="header-anchor" href="#_3-元素顺序" aria-hidden="true">#</a></h4><ul><li><strong><code>Hashtable</code></strong> 和 <strong><code>HashMap</code></strong>：<strong>不保证顺序</strong>（迭代顺序可能随时间变化）。</li><li><strong><code>TreeMap</code></strong>：<strong>严格按键排序</strong>（自然顺序或自定义 <code>Comparator</code>）。<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">TreeMap</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Integer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> treeMap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">TreeMap</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">c</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">b</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 输出顺序：a=1, b=2, c=3</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h4 id="_4-底层实现" tabindex="-1">4. <strong>底层实现</strong> <a class="header-anchor" href="#_4-底层实现" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>实现类</strong></th><th><strong>数据结构</strong></th><th><strong>冲突解决</strong></th><th><strong>扩容机制</strong></th></tr></thead><tbody><tr><td><code>Hashtable</code></td><td><strong>数组 + 链表</strong></td><td>单链表</td><td>默认容量 11，负载因子 0.75</td></tr><tr><td><code>HashMap</code></td><td><strong>数组 + 链表/红黑树</strong></td><td>链表长度 ≥8 转红黑树</td><td>默认容量 16，负载因子 0.75</td></tr><tr><td><code>TreeMap</code></td><td><strong>红黑树</strong></td><td>树状结构自动平衡</td><td>无需扩容</td></tr></tbody></table><hr><h4 id="_5-性能对比" tabindex="-1">5. <strong>性能对比</strong> <a class="header-anchor" href="#_5-性能对比" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>操作</strong></th><th><strong>Hashtable</strong></th><th><strong>HashMap</strong></th><th><strong>TreeMap</strong></th></tr></thead><tbody><tr><td><strong><code>get()</code>/<code>put()</code></strong></td><td>O(1)（平均，冲突少）</td><td>O(1)（平均，冲突少）</td><td><strong>O(log n)</strong>（红黑树搜索）</td></tr><tr><td><strong>排序操作</strong></td><td>不支持</td><td>不支持</td><td><strong>高效</strong>（<code>firstKey()</code>, <code>subMap()</code>）</td></tr><tr><td><strong>线程安全开销</strong></td><td><strong>高</strong>（同步锁）</td><td>无（需手动同步）</td><td>无（需手动同步）</td></tr></tbody></table><ul><li><strong><code>HashMap</code></strong>：在哈希冲突少时性能最佳（平均 O(1)）。</li><li><strong><code>TreeMap</code></strong>：适合需要有序遍历的场景（如范围查询），但操作成本 O(log n)。</li></ul><hr><h4 id="_6-适用场景" tabindex="-1">6. <strong>适用场景</strong> <a class="header-anchor" href="#_6-适用场景" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>实现类</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><code>Hashtable</code></td><td><strong>遗留代码</strong>或不需高并发的多线程场景（推荐改用 <code>ConcurrentHashMap</code>）。</td></tr><tr><td><code>HashMap</code></td><td><strong>单线程</strong> 或 <strong>手动同步的多线程</strong> 环境（优先选择）。</td></tr><tr><td><code>TreeMap</code></td><td>需 <strong>键排序</strong> 或 <strong>范围查询</strong>（如 <code>keySet().subSet(from, to)</code>）。</td></tr></tbody></table><hr><h4 id="_7-额外特性" tabindex="-1">7. <strong>额外特性</strong> <a class="header-anchor" href="#_7-额外特性" aria-hidden="true">#</a></h4><ul><li><strong><code>HashMap</code></strong>： <ul><li>可指定初始容量和负载因子（优化性能）。</li><li>允许 fail-fast 迭代器（快速失败机制）。</li></ul></li><li><strong><code>TreeMap</code></strong>： <ul><li>实现 <code>NavigableMap</code> 接口，提供导航方法（如 <code>ceilingKey()</code>, <code>floorKey()</code>）。</li><li>支持自定义排序（通过 <code>Comparator</code>）。</li></ul></li></ul><hr><h4 id="代码示例" tabindex="-1">代码示例 <a class="header-anchor" href="#代码示例" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// HashMap 示例（允许 null）</span></span>
<span class="line"><span style="color:#C792EA;">Map</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Integer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> hashMap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">HashMap</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#A6ACCD;">hashMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">A</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">hashMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(null,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">      </span><span style="color:#676E95;font-style:italic;">// 允许</span></span>
<span class="line"><span style="color:#A6ACCD;">hashMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">B</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null);</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// 允许</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// TreeMap 示例（排序）</span></span>
<span class="line"><span style="color:#C792EA;">TreeMap</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Integer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> treeMap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">TreeMap</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Z</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">A</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">treeMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">keySet</span><span style="color:#89DDFF;">());</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 输出 [A, Z]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Hashtable 示例（线程安全）</span></span>
<span class="line"><span style="color:#C792EA;">Map</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Integer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> hashtable </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Hashtable</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#A6ACCD;">hashtable</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">C</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// hashtable.put(null, 4); // 抛出 NPE</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="总结对比表" tabindex="-1">总结对比表 <a class="header-anchor" href="#总结对比表" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>特性</strong></th><th><code>Hashtable</code></th><th><code>HashMap</code></th><th><code>TreeMap</code></th></tr></thead><tbody><tr><td><strong>线程安全</strong></td><td>✅（同步方法）</td><td>❌</td><td>❌</td></tr><tr><td><strong>Null 键/值</strong></td><td>❌/❌</td><td>✅/✅</td><td>❌（键）/✅（值）</td></tr><tr><td><strong>数据顺序</strong></td><td>❌</td><td>❌</td><td>✅（按键排序）</td></tr><tr><td><strong>底层结构</strong></td><td>数组+链表</td><td>数组+链表/红黑树</td><td>红黑树</td></tr><tr><td><strong>时间复杂度</strong></td><td>O(1)（平均）</td><td>O(1)（平均）</td><td>O(log n)</td></tr><tr><td><strong>排序支持</strong></td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td><strong>迭代器</strong></td><td>Enumerator</td><td>Iterator（fail-fast）</td><td>Iterator（基于树）</td></tr><tr><td><strong>推荐使用场景</strong></td><td>遗留多线程代码</td><td>通用键值对存储</td><td>需排序或范围查询</td></tr></tbody></table><blockquote><p><strong>推荐实践</strong>：</p><ul><li>优先使用 <code>HashMap</code>（单线程）或 <code>ConcurrentHashMap</code>（多线程）。</li><li>需要排序时选择 <code>TreeMap</code>。</li><li>避免在新代码中使用 <code>Hashtable</code>（遗留类）。</li></ul></blockquote><hr><h2 id="如何保证集合是线程安全的-concurenthashmap-如何实现高效地线程安全" tabindex="-1">如何保证集合是线程安全的 ConcurentHashMap 如何实现高效地线程安全 <a class="header-anchor" href="#如何保证集合是线程安全的-concurenthashmap-如何实现高效地线程安全" aria-hidden="true">#</a></h2><p>在Java中确保集合的线程安全性可以通过多种方式实现，以下是关键方法和原理，并以 <strong>ConcurrentHashMap 的高效线程安全实现</strong> 为核心进行详解：</p><hr><h4 id="一、保证集合线程安全的常见方法" tabindex="-1"><strong>一、保证集合线程安全的常见方法</strong> <a class="header-anchor" href="#一、保证集合线程安全的常见方法" aria-hidden="true">#</a></h4><ol><li><p><strong>互斥同步 (Synchronized Wrappers)</strong> 使用 <code>Collections.synchronizedXXX()</code> 包装集合，所有操作通过 <strong>对象级锁</strong>（如 <code>synchronized (mutex)</code>）实现线程安全：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Map</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> syncMap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Collections</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">synchronizedMap</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">HashMap</span><span style="color:#89DDFF;">&lt;&gt;());</span></span>
<span class="line"></span></code></pre></div><ul><li><strong>优点</strong>：实现简单。</li><li><strong>缺点</strong>：所有操作串行化，<strong>全局锁导致高并发性能低下</strong>。</li></ul></li><li><p><strong>并发集合 (java.util.concurrent)</strong> 使用 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等专为并发设计的容器：</p><ul><li><strong>无锁读操作</strong>：读取通常<strong>不需要加锁</strong>（依赖内存可见性保障）。</li><li><strong>细粒度锁/CAS</strong>：写入时仅锁定部分数据，高并发下性能优异。</li></ul></li></ol><hr><h4 id="二、concurrenthashmap-如何实现高效线程安全" tabindex="-1"><strong>二、ConcurrentHashMap 如何实现高效线程安全</strong> <a class="header-anchor" href="#二、concurrenthashmap-如何实现高效线程安全" aria-hidden="true">#</a></h4><p>以 <strong>JDK 8 后的实现</strong> 为例，核心设计如下：</p><h5 id="_1-底层结构优化" tabindex="-1"><strong>1. 底层结构优化</strong> <a class="header-anchor" href="#_1-底层结构优化" aria-hidden="true">#</a></h5><table><thead><tr><th><strong>组成</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>Node 数组 (table)</strong></td><td>存放键值对的基础数组，长度始终为 2 的幂（方便位运算定位桶）。</td></tr><tr><td><strong>链表 → 红黑树</strong></td><td>单个桶（Bucket）内：链表长度超过阈值（默认8）时转化为树，优化查询效率。</td></tr><tr><td><strong>volatile 修饰</strong></td><td>数组元素 <code>Node.val</code> 和 <code>Node.next</code> 为 <code>volatile</code>，保证内存可见性。</td></tr></tbody></table><h5 id="_2-并发控制机制" tabindex="-1"><strong>2. 并发控制机制</strong> <a class="header-anchor" href="#_2-并发控制机制" aria-hidden="true">#</a></h5><ul><li><strong>CAS (Compare-And-Swap) 操作</strong> 对<strong>桶为空</strong>的情况直接通过 CAS 写入（如 <code>tabAt(tab, i)</code> 和 <code>casTabAt()</code>），避免加锁。</li><li><strong>桶级锁 (Segment-Free)</strong> 对<strong>非空的桶</strong>，使用 <code>synchronized</code> 锁定桶的头节点（精细锁粒度，如锁定链表头或树的根节点）：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">f</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// f 是桶头节点</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">tabAt</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">tab</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> f</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 操作链表或树</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul><h5 id="_3-高效并发操作示例" tabindex="-1"><strong>3. 高效并发操作示例</strong> <a class="header-anchor" href="#_3-高效并发操作示例" aria-hidden="true">#</a></h5><ul><li><strong><code>get(Object key)</code></strong> 无需锁，遍历链表/树（依赖 <code>volatile</code> 变量保障数据可见性）。</li><li><strong><code>put(K key, V value)</code></strong><ol><li>计算哈希，定位桶位置 <code>i</code>。</li><li>若桶为空 → <strong>CAS 插入</strong>。</li><li>若桶非空 → <strong>同步锁头节点</strong> → 插入链表/树。</li><li>若链表超长 → 树化（树节点复用 <code>TreeNode</code>，减少对象开销）。</li></ol></li></ul><h5 id="_4-扩容策略-multi-threaded-transfer" tabindex="-1"><strong>4. 扩容策略 (Multi-Threaded Transfer)</strong> <a class="header-anchor" href="#_4-扩容策略-multi-threaded-transfer" aria-hidden="true">#</a></h5><ul><li><strong>并发扩容迁移</strong> 线程在插入时若检测到 <code>table</code> 在扩容，可<strong>协助迁移数据</strong>（<code>helpTransfer()</code>）。</li><li><strong>分段迁移桶</strong> 将原数组划分为多个区间，不同线程负责不同区间的迁移（迁移完成后标记为 <code>ForwardingNode</code>）。</li><li><strong>非阻塞性</strong> 读操作在迁移过程中可访问旧数组或新数组，无阻塞；写操作参与扩容。</li></ul><h5 id="_5-计数实现-counter-cells" tabindex="-1"><strong>5. 计数实现 (Counter Cells)</strong> <a class="header-anchor" href="#_5-计数实现-counter-cells" aria-hidden="true">#</a></h5><ul><li><strong>LongAdder 思想</strong> 使用 <code>CounterCell[]</code> 分散计数，解决 <code>size()</code> 的原子性瓶颈。</li><li><strong>求和逻辑</strong><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">long</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">sumCount</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">CounterCell</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> cs </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> counterCells</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">long</span><span style="color:#A6ACCD;"> sum </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> baseCount</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">cs </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">CounterCell</span><span style="color:#A6ACCD;"> cell </span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> cs</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">            sum </span><span style="color:#89DDFF;">+=</span><span style="color:#A6ACCD;"> cell</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 分段累加减少冲突</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> sum</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h4 id="三、concurrenthashmap-的优势总结" tabindex="-1"><strong>三、ConcurrentHashMap 的优势总结</strong> <a class="header-anchor" href="#三、concurrenthashmap-的优势总结" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>技术</strong></th><th><strong>解决的问题</strong></th><th><strong>性能影响</strong></th></tr></thead><tbody><tr><td><strong>CAS + 桶锁</strong></td><td>锁粒度从整个表 → 单个桶</td><td>冲突减少 99%（理想情况）</td></tr><tr><td><strong>链表转红黑树</strong></td><td>避免哈希冲突导致的长链表查询退化</td><td>查询复杂度 O(1) → O(log n)</td></tr><tr><td><strong>并发扩容</strong></td><td>多线程协作迁移数据，避免单点性能瓶颈</td><td>扩容期间仍能响应读写请求</td></tr><tr><td><strong>分段计数</strong></td><td>原子计数分摊到多个 Cell，避免自旋阻塞</td><td><code>size()</code> 调用接近常数时间</td></tr></tbody></table><blockquote><p><strong>注</strong>：JDK 7 的分段锁（<code>Segment</code>）因不够灵活已被弃用，JDK 8 的设计实现了更高并发度。</p></blockquote><hr><h4 id="四、与其他线程安全方案的对比" tabindex="-1"><strong>四、与其他线程安全方案的对比</strong> <a class="header-anchor" href="#四、与其他线程安全方案的对比" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>方案</strong></th><th><strong>写入性能</strong></th><th><strong>读取性能</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><code>Collections.synchronizedMap</code></td><td>低（全局锁）</td><td>低（锁竞争）</td><td>简单应用，低并发</td></tr><tr><td><code>Hashtable</code></td><td>低（全局锁）</td><td>低（锁竞争）</td><td>已废弃，不推荐使用</td></tr><tr><td><strong><code>ConcurrentHashMap</code></strong></td><td><strong>高</strong></td><td><strong>极高</strong></td><td>高并发读写</td></tr><tr><td><code>CopyOnWriteArrayList</code></td><td>极低（复制全量数据）</td><td>极高（无锁）</td><td>读多写极少场景</td></tr></tbody></table><hr><h4 id="总结-2" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结-2" aria-hidden="true">#</a></h4><p><strong>ConcurrentHashMap 的高效性源于：</strong> ✅ <strong>桶锁粒度</strong>：仅锁定冲突桶（而非全局）。 ✅ <strong>CAS 无锁写入</strong>：无冲突时直接更新。 ✅ <strong>并发扩容设计</strong>：迁移任务分摊给多个线程。 ✅ <strong>数据结构优化</strong>：红黑树减少哈希冲突导致的性能抖动。</p><p>在实际开发中，对高并发 Map 操作，推荐<strong>始终选择 <code>ConcurrentHashMap</code></strong>，而非基于全表锁的同步包装类。</p><hr><h2 id="java提供了哪些io方式-nio如何实现多路复用" tabindex="-1">java提供了哪些IO方式？NIO如何实现多路复用？ <a class="header-anchor" href="#java提供了哪些io方式-nio如何实现多路复用" aria-hidden="true">#</a></h2><p>Java 提供了多种 I/O 模型以适应不同场景需求，主要分为三类：<strong>BIO（Blocking I/O）</strong>、<strong>NIO（Non-blocking I/O 或 New I/O）</strong> 和 <strong>AIO（Asynchronous I/O）</strong>。</p><hr><h4 id="一、java-提供的-i-o-方式" tabindex="-1"><strong>一、Java 提供的 I/O 方式</strong> <a class="header-anchor" href="#一、java-提供的-i-o-方式" aria-hidden="true">#</a></h4><h5 id="_1-bio-blocking-i-o" tabindex="-1">1. <strong>BIO（Blocking I/O）</strong> <a class="header-anchor" href="#_1-bio-blocking-i-o" aria-hidden="true">#</a></h5><ul><li><strong>特点</strong>：同步阻塞模型，一个连接一个线程。</li><li><strong>工作流程</strong>： <ul><li>当线程调用 <code>read()</code> 或 <code>write()</code> 时，会被阻塞直到数据准备就绪或完成传输。</li></ul></li><li><strong>适用场景</strong>： <ul><li>低并发、连接数较少的场景（如内部系统）。</li></ul></li><li><strong>核心类</strong>： <ul><li><code>InputStream</code> / <code>OutputStream</code>（字节流）</li><li><code>Reader</code> / <code>Writer</code>（字符流）</li><li><code>Socket</code> / <code>ServerSocket</code>（网络通信）</li></ul></li><li><strong>缺点</strong>： <ul><li>线程资源消耗大，高并发时可能导致线程耗尽。</li></ul></li></ul><h5 id="_2-nio-non-blocking-i-o" tabindex="-1">2. <strong>NIO（Non-blocking I/O）</strong> <a class="header-anchor" href="#_2-nio-non-blocking-i-o" aria-hidden="true">#</a></h5><ul><li><strong>特点</strong>：同步非阻塞模型，基于<strong>多路复用（Multiplexing）</strong>，一个线程处理多个连接。</li><li><strong>工作流程</strong>： <ul><li>通道（Channel）注册到选择器（Selector），由 Selector 轮询就绪事件。</li><li>线程不会被 I/O 操作阻塞。</li></ul></li><li><strong>适用场景</strong>： <ul><li>高并发、大量连接但数据量较小的场景（如聊天服务器、网关）。</li></ul></li><li><strong>核心组件</strong>： <ul><li><strong>Buffer（缓冲区）</strong>：<code>ByteBuffer</code> 等，用于数据存储。</li><li><strong>Channel（通道）</strong>：<code>SocketChannel</code>、<code>ServerSocketChannel</code>，支持非阻塞读写。</li><li><strong>Selector（选择器）</strong>：核心多路复用器，监听多个 Channel 的事件。</li></ul></li><li><strong>优点</strong>：减少线程数量，提高资源利用率。</li></ul><h5 id="_3-aio-asynchronous-i-o" tabindex="-1">3. <strong>AIO（Asynchronous I/O）</strong> <a class="header-anchor" href="#_3-aio-asynchronous-i-o" aria-hidden="true">#</a></h5><ul><li><strong>特点</strong>：异步非阻塞模型，基于回调或 Future 通知。</li><li><strong>工作流程</strong>： <ul><li>应用发起 I/O 操作后立即返回，操作系统完成操作后主动回调通知。</li></ul></li><li><strong>适用场景</strong>： <ul><li>高并发且数据量大的场景（如文件操作、长连接）。</li></ul></li><li><strong>核心类</strong>： <ul><li><code>AsynchronousSocketChannel</code> / <code>AsynchronousServerSocketChannel</code></li><li><code>CompletionHandler</code>（回调处理器）</li></ul></li><li><strong>优点</strong>：彻底解放线程，但编程模型较复杂。</li></ul><hr><h4 id="二、nio-多路复用的实现原理" tabindex="-1"><strong>二、NIO 多路复用的实现原理</strong> <a class="header-anchor" href="#二、nio-多路复用的实现原理" aria-hidden="true">#</a></h4><p>多路复用的核心是通过 <strong>Selector</strong> 监控多个 Channel 的 I/O 事件（如连接、读、写），使单线程能够高效管理多个连接。</p><h5 id="关键实现步骤" tabindex="-1">关键实现步骤： <a class="header-anchor" href="#关键实现步骤" aria-hidden="true">#</a></h5><ol><li><p><strong>创建 Selector</strong> 通过静态方法创建选择器：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Selector</span><span style="color:#A6ACCD;"> selector </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Selector</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">open</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>配置 Channel 为非阻塞模式</strong> 将 Channel 设置为非阻塞（必须）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ServerSocketChannel</span><span style="color:#A6ACCD;"> serverChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ServerSocketChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">open</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">serverChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">configureBlocking</span><span style="color:#89DDFF;">(false);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 关键！</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>注册 Channel 到 Selector</strong> 指定要监听的事件（如 <code>OP_ACCEPT</code>、<code>OP_READ</code>）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">serverChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">register</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">selector</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> SelectionKey</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">OP_ACCEPT</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>轮询就绪事件</strong> 调用 <code>select()</code> 阻塞等待事件发生（可设置超时）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(true)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    selector</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">select</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 阻塞直到有就绪事件</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Set</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">SelectionKey</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> keys </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> selector</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">selectedKeys</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Iterator</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">SelectionKey</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> iter </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> keys</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">iterator</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">iter</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hasNext</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">SelectionKey</span><span style="color:#A6ACCD;"> key </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> iter</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">next</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        iter</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">remove</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 移除已处理事件</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 处理事件...</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>处理不同类型的事件</strong> 根据 <code>SelectionKey</code> 的事件类型执行操作：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isAcceptable</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 接受新连接</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">SocketChannel</span><span style="color:#A6ACCD;"> clientChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> serverChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">accept</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    clientChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">configureBlocking</span><span style="color:#89DDFF;">(false);</span></span>
<span class="line"><span style="color:#A6ACCD;">    clientChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">register</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">selector</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> SelectionKey</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">OP_READ</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isReadable</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 读取客户端数据</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">SocketChannel</span><span style="color:#A6ACCD;"> channel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">SocketChannel</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">channel</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">ByteBuffer</span><span style="color:#A6ACCD;"> buffer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ByteBuffer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">allocate</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1024</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    channel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">read</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">buffer</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 处理数据...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isWritable</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 写数据（通常只在需要时才注册写事件）</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ol><hr><h4 id="三、操作系统层面的多路复用机制" tabindex="-1"><strong>三、操作系统层面的多路复用机制</strong> <a class="header-anchor" href="#三、操作系统层面的多路复用机制" aria-hidden="true">#</a></h4><p>Selector 的底层依赖于操作系统的 I/O 多路复用技术：</p><ul><li><strong>Linux</strong>：基于 <strong>epoll</strong>（高效的红黑树 + 事件驱动）</li><li><strong>Windows</strong>：基于 <strong>IOCP</strong>（I/O Completion Port）</li><li><strong>macOS/BSD</strong>：基于 <strong>kqueue</strong></li></ul><p>以 Linux 的 epoll 为例：</p><ol><li><strong>创建 epoll 实例</strong><code>epoll_create()</code> 初始化一个事件表。</li><li><strong>注册文件描述符（FD）</strong><code>epoll_ctl()</code> 将 Socket FD 加入 epoll，监听事件（EPOLLIN/EPOLLOUT）。</li><li><strong>等待事件就绪</strong><code>epoll_wait()</code> 阻塞直到有 FD 就绪，返回就绪的 FD 列表。</li><li><strong>处理事件</strong> 遍历就绪列表进行读写操作（非阻塞）。</li></ol><blockquote><p><strong>Java NIO 与 epoll 的关系</strong> 当调用 <code>Selector.open()</code> 时，Java 默认使用 <code>EPollSelectorProvider</code>（Linux）创建 epoll 实例，最终通过 <code>native</code> 方法调用操作系统 API。</p></blockquote><hr><h4 id="四、多路复用的优势与局限性" tabindex="-1"><strong>四、多路复用的优势与局限性</strong> <a class="header-anchor" href="#四、多路复用的优势与局限性" aria-hidden="true">#</a></h4><h5 id="优势" tabindex="-1"><strong>优势</strong>： <a class="header-anchor" href="#优势" aria-hidden="true">#</a></h5><ol><li><strong>高并发支撑</strong> 单线程可处理数万连接，避免 BIO 的线程爆炸问题。</li><li><strong>资源高效</strong> 减少线程上下文切换和内存占用。</li><li><strong>延迟优化</strong> 事件就绪时才触发操作，响应速度更快。</li></ol><h5 id="局限性" tabindex="-1"><strong>局限性</strong>： <a class="header-anchor" href="#局限性" aria-hidden="true">#</a></h5><ol><li><strong>编程复杂</strong> 需处理缓冲区、事件状态等细节。</li><li><strong>数据量小时高效</strong> 长连接处理大文件时仍可能阻塞（需配合线程池）。</li><li><strong>平台差异</strong> 不同操作系统的实现存在性能差异（epoll 最优）。</li></ol><hr><h4 id="总结-3" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结-3" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>I/O 模型</strong></th><th>阻塞方式</th><th>线程要求</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>BIO</strong></td><td>同步阻塞</td><td>一连接一线程</td><td>低并发、简单应用</td></tr><tr><td><strong>NIO</strong></td><td>同步非阻塞</td><td>多路复用单/少线程</td><td>高并发、短连接（如 Web）</td></tr><tr><td><strong>AIO</strong></td><td>异步非阻塞</td><td>回调/Future</td><td>高吞吐、长连接（如文件）</td></tr></tbody></table><p>多路复用是 NIO 的核心，通过 <strong>Selector + Channel + Buffer</strong> 组合，结合操作系统的 epoll/kqueue/IOCP 机制，实现高效的 I/O 管理。尽管编程模型复杂，但在高并发场景下优势显著，是构建高性能网络服务的基石。</p><hr><h2 id="java提供了哪些io方式-nio如何实现多路复用-1" tabindex="-1">java提供了哪些IO方式？NIO如何实现多路复用？ <a class="header-anchor" href="#java提供了哪些io方式-nio如何实现多路复用-1" aria-hidden="true">#</a></h2><p>Java 提供了多种 I/O 模型以适应不同场景需求，主要分为三类：<strong>BIO（Blocking I/O）</strong>、<strong>NIO（Non-blocking I/O 或 New I/O）</strong> 和 <strong>AIO（Asynchronous I/O）</strong>。</p><hr><h4 id="一、java-提供的-i-o-方式-1" tabindex="-1"><strong>一、Java 提供的 I/O 方式</strong> <a class="header-anchor" href="#一、java-提供的-i-o-方式-1" aria-hidden="true">#</a></h4><h5 id="_1-bio-blocking-i-o-1" tabindex="-1">1. <strong>BIO（Blocking I/O）</strong> <a class="header-anchor" href="#_1-bio-blocking-i-o-1" aria-hidden="true">#</a></h5><ul><li><strong>特点</strong>：同步阻塞模型，一个连接一个线程。</li><li><strong>工作流程</strong>： <ul><li>当线程调用 <code>read()</code> 或 <code>write()</code> 时，会被阻塞直到数据准备就绪或完成传输。</li></ul></li><li><strong>适用场景</strong>： <ul><li>低并发、连接数较少的场景（如内部系统）。</li></ul></li><li><strong>核心类</strong>： <ul><li><code>InputStream</code> / <code>OutputStream</code>（字节流）</li><li><code>Reader</code> / <code>Writer</code>（字符流）</li><li><code>Socket</code> / <code>ServerSocket</code>（网络通信）</li></ul></li><li><strong>缺点</strong>： <ul><li>线程资源消耗大，高并发时可能导致线程耗尽。</li></ul></li></ul><h5 id="_2-nio-non-blocking-i-o-1" tabindex="-1">2. <strong>NIO（Non-blocking I/O）</strong> <a class="header-anchor" href="#_2-nio-non-blocking-i-o-1" aria-hidden="true">#</a></h5><ul><li><strong>特点</strong>：同步非阻塞模型，基于<strong>多路复用（Multiplexing）</strong>，一个线程处理多个连接。</li><li><strong>工作流程</strong>： <ul><li>通道（Channel）注册到选择器（Selector），由 Selector 轮询就绪事件。</li><li>线程不会被 I/O 操作阻塞。</li></ul></li><li><strong>适用场景</strong>： <ul><li>高并发、大量连接但数据量较小的场景（如聊天服务器、网关）。</li></ul></li><li><strong>核心组件</strong>： <ul><li><strong>Buffer（缓冲区）</strong>：<code>ByteBuffer</code> 等，用于数据存储。</li><li><strong>Channel（通道）</strong>：<code>SocketChannel</code>、<code>ServerSocketChannel</code>，支持非阻塞读写。</li><li><strong>Selector（选择器）</strong>：核心多路复用器，监听多个 Channel 的事件。</li></ul></li><li><strong>优点</strong>：减少线程数量，提高资源利用率。</li></ul><h5 id="_3-aio-asynchronous-i-o-1" tabindex="-1">3. <strong>AIO（Asynchronous I/O）</strong> <a class="header-anchor" href="#_3-aio-asynchronous-i-o-1" aria-hidden="true">#</a></h5><ul><li><strong>特点</strong>：异步非阻塞模型，基于回调或 Future 通知。</li><li><strong>工作流程</strong>： <ul><li>应用发起 I/O 操作后立即返回，操作系统完成操作后主动回调通知。</li></ul></li><li><strong>适用场景</strong>： <ul><li>高并发且数据量大的场景（如文件操作、长连接）。</li></ul></li><li><strong>核心类</strong>： <ul><li><code>AsynchronousSocketChannel</code> / <code>AsynchronousServerSocketChannel</code></li><li><code>CompletionHandler</code>（回调处理器）</li></ul></li><li><strong>优点</strong>：彻底解放线程，但编程模型较复杂。</li></ul><hr><h4 id="二、nio-多路复用的实现原理-1" tabindex="-1"><strong>二、NIO 多路复用的实现原理</strong> <a class="header-anchor" href="#二、nio-多路复用的实现原理-1" aria-hidden="true">#</a></h4><p>多路复用的核心是通过 <strong>Selector</strong> 监控多个 Channel 的 I/O 事件（如连接、读、写），使单线程能够高效管理多个连接。</p><h5 id="关键实现步骤-1" tabindex="-1">关键实现步骤： <a class="header-anchor" href="#关键实现步骤-1" aria-hidden="true">#</a></h5><ol><li><p><strong>创建 Selector</strong> 通过静态方法创建选择器：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Selector</span><span style="color:#A6ACCD;"> selector </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Selector</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">open</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>配置 Channel 为非阻塞模式</strong> 将 Channel 设置为非阻塞（必须）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ServerSocketChannel</span><span style="color:#A6ACCD;"> serverChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ServerSocketChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">open</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">serverChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">configureBlocking</span><span style="color:#89DDFF;">(false);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 关键！</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>注册 Channel 到 Selector</strong> 指定要监听的事件（如 <code>OP_ACCEPT</code>、<code>OP_READ</code>）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">serverChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">register</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">selector</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> SelectionKey</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">OP_ACCEPT</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>轮询就绪事件</strong> 调用 <code>select()</code> 阻塞等待事件发生（可设置超时）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(true)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    selector</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">select</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 阻塞直到有就绪事件</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Set</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">SelectionKey</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> keys </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> selector</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">selectedKeys</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Iterator</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">SelectionKey</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> iter </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> keys</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">iterator</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">iter</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hasNext</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">SelectionKey</span><span style="color:#A6ACCD;"> key </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> iter</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">next</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        iter</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">remove</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 移除已处理事件</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 处理事件...</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>处理不同类型的事件</strong> 根据 <code>SelectionKey</code> 的事件类型执行操作：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isAcceptable</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 接受新连接</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">SocketChannel</span><span style="color:#A6ACCD;"> clientChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> serverChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">accept</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    clientChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">configureBlocking</span><span style="color:#89DDFF;">(false);</span></span>
<span class="line"><span style="color:#A6ACCD;">    clientChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">register</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">selector</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> SelectionKey</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">OP_READ</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isReadable</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 读取客户端数据</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">SocketChannel</span><span style="color:#A6ACCD;"> channel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">SocketChannel</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">channel</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">ByteBuffer</span><span style="color:#A6ACCD;"> buffer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ByteBuffer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">allocate</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1024</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    channel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">read</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">buffer</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 处理数据...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isWritable</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 写数据（通常只在需要时才注册写事件）</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ol><hr><h4 id="三、操作系统层面的多路复用机制-1" tabindex="-1"><strong>三、操作系统层面的多路复用机制</strong> <a class="header-anchor" href="#三、操作系统层面的多路复用机制-1" aria-hidden="true">#</a></h4><p>Selector 的底层依赖于操作系统的 I/O 多路复用技术：</p><ul><li><strong>Linux</strong>：基于 <strong>epoll</strong>（高效的红黑树 + 事件驱动）</li><li><strong>Windows</strong>：基于 <strong>IOCP</strong>（I/O Completion Port）</li><li><strong>macOS/BSD</strong>：基于 <strong>kqueue</strong></li></ul><p>以 Linux 的 epoll 为例：</p><ol><li><strong>创建 epoll 实例</strong><code>epoll_create()</code> 初始化一个事件表。</li><li><strong>注册文件描述符（FD）</strong><code>epoll_ctl()</code> 将 Socket FD 加入 epoll，监听事件（EPOLLIN/EPOLLOUT）。</li><li><strong>等待事件就绪</strong><code>epoll_wait()</code> 阻塞直到有 FD 就绪，返回就绪的 FD 列表。</li><li><strong>处理事件</strong> 遍历就绪列表进行读写操作（非阻塞）。</li></ol><blockquote><p><strong>Java NIO 与 epoll 的关系</strong> 当调用 <code>Selector.open()</code> 时，Java 默认使用 <code>EPollSelectorProvider</code>（Linux）创建 epoll 实例，最终通过 <code>native</code> 方法调用操作系统 API。</p></blockquote><hr><h4 id="四、多路复用的优势与局限性-1" tabindex="-1"><strong>四、多路复用的优势与局限性</strong> <a class="header-anchor" href="#四、多路复用的优势与局限性-1" aria-hidden="true">#</a></h4><h5 id="优势-1" tabindex="-1"><strong>优势</strong>： <a class="header-anchor" href="#优势-1" aria-hidden="true">#</a></h5><ol><li><strong>高并发支撑</strong> 单线程可处理数万连接，避免 BIO 的线程爆炸问题。</li><li><strong>资源高效</strong> 减少线程上下文切换和内存占用。</li><li><strong>延迟优化</strong> 事件就绪时才触发操作，响应速度更快。</li></ol><h5 id="局限性-1" tabindex="-1"><strong>局限性</strong>： <a class="header-anchor" href="#局限性-1" aria-hidden="true">#</a></h5><ol><li><strong>编程复杂</strong> 需处理缓冲区、事件状态等细节。</li><li><strong>数据量小时高效</strong> 长连接处理大文件时仍可能阻塞（需配合线程池）。</li><li><strong>平台差异</strong> 不同操作系统的实现存在性能差异（epoll 最优）。</li></ol><hr><h4 id="总结-4" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结-4" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>I/O 模型</strong></th><th>阻塞方式</th><th>线程要求</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>BIO</strong></td><td>同步阻塞</td><td>一连接一线程</td><td>低并发、简单应用</td></tr><tr><td><strong>NIO</strong></td><td>同步非阻塞</td><td>多路复用单/少线程</td><td>高并发、短连接（如 Web）</td></tr><tr><td><strong>AIO</strong></td><td>异步非阻塞</td><td>回调/Future</td><td>高吞吐、长连接（如文件）</td></tr></tbody></table><p>多路复用是 NIO 的核心，通过 <strong>Selector + Channel + Buffer</strong> 组合，结合操作系统的 epoll/kqueue/IOCP 机制，实现高效的 I/O 管理。尽管编程模型复杂，但在高并发场景下优势显著，是构建高性能网络服务的基石。</p><hr><h2 id="java中有几种文件拷贝方式-那种最高效" tabindex="-1">java中有几种文件拷贝方式？那种最高效？ <a class="header-anchor" href="#java中有几种文件拷贝方式-那种最高效" aria-hidden="true">#</a></h2><p>在Java中，实现文件拷贝主要有以下几种方式，效率从低到高排列：</p><h4 id="_1-传统的流-java-io包" tabindex="-1">1. <strong>传统的流（<code>java.io</code>包）</strong> <a class="header-anchor" href="#_1-传统的流-java-io包" aria-hidden="true">#</a></h4><ul><li>使用<code>FileInputStream</code> + <code>FileOutputStream</code></li><li>使用 <strong>缓冲流</strong>（<code>BufferedInputStream</code> + <code>BufferedOutputStream</code>）</li><li><strong>优点</strong>：兼容性好（Java 1.0+）</li><li><strong>缺点</strong>：多级缓冲可能带来额外开销</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">InputStream</span><span style="color:#A6ACCD;"> is </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">BufferedInputStream</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">FileInputStream</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">source.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">));</span></span>
<span class="line"><span style="color:#A6ACCD;">     </span><span style="color:#C792EA;">OutputStream</span><span style="color:#A6ACCD;"> os </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">BufferedOutputStream</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">FileOutputStream</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">target.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">byte</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> buffer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">byte</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">8192</span><span style="color:#89DDFF;">];</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 8KB缓冲区</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> len</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">((</span><span style="color:#A6ACCD;">len </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> is</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">read</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">buffer</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        os</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">write</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">buffer</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> len</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="_2-nio-的-filechannel" tabindex="-1">2. <strong>NIO 的 <code>FileChannel</code></strong> <a class="header-anchor" href="#_2-nio-的-filechannel" aria-hidden="true">#</a></h4><ul><li>使用<code>transferTo()</code>或<code>transferFrom()</code> <strong>（效率最高）</strong></li><li><strong>优点</strong>：利用操作系统零拷贝（zero-copy），减少内核态与用户态切换</li><li><strong>适用场景</strong>：大文件拷贝</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">FileChannel</span><span style="color:#A6ACCD;"> srcChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">FileInputStream</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">source.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">getChannel</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">     </span><span style="color:#C792EA;">FileChannel</span><span style="color:#A6ACCD;"> destChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">FileOutputStream</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">target.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">getChannel</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    srcChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">transferTo</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> srcChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">size</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> destChannel</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 或 destChannel.transferFrom(srcChannel, 0, srcChannel.size());</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="_3-files-copy-工具方法-推荐" tabindex="-1">3. <strong><code>Files.copy()</code> 工具方法（推荐）</strong> <a class="header-anchor" href="#_3-files-copy-工具方法-推荐" aria-hidden="true">#</a></h4><ul><li>Java 7+ <code>java.nio.file.Files</code></li><li><strong>内部优化</strong>：自动选择<code>FileChannel</code>或流（根据不同操作系统）</li><li><strong>优点</strong>：代码简洁高效</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Path</span><span style="color:#A6ACCD;"> source </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Paths</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">source.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#C792EA;">Path</span><span style="color:#A6ACCD;"> target </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Paths</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">target.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">Files</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">copy</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">source</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> StandardCopyOption</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">REPLACE_EXISTING</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="_4-内存映射文件-mappedbytebuffer" tabindex="-1">4. <strong>内存映射文件（MappedByteBuffer）</strong> <a class="header-anchor" href="#_4-内存映射文件-mappedbytebuffer" aria-hidden="true">#</a></h4><ul><li>适用于频繁读写时，但<strong>拷贝场景不常用</strong></li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">RandomAccessFile</span><span style="color:#A6ACCD;"> srcFile </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">RandomAccessFile</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">source.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">r</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">     </span><span style="color:#C792EA;">RandomAccessFile</span><span style="color:#A6ACCD;"> destFile </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">RandomAccessFile</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">target.txt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">rw</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">FileChannel</span><span style="color:#A6ACCD;"> srcChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> srcFile</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getChannel</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">FileChannel</span><span style="color:#A6ACCD;"> destChannel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> destFile</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getChannel</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">MappedByteBuffer</span><span style="color:#A6ACCD;"> srcBuffer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> srcChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">map</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">FileChannel</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">MapMode</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">READ_ONLY</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> srcChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">size</span><span style="color:#89DDFF;">());</span></span>
<span class="line"><span style="color:#A6ACCD;">    destChannel</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">write</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">srcBuffer</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="✅-效率终极排行-大文件场景" tabindex="-1">✅ 效率终极排行（大文件场景） <a class="header-anchor" href="#✅-效率终极排行-大文件场景" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>方式</strong></th><th><strong>效率</strong></th><th><strong>推荐指数</strong></th><th>特点</th></tr></thead><tbody><tr><td><code>FileChannel.transferTo()</code></td><td>⭐⭐⭐⭐⭐</td><td>最高</td><td>零拷贝优化，内核层直接操作</td></tr><tr><td><code>Files.copy()</code></td><td>⭐⭐⭐⭐</td><td>首选</td><td>内部优化，简洁可靠</td></tr><tr><td>缓冲流（带缓冲区）</td><td>⭐⭐⭐</td><td>一般</td><td>兼容性强</td></tr><tr><td>普通I/O流</td><td>⭐⭐</td><td>不推荐</td><td>未缓冲，性能差</td></tr><tr><td><code>MappedByteBuffer</code></td><td>⭐⭐⭐</td><td>非拷贝首选</td><td>适合随机访问</td></tr></tbody></table><hr><h4 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-hidden="true">#</a></h4><ul><li><p><strong>最高效的方式</strong>：<strong><code>FileChannel.transferTo()</code></strong> 或 <strong><code>transferFrom()</code></strong> （利用操作系统零拷贝，减少用户态-内核态切换，尤其适合大文件）</p></li><li><p><strong>日常开发推荐</strong>：<strong><code>Files.copy()</code></strong> （API简洁，内置优化，无需手动管理缓冲区和流）</p></li></ul><blockquote><p>💡 <strong>性能对比</strong>（实际测试参考）：</p><ul><li>对于数GB级大文件，<code>FileChannel</code>比传统流快 20%~50%</li><li><code>Files.copy()</code> 在多数JDK中自动调用 <code>FileChannel</code>，几乎等效</li></ul></blockquote><p>建议：优先使用 <strong><code>Files.copy()</code></strong>，需要极致性能时手动使用 <strong><code>FileChannel</code></strong>。</p><hr><h2 id="谈谈接口和抽象类有什么区别" tabindex="-1">谈谈接口和抽象类有什么区别？ <a class="header-anchor" href="#谈谈接口和抽象类有什么区别" aria-hidden="true">#</a></h2><p>在Java中，接口（<code>interface</code>）和抽象类（<code>abstract class</code>）都是实现抽象和多态的关键机制，但它们在使用场景和特性上有显著区别。以下是核心区别对比：</p><hr><h4 id="_1-继承与实现" tabindex="-1"><strong>1. 继承与实现</strong> <a class="header-anchor" href="#_1-继承与实现" aria-hidden="true">#</a></h4><ul><li><p><strong>抽象类</strong>：</p><ul><li>子类通过 <code>extends</code> <strong>继承</strong>，<strong>单继承</strong>（Java不支持多继承）。</li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Animal</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*...*/</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Dog</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Animal</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*...*/</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong>接口</strong>：</p><ul><li>类通过 <code>implements</code> <strong>实现</strong>，<strong>支持多实现</strong>。</li><li>接口可通过 <code>extends</code> <strong>继承其他接口</strong>（支持多继承）。</li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Flyable</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">fly</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Swimmable</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">swim</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Duck</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Flyable</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Swimmable</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*...*/</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 多实现</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><hr><h4 id="_2-构造方法" tabindex="-1"><strong>2. 构造方法</strong> <a class="header-anchor" href="#_2-构造方法" aria-hidden="true">#</a></h4><ul><li><p><strong>抽象类</strong>：</p><ul><li><strong>可以包含构造方法</strong>（用于初始化成员变量）。</li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Shape</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> color</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Shape</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">color</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">color </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> color</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 构造方法</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong>接口</strong>：</p><ul><li><strong>不允许有构造方法</strong>（不能被实例化）。</li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Usb</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 不能有构造方法 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><hr><h4 id="_3-成员变量" tabindex="-1"><strong>3. 成员变量</strong> <a class="header-anchor" href="#_3-成员变量" aria-hidden="true">#</a></h4><ul><li><p><strong>抽象类</strong>：</p><ul><li>可以包含<strong>任意类型成员变量</strong>（<code>private</code>/<code>protected</code>/<code>public</code>）。</li><li>变量可以是<strong>非静态</strong>、<strong>非final</strong>的。</li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Animal</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">protected</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> age</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 非final变量</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong>接口</strong>：</p><ul><li>变量<strong>默认是 <code>public static final</code></strong>（常量）。</li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Constants</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> DEFAULT_NAME </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">UNKNOWN</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 等同于 public static final</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><hr><h4 id="_4-方法实现" tabindex="-1"><strong>4. 方法实现</strong> <a class="header-anchor" href="#_4-方法实现" aria-hidden="true">#</a></h4><ul><li><p><strong>抽象类</strong>：</p><ul><li>可以包含： <ul><li><strong>抽象方法</strong>（无实现）。</li><li><strong>具体方法</strong>（有实现）。</li><li><strong>静态方法</strong>。</li><li><strong>private方法</strong>（Java 9+）。</li></ul></li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Vehicle</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 抽象方法</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">stop</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">           </span><span style="color:#676E95;font-style:italic;">// 具体方法</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Stopped.</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong>接口</strong>：</p><ul><li><strong>Java 8前</strong>：只能有抽象方法。</li><li><strong>Java 8+</strong>： <ul><li><strong>默认方法</strong>（<code>default</code>修饰，提供默认实现）。</li><li><strong>静态方法</strong>（有实现）。</li><li><strong>私有方法</strong>（Java 9+）。</li></ul></li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Logger</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">log</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">msg</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">          </span><span style="color:#676E95;font-style:italic;">// 抽象方法</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">logError</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">msg</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 默认方法</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ERROR: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> msg</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getVersion</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">   </span><span style="color:#676E95;font-style:italic;">// 静态方法</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1.0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><hr><h4 id="_5-设计目的" tabindex="-1"><strong>5. 设计目的</strong> <a class="header-anchor" href="#_5-设计目的" aria-hidden="true">#</a></h4><ul><li><p><strong>抽象类</strong>：</p><ul><li><strong>描述“是什么”（is-a关系）</strong>：聚焦<strong>本质抽象</strong>（如 <code>Animal</code> 是 <code>Dog</code> 的抽象）。</li><li>适合<strong>共享代码逻辑</strong>（子类复用父类的具体方法）。</li></ul></li><li><p><strong>接口</strong>：</p><ul><li><strong>描述“能做什么”（has-a关系）</strong>：聚焦<strong>行为抽象</strong>（如 <code>Flyable</code> 定义飞行能力）。</li><li>实现<strong>解耦</strong>与<strong>多态扩展</strong>，避免单继承限制。</li></ul></li></ul><hr><h4 id="_6-实际应用场景" tabindex="-1"><strong>6. 实际应用场景</strong> <a class="header-anchor" href="#_6-实际应用场景" aria-hidden="true">#</a></h4><ul><li><p><strong>使用抽象类</strong>：</p><ul><li>需要定义<strong>部分具体实现</strong>（如模板方法模式）。</li><li>多个类有<strong>共享状态或代码</strong>（如 <code>GameCharacter</code> 抽象类包含公共的 <code>health</code> 属性和 <code>render()</code> 方法）。</li></ul></li><li><p><strong>使用接口</strong>：</p><ul><li><strong>定义行为契约</strong>（如 <code>Comparable&lt;T&gt;</code> 实现对象比较）。</li><li><strong>实现多态扩展</strong>（如 <code>List</code> 接口有 <code>ArrayList</code>/<code>LinkedList</code> 等不同实现）。</li><li><strong>解决多重继承问题</strong>（类可实现多个接口）。</li></ul></li></ul><hr><h4 id="总结对比表-1" tabindex="-1"><strong>总结对比表</strong> <a class="header-anchor" href="#总结对比表-1" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>特性</strong></th><th><strong>抽象类</strong></th><th><strong>接口</strong></th></tr></thead><tbody><tr><td>继承方式</td><td><code>extends</code>（单继承）</td><td><code>implements</code>（多实现）</td></tr><tr><td>构造方法</td><td>✅ 有</td><td>❌ 无</td></tr><tr><td>成员变量</td><td>✅ 任意类型</td><td>❌ 只能是 <code>public static final</code> 常量</td></tr><tr><td>方法实现</td><td>✅ 可含具体方法、抽象方法</td><td>✅ Java 8+ 支持 <code>default</code>/静态方法</td></tr><tr><td>多继承</td><td>❌ Java不支持</td><td>✅ 接口可多继承其他接口</td></tr><tr><td>设计目标</td><td><strong>代码复用 + 部分抽象</strong></td><td><strong>行为抽象 + 解耦</strong></td></tr><tr><td>关系</td><td>子类是父类的具体类型（<strong>is-a</strong>）</td><td>实现类具有某种能力（<strong>like-a</strong>）</td></tr></tbody></table><hr><h4 id="何时选择" tabindex="-1"><strong>何时选择？</strong> <a class="header-anchor" href="#何时选择" aria-hidden="true">#</a></h4><ul><li><p><strong>优先选接口</strong>： 需要定义行为契约、实现多态解耦，或类已有父类但需扩展能力（如 <code>Dog extends Animal implements GuardDog</code>）。</p></li><li><p><strong>选抽象类</strong>： 多个类需复用公共代码/状态，且逻辑是紧密相关的同一类实体（如不同 <code>PaymentMethod</code> 共享支付验证逻辑）。</p></li></ul><blockquote><p>💡 <strong>行业实践</strong>： 现代Java开发中，接口更常用（尤其是配合<code>default</code>方法），仅在需要共享代码或状态时使用抽象类。</p></blockquote><hr><h2 id="java中谈谈你知道的设计模式" tabindex="-1">java中谈谈你知道的设计模式？ <a class="header-anchor" href="#java中谈谈你知道的设计模式" aria-hidden="true">#</a></h2><h3 id="java中的设计模式-程序员的必修课" tabindex="-1">Java中的设计模式：程序员的必修课 <a class="header-anchor" href="#java中的设计模式-程序员的必修课" aria-hidden="true">#</a></h3><p>在Java开发中，设计模式（Design Pattern）是经过反复实践、被多数人知晓、并经过分类编目的优秀代码设计经验的总结。它并非一种具体的技术或代码，而是一种在特定情境下解决常见问题的通用、可复用的解决方案。熟练掌握和运用设计模式，可以显著提升代码的可重用性、可读性、可维护性和健壮性，是衡量一位程序员内功是否深厚的重要指标。</p><p>这些模式的“圣经”通常指的是由Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides四位作者（被称为“四人帮”，Gang of Four，简称GoF）合著的《设计模式：可复用面向对象软件的基础》一书，书中详细描述了23种经典的设计模式。</p><p>这些设计模式通常被分为三大类：<strong>创建型（Creational）</strong>、<strong>结构型（Structural）</strong> 和 <strong>行为型（Behavioral）</strong>。</p><hr><h4 id="一、-创建型模式-creational-patterns" tabindex="-1">一、 创建型模式 (Creational Patterns) <a class="header-anchor" href="#一、-创建型模式-creational-patterns" aria-hidden="true">#</a></h4><p>创建型模式的核心在于<strong>对象的创建</strong>，它们将对象的创建和使用过程解耦，使得系统在创建对象时能有更大的灵活性。</p><h5 id="_1-单例模式-singleton" tabindex="-1">1. 单例模式 (Singleton) <a class="header-anchor" href="#_1-单例模式-singleton" aria-hidden="true">#</a></h5><p><strong>核心思想：</strong> 保证一个类只有一个实例，并提供一个全局访问点。</p><p><strong>应用场景：</strong> 当系统中某个类只需要一个实例时，例如线程池、缓存、日志对象、数据库连接池等。</p><p><strong>实现方式：</strong></p><ul><li><p><strong>饿汉式 (Eager Initialization):</strong> 类加载时就立即创建实例，线程安全，但可能造成资源浪费。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Singleton</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Singleton</span><span style="color:#A6ACCD;"> INSTANCE </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Singleton</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Singleton</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Singleton</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getInstance</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> INSTANCE</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>懒汉式 (Lazy Initialization):</strong> 第一次调用<code>getInstance()</code>时才创建实例。需要处理多线程同步问题。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Singleton</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">volatile</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Singleton</span><span style="color:#A6ACCD;"> instance</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// volatile保证可见性</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Singleton</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Singleton</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getInstance</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">instance </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Singleton</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">instance </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                    instance </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Singleton</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> instance</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><em>上述为双重检查锁定（Double-Checked Locking）实现，是懒汉式中推荐的写法。</em></p></li></ul><h5 id="_2-工厂方法模式-factory-method" tabindex="-1">2. 工厂方法模式 (Factory Method) <a class="header-anchor" href="#_2-工厂方法模式-factory-method" aria-hidden="true">#</a></h5><p><strong>核心思想：</strong> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p><p><strong>应用场景：</strong> 当一个类不知道它所需要的对象的类时，或者当一个类希望由它的子类来指定它所创建的对象时。例如，Java中的<code>java.util.Calendar#getInstance()</code>。</p><p><strong>结构：</strong></p><ul><li><strong>Product (产品接口):</strong> 定义了工厂方法所创建的对象的接口。</li><li><strong>ConcreteProduct (具体产品):</strong> 实现Product接口。</li><li><strong>Factory (工厂接口):</strong> 声明工厂方法，该方法返回一个Product类型的对象。</li><li><strong>ConcreteFactory (具体工厂):</strong> 实现Factory接口，覆盖工厂方法以返回一个ConcreteProduct实例。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 产品接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Logger</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">log</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">message</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 具体产品</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FileLogger</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Logger</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">log</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">message</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 写入文件 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">DatabaseLogger</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Logger</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">log</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">message</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 写入数据库 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 工厂接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">LoggerFactory</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Logger</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createLogger</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 具体工厂</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FileLoggerFactory</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">LoggerFactory</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Logger</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createLogger</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">FileLogger</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">DatabaseLoggerFactory</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">LoggerFactory</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Logger</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createLogger</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">DatabaseLogger</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h5 id="_3-抽象工厂模式-abstract-factory" tabindex="-1">3. 抽象工厂模式 (Abstract Factory) <a class="header-anchor" href="#_3-抽象工厂模式-abstract-factory" aria-hidden="true">#</a></h5><p><strong>核心思想：</strong> 提供一个接口，用于创建<strong>一系列相关或相互依赖的对象</strong>，而无需指定它们具体的类。</p><p><strong>应用场景：</strong> 当系统需要独立于其产品的创建、组合和表示时。例如，更换UI主题（一套按钮、文本框等）。</p><p><strong>与工厂方法的区别：</strong> 工厂方法模式针对的是一个产品等级结构，而抽象工厂模式针对的是多个产品等级结构（一个产品族）。</p><hr><h4 id="二、-结构型模式-structural-patterns" tabindex="-1">二、 结构型模式 (Structural Patterns) <a class="header-anchor" href="#二、-结构型模式-structural-patterns" aria-hidden="true">#</a></h4><p>结构型模式关注<strong>类和对象的组合</strong>，通过继承、组合等方式形成更大的结构，以适应更复杂的业务需求。</p><h5 id="_1-适配器模式-adapter" tabindex="-1">1. 适配器模式 (Adapter) <a class="header-anchor" href="#_1-适配器模式-adapter" aria-hidden="true">#</a></h5><p><strong>核心思想：</strong> 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>应用场景：</strong> 在系统中使用一个已经存在的类，而它的接口不符合系统的需要时。例如，<code>java.io.InputStreamReader</code> 将 <code>InputStream</code> (字节流) 适配成 <code>Reader</code> (字符流)。</p><p><strong>实现方式：</strong></p><ul><li><strong>类适配器：</strong> 通过继承实现。</li><li><strong>对象适配器：</strong> 通过组合（持有被适配对象的引用）实现，更为常用和灵活。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 目标接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Target</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">request</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 被适配的类</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Adaptee</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">specificRequest</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">被适配类的特殊请求。</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 对象适配器</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Adapter</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Target</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Adaptee</span><span style="color:#A6ACCD;"> adaptee</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Adapter</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Adaptee</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">adaptee</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">adaptee </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> adaptee</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">request</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        adaptee</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">specificRequest</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h5 id="_2-装饰器模式-decorator" tabindex="-1">2. 装饰器模式 (Decorator) <a class="header-anchor" href="#_2-装饰器模式-decorator" aria-hidden="true">#</a></h5><p><strong>核心思想：</strong> 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p><strong>应用场景：</strong> 需要在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。例如，Java IO中的各种输入输出流，如 <code>BufferedInputStream</code> 装饰了 <code>FileInputStream</code> 增加了缓冲功能。</p><p><strong>结构：</strong></p><ul><li><strong>Component (组件接口):</strong> 定义一个对象接口。</li><li><strong>ConcreteComponent (具体组件):</strong> 定义了一个具体的对象，也可以给这个对象添加一些职责。</li><li><strong>Decorator (装饰器):</strong> 持有一个Component对象的引用，并定义一个与Component接口一致的接口。</li><li><strong>ConcreteDecorator (具体装饰器):</strong> 负责给组件对象添加职责。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 组件接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Coffee</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">double</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getCost</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getDescription</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 具体组件</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SimpleCoffee</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Coffee</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">double</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getCost</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getDescription</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">简单咖啡</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 装饰器</span></span>
<span class="line"><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">CoffeeDecorator</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Coffee</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">protected</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Coffee</span><span style="color:#A6ACCD;"> decoratedCoffee</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">CoffeeDecorator</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Coffee</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">coffee</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">decoratedCoffee </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> coffee</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">double</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getCost</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> decoratedCoffee</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getCost</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getDescription</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> decoratedCoffee</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getDescription</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 具体装饰器</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">WithMilk</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">CoffeeDecorator</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">WithMilk</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Coffee</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">c</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> super</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">c</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">double</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getCost</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> super</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getCost</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getDescription</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> super</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getDescription</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">, 加牛奶</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h5 id="_3-代理模式-proxy" tabindex="-1">3. 代理模式 (Proxy) <a class="header-anchor" href="#_3-代理模式-proxy" aria-hidden="true">#</a></h5><p><strong>核心思想：</strong> 为其他对象提供一种代理以控制对这个对象的访问。</p><p><strong>应用场景：</strong> 当需要控制对一个对象的访问时，可以增加一些额外的处理，如权限控制、懒加载、日志记录等。例如，Spring AOP的实现就大量用到了代理模式。</p><p><strong>分类：</strong></p><ul><li><strong>静态代理：</strong> 代理类和被代理类在编译期就确定下来。</li><li><strong>动态代理：</strong> 在运行时动态生成代理类。Java中主要通过 <code>java.lang.reflect.Proxy</code> (基于接口) 和 CGLIB (基于子类) 实现。</li></ul><hr><h4 id="三、-行为型模式-behavioral-patterns" tabindex="-1">三、 行为型模式 (Behavioral Patterns) <a class="header-anchor" href="#三、-行为型模式-behavioral-patterns" aria-hidden="true">#</a></h4><p>行为型模式关注<strong>对象之间的通信和职责分配</strong>，旨在使对象之间的协作更加灵活、高效。</p><h5 id="_1-观察者模式-observer" tabindex="-1">1. 观察者模式 (Observer) <a class="header-anchor" href="#_1-观察者模式-observer" aria-hidden="true">#</a></h5><p><strong>核心思想：</strong> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知并自动更新。</p><p><strong>应用场景：</strong> 当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象有待改变时。例如，GUI中的事件监听（<code>ActionListener</code>），消息队列的发布/订阅模型。</p><p><strong>结构：</strong></p><ul><li><strong>Subject (主题/被观察者):</strong> 维护了一个观察者列表，提供了添加、删除和通知观察者的方法。</li><li><strong>Observer (观察者):</strong> 定义了一个更新接口，当被观察者状态改变时，该接口被调用。</li><li><strong>ConcreteSubject (具体主题):</strong> 实现了主题接口，并在自身状态改变时通知所有注册的观察者。</li><li><strong>ConcreteObserver (具体观察者):</strong> 实现了观察者接口，以在接收到通知时更新自身状态。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 观察者接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Observer</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">update</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">message</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 被观察者接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Subject</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">registerObserver</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Observer</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">o</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">removeObserver</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Observer</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">o</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">notifyObservers</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 具体被观察者</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">WeatherStation</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Subject</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">List</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Observer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> observers </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ArrayList</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> weather</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">setWeather</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">newWeather</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">weather </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> newWeather</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">notifyObservers</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// ... 实现 register, remove, notify ...</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">notifyObservers</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Observer</span><span style="color:#A6ACCD;"> observer </span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> observers</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            observer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">update</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">weather</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h5 id="_2-策略模式-strategy" tabindex="-1">2. 策略模式 (Strategy) <a class="header-anchor" href="#_2-策略模式-strategy" aria-hidden="true">#</a></h5><p><strong>核心思想：</strong> 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p><p><strong>应用场景：</strong> 如果在一个系统中有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。例如，电商网站的支付方式（支付宝、微信支付、银行卡支付）。</p><p><strong>结构：</strong></p><ul><li><strong>Context (上下文):</strong> 维护一个对Strategy对象的引用。</li><li><strong>Strategy (策略接口):</strong> 定义所有支持的算法的公共接口。</li><li><strong>ConcreteStrategy (具体策略):</strong> 封装了具体的算法或行为。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 策略接口</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">PaymentStrategy</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">pay</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">amount</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 具体策略</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">AlipayStrategy</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">PaymentStrategy</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">pay</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">amount</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 支付宝支付逻辑 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">WechatPayStrategy</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">implements</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">PaymentStrategy</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">pay</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">amount</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 微信支付逻辑 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 上下文</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ShoppingCart</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">PaymentStrategy</span><span style="color:#A6ACCD;"> paymentStrategy</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">setPaymentStrategy</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">PaymentStrategy</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">paymentStrategy</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">paymentStrategy </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> paymentStrategy</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">checkout</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">amount</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        paymentStrategy</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pay</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">amount</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h5 id="_3-模板方法模式-template-method" tabindex="-1">3. 模板方法模式 (Template Method) <a class="header-anchor" href="#_3-模板方法模式-template-method" aria-hidden="true">#</a></h5><p><strong>核心思想：</strong> 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>应用场景：</strong> 当多个子类有共有的方法，并且这些方法逻辑相同时，可以将其抽取到父类的模板方法中。例如，<code>java.io.InputStream</code> 中的 <code>read(byte b[], int off, int len)</code> 方法就是一个模板方法。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Game</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">initialize</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">startPlay</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">abstract</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">endPlay</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 模板方法，被final修饰，防止被重写</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">play</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">initialize</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">startPlay</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">endPlay</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Cricket</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Game</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">initialize</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">板球游戏初始化！</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">startPlay</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">板球游戏开始！</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">endPlay</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">板球游戏结束！</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h4 id="总结-5" tabindex="-1">总结 <a class="header-anchor" href="#总结-5" aria-hidden="true">#</a></h4><p>设计模式是前人智慧的结晶，是解决软件设计问题的“良方”。学习设计模式的重点在于理解其背后的设计原则（如单一职责原则、开闭原则、里氏替换原则等），并能够在合适的场景下灵活运用。一开始可能会觉得生搬硬套，但随着项目经验的积累，你会逐渐体会到设计模式带来的巨大好处，并能够写出更加优雅、健壮和易于维护的Java代码。</p><hr><h2 id="java中synchronized和reentrantlock有什么区别" tabindex="-1">java中synchronized和ReentrantLock有什么区别？ <a class="header-anchor" href="#java中synchronized和reentrantlock有什么区别" aria-hidden="true">#</a></h2><p>在Java中，<code>synchronized</code>关键字和<code>ReentrantLock</code>类都用于实现线程同步，解决多线程竞争问题。它们的核心区别如下：</p><h4 id="_1-设计层面" tabindex="-1">1. <strong>设计层面</strong> <a class="header-anchor" href="#_1-设计层面" aria-hidden="true">#</a></h4><ul><li><strong><code>synchronized</code></strong> Java语言级关键字，隐式锁机制，用法简单（JVM管理锁的获取与释放）。</li><li><strong><code>ReentrantLock</code></strong> JDK提供的显式锁类（<code>java.util.concurrent.locks</code>包），需手动加锁/释放锁。</li></ul><h4 id="_2-锁的公平性" tabindex="-1">2. <strong>锁的公平性</strong> <a class="header-anchor" href="#_2-锁的公平性" aria-hidden="true">#</a></h4><ul><li><strong><code>synchronized</code></strong> 仅支持<strong>非公平锁</strong>（竞争线程随机获取锁）。</li><li><strong><code>ReentrantLock</code></strong> 可自由选择：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 公平锁（按等待时间分配）</span></span>
<span class="line"><span style="color:#C792EA;">ReentrantLock</span><span style="color:#A6ACCD;"> fairLock </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ReentrantLock</span><span style="color:#89DDFF;">(true);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 非公平锁（默认）</span></span>
<span class="line"><span style="color:#C792EA;">ReentrantLock</span><span style="color:#A6ACCD;"> unfairLock </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ReentrantLock</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span></code></pre></div></li></ul><h4 id="_3-锁获取的灵活性" tabindex="-1">3. <strong>锁获取的灵活性</strong> <a class="header-anchor" href="#_3-锁获取的灵活性" aria-hidden="true">#</a></h4><ul><li><strong><code>synchronized</code></strong> 线程若未获锁，将<strong>一直阻塞</strong>直到成功，无法中途取消。</li><li><strong><code>ReentrantLock</code></strong> 提供灵活控制： <ul><li><strong>尝试锁</strong>：失败立即返回<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">tryLock</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 非阻塞尝试</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 业务逻辑 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unlock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><strong>超时锁</strong>：指定等待时间<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">tryLock</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> TimeUnit</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">SECONDS</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 最大等待5秒</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 业务逻辑 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unlock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><strong>可中断锁</strong>：等待中响应中断<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">lockInterruptibly</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 阻塞时若被中断，抛出InterruptedException</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><h4 id="_4-条件变量-condition" tabindex="-1">4. <strong>条件变量（Condition）</strong> <a class="header-anchor" href="#_4-条件变量-condition" aria-hidden="true">#</a></h4><ul><li><strong><code>synchronized</code></strong> 仅通过<code>wait()</code>/<code>notifyAll()</code>实现一个条件队列，无法细化等待条件。</li><li><strong><code>ReentrantLock</code></strong> 支持<strong>多个条件队列</strong>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Condition</span><span style="color:#A6ACCD;"> notFull </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newCondition</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 条件1：队列未满</span></span>
<span class="line"><span style="color:#C792EA;">Condition</span><span style="color:#A6ACCD;"> notEmpty </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newCondition</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 条件2：队列非空</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 生产线程</span></span>
<span class="line"><span style="color:#A6ACCD;">lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">lock</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isFull</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> notFull</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">await</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 等待&quot;未满&quot;条件</span></span>
<span class="line"><span style="color:#A6ACCD;">  queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">  notEmpty</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">signal</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 唤醒&quot;非空&quot;等待者</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unlock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 消费线程</span></span>
<span class="line"><span style="color:#A6ACCD;">lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">lock</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isEmpty</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> notEmpty</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">await</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 等待&quot;非空&quot;条件</span></span>
<span class="line"><span style="color:#A6ACCD;">  queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">take</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">  notFull</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">signal</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 唤醒&quot;未满&quot;等待者</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unlock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul><h4 id="_5-锁的实现机制" tabindex="-1">5. <strong>锁的实现机制</strong> <a class="header-anchor" href="#_5-锁的实现机制" aria-hidden="true">#</a></h4><ul><li><strong><code>synchronized</code></strong> 基于JVM底层优化，如： <ul><li><strong>偏向锁</strong>：无竞争时减少开销</li><li><strong>轻量级锁</strong>：短时竞争通过CAS解决</li><li><strong>锁消除/粗化</strong>：编译器优化</li></ul></li><li><strong><code>ReentrantLock</code></strong> 基于AQS（AbstractQueuedSynchronizer）实现，纯Java代码控制同步队列。</li></ul><h4 id="_6-性能差异" tabindex="-1">6. <strong>性能差异</strong> <a class="header-anchor" href="#_6-性能差异" aria-hidden="true">#</a></h4><ul><li>早期版本（如Java 5）中，<code>ReentrantLock</code>性能显著优于<code>synchronized</code>。</li><li><strong>Java 6+</strong>：JVM大幅优化<code>synchronized</code>后，两者在无竞争场景下性能相近；高竞争时<code>ReentrantLock</code>仍有优势。</li></ul><h4 id="_7-使用场景推荐" tabindex="-1">7. <strong>使用场景推荐</strong> <a class="header-anchor" href="#_7-使用场景推荐" aria-hidden="true">#</a></h4><table><thead><tr><th>场景</th><th>推荐方式</th></tr></thead><tbody><tr><td>简单同步需求</td><td>✅ <code>synchronized</code></td></tr><tr><td>需要公平锁</td><td>✅ <code>ReentrantLock</code></td></tr><tr><td>细粒度条件控制（多个等待条件）</td><td>✅ <code>ReentrantLock</code></td></tr><tr><td>尝试锁/超时锁/可中断锁需求</td><td>✅ <code>ReentrantLock</code></td></tr><tr><td>避免锁泄漏</td><td>✅ <code>synchronized</code>（自动释放）</td></tr></tbody></table><h4 id="示例代码对比" tabindex="-1">示例代码对比 <a class="header-anchor" href="#示例代码对比" aria-hidden="true">#</a></h4><p><code>synchronized</code>实现：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SyncCounter</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> count</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        count</span><span style="color:#89DDFF;">++;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 自动加锁/释放锁</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><code>ReentrantLock</code>实现：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">LockCounter</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ReentrantLock</span><span style="color:#A6ACCD;"> lock </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ReentrantLock</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> count</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">lock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 显式加锁</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            count</span><span style="color:#89DDFF;">++;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unlock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 必须finally释放！</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h4 id="总结-6" tabindex="-1">总结 <a class="header-anchor" href="#总结-6" aria-hidden="true">#</a></h4><table><thead><tr><th>特性</th><th><code>synchronized</code></th><th><code>ReentrantLock</code></th></tr></thead><tbody><tr><td>锁类型</td><td>隐式锁</td><td>显式锁</td></tr><tr><td>公平性</td><td>仅非公平</td><td>支持公平/非公平（默认非公平）</td></tr><tr><td>条件变量</td><td>单一条件</td><td>多个条件（<code>newCondition()</code>）</td></tr><tr><td>尝试锁/超时锁</td><td>❌ 不支持</td><td>✅ <code>tryLock()</code>, <code>tryLock(time)</code></td></tr><tr><td>可中断锁</td><td>❌ 阻塞不可中断</td><td>✅ <code>lockInterruptibly()</code></td></tr><tr><td>锁释放</td><td>自动释放（方法/块结束）</td><td>需手动<code>unlock()</code>（易遗漏！）</td></tr><tr><td>代码复杂度</td><td>简洁</td><td>需模板代码（<code>try-finally</code>）</td></tr><tr><td>锁优化机制</td><td>✅ JVM内置优化（偏向锁等）</td><td>❌ 纯Java实现</td></tr></tbody></table><p><strong>优先选择<code>synchronized</code></strong>：简洁安全，适合大多数同步场景。 <strong>选择<code>ReentrantLock</code></strong>：当需要公平锁、条件变量、锁中断等高级特性时使用。</p><hr><h2 id="synchronized底层是如何实现的-什么是锁的升级和降级" tabindex="-1">synchronized底层是如何实现的？什么是锁的升级和降级 <a class="header-anchor" href="#synchronized底层是如何实现的-什么是锁的升级和降级" aria-hidden="true">#</a></h2><h2 id="synchronized底层实现与锁升级机制" tabindex="-1"><code>synchronized</code>底层实现与锁升级机制 <a class="header-anchor" href="#synchronized底层实现与锁升级机制" aria-hidden="true">#</a></h2><h3 id="synchronized底层实现" tabindex="-1"><code>synchronized</code>底层实现 <a class="header-anchor" href="#synchronized底层实现" aria-hidden="true">#</a></h3><p><code>synchronized</code>关键字的底层实现涉及JVM的内置机制和对象的内存布局：</p><ol><li><strong>对象头机制</strong>： <ul><li>每个Java对象在堆中存储时都有一个对象头，其中包含Mark Word（标记字）</li><li>Mark Word存储对象的运行时信息：哈希码、GC分代年龄、锁标志位等</li><li>Mark Word长度在32位JVM中是32位，64位JVM中是64位</li></ul></li></ol><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Java对象在内存中的布局</span></span>
<span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Instance</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">对象实例</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Mark</span><span style="color:#A6ACCD;"> Word</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// 锁信息的核心存储区</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Class</span><span style="color:#A6ACCD;"> Pointer </span><span style="color:#676E95;font-style:italic;">// 指向类元数据的指针</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Instance</span><span style="color:#A6ACCD;"> Data </span><span style="color:#676E95;font-style:italic;">// 对象实际数据</span></span>
<span class="line"><span style="color:#A6ACCD;">    Padding       </span><span style="color:#676E95;font-style:italic;">// 对齐填充</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ol start="2"><li><p><strong>Mark Word结构</strong>：</p><ul><li>不同锁状态下的Mark Word结构不同：</li></ul><table><thead><tr><th>锁状态</th><th>存储内容</th><th>标志位</th></tr></thead><tbody><tr><td>无锁</td><td>对象hashCode + 分代年龄</td><td>01</td></tr><tr><td>偏向锁</td><td>偏向线程ID + Epoch + 分代年龄</td><td>01</td></tr><tr><td>轻量级锁</td><td>指向栈中锁记录的指针</td><td>00</td></tr><tr><td>重量级锁</td><td>指向互斥量（monitor）的指针</td><td>10</td></tr><tr><td>GC标记</td><td>空</td><td>11</td></tr></tbody></table></li><li><p><strong>Monitor对象</strong>：</p><ul><li>JVM为每个对象关联一个ObjectMonitor对象（监视器）</li><li>结构关键字段：<div class="language-c++"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">ObjectMonitor {</span></span>
<span class="line"><span style="color:#A6ACCD;">    _header;      // Mark Word的存储位置</span></span>
<span class="line"><span style="color:#A6ACCD;">    _owner;       // 持有锁的线程</span></span>
<span class="line"><span style="color:#A6ACCD;">    _count;       // 锁的重入次数</span></span>
<span class="line"><span style="color:#A6ACCD;">    _WaitSet;     // 等待队列（调用wait()的线程）</span></span>
<span class="line"><span style="color:#A6ACCD;">    _EntryList;   // 锁阻塞队列</span></span>
<span class="line"><span style="color:#A6ACCD;">    _cxq;         // 竞争队列</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div></li><li>当线程尝试获取锁时： <ol><li>通过CAS操作修改Mark Word</li><li>成功则获取锁，失败则进入阻塞队列</li></ol></li></ul></li></ol><h3 id="锁的升级过程-锁膨胀" tabindex="-1">锁的升级过程 (锁膨胀) <a class="header-anchor" href="#锁的升级过程-锁膨胀" aria-hidden="true">#</a></h3><p>锁升级是JVM针对不同并发场景进行的优化，共有4个阶段：</p><div class="language-mermaid"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">graph</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">TD</span></span>
<span class="line"><span style="color:#A6ACCD;">    A</span><span style="color:#89DDFF;font-style:italic;">[</span><span style="color:#C3E88D;">无锁状态</span><span style="color:#89DDFF;font-style:italic;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">--&gt;|</span><span style="color:#C3E88D;">首次访问</span><span style="color:#89DDFF;font-style:italic;">|</span><span style="color:#A6ACCD;"> B</span><span style="color:#89DDFF;font-style:italic;">[</span><span style="color:#C3E88D;">偏向锁</span><span style="color:#89DDFF;font-style:italic;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">    B </span><span style="color:#89DDFF;font-style:italic;">--&gt;|</span><span style="color:#C3E88D;">竞争出现</span><span style="color:#89DDFF;font-style:italic;">|</span><span style="color:#A6ACCD;"> C</span><span style="color:#89DDFF;font-style:italic;">[</span><span style="color:#C3E88D;">轻量级锁</span><span style="color:#89DDFF;font-style:italic;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">    C </span><span style="color:#89DDFF;font-style:italic;">--&gt;|</span><span style="color:#C3E88D;">自旋失败</span><span style="color:#89DDFF;font-style:italic;">|</span><span style="color:#A6ACCD;"> D</span><span style="color:#89DDFF;font-style:italic;">[</span><span style="color:#C3E88D;">重量级锁</span><span style="color:#89DDFF;font-style:italic;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">    D </span><span style="color:#89DDFF;font-style:italic;">--&gt;|</span><span style="color:#C3E88D;">锁释放</span><span style="color:#89DDFF;font-style:italic;">|</span><span style="color:#A6ACCD;"> A</span></span>
<span class="line"></span></code></pre></div><h4 id="_1-偏向锁-biased-locking" tabindex="-1">1. 偏向锁 (Biased Locking) <a class="header-anchor" href="#_1-偏向锁-biased-locking" aria-hidden="true">#</a></h4><ul><li><strong>目的</strong>：无竞争环境优化</li><li><strong>原理</strong>： <ul><li>当线程第一次访问同步块时，在对象头存储偏向线程ID</li><li>后续该线程进入同步块无需任何同步操作（只需检查线程ID）</li></ul></li><li><strong>触发场景</strong>：单线程重复访问同步块</li><li><strong>优势</strong>：加锁/解锁无任何代价</li><li><strong>图示实现</strong>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">对象锁状态 </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> 无锁 </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> 支持偏向锁</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    使用CAS记录线程ID到Mark </span><span style="color:#C792EA;">Word</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">成功</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        对象进入偏向锁状态</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul><h4 id="_2-轻量级锁-lightweight-locking" tabindex="-1">2. 轻量级锁 (Lightweight Locking) <a class="header-anchor" href="#_2-轻量级锁-lightweight-locking" aria-hidden="true">#</a></h4><ul><li><strong>目的</strong>：多线程交替执行优化</li><li><strong>原理</strong>： <ol><li>在栈帧中创建Lock Record</li><li>将对象头的Mark Word复制到锁记录（Displaced Mark Word）</li><li>尝试用CAS将对象头指向锁记录</li><li>成功则获锁，失败则锁膨胀</li></ol></li><li><strong>触发场景</strong>：多线程交替访问（非竞争）</li><li><strong>优势</strong>：避免线程阻塞（使用自旋）</li><li><strong>升级条件</strong>： <ul><li>CAS失败（表示有竞争）</li><li>自旋超过阈值（自适应自旋）</li></ul></li></ul><h4 id="_3-重量级锁-heavyweight-locking" tabindex="-1">3. 重量级锁 (Heavyweight Locking) <a class="header-anchor" href="#_3-重量级锁-heavyweight-locking" aria-hidden="true">#</a></h4><ul><li><strong>最终状态</strong>：真正OS级锁</li><li><strong>实现机制</strong>： <ul><li>通过操作系统的互斥量(mutex)实现</li><li>未获取锁的线程进入阻塞队列（上下文切换）</li></ul></li><li><strong>触发方式</strong>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">lock</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(!</span><span style="color:#A6ACCD;">尝试轻量级加锁</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        膨胀为重量级锁</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        阻塞当前线程</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><strong>开销</strong>：涉及上下文切换（10-100微秒级开销）</li></ul><h4 id="_4-锁降级" tabindex="-1">4. 锁降级？ <a class="header-anchor" href="#_4-锁降级" aria-hidden="true">#</a></h4><ul><li><strong>Java标准锁体系不支持主动降级</strong></li><li>特殊情况： <ul><li>GC过程扫描发现无锁竞争，可能重置为无锁状态</li><li>偏向锁超时（默认15秒）自动重置</li><li>JVM安全点中清理</li></ul></li><li><strong>重要</strong>：锁升级是<strong>单向过程</strong>（不可逆，除非完全释放后重新获取）</li></ul><h3 id="性能优化特点" tabindex="-1">性能优化特点 <a class="header-anchor" href="#性能优化特点" aria-hidden="true">#</a></h3><ol><li><p><strong>自适应自旋</strong>：</p><ul><li>JVM动态调整自旋次数（根据历史成功率）</li><li>避免固定自旋造成的CPU浪费</li></ul></li><li><p><strong>锁消除</strong>：</p><ul><li>通过逃逸分析如果发现对象不可能共享</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">method</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> lock </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 局部对象</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">synchronized</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lock</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">        </span><span style="color:#676E95;font-style:italic;">// 同步被消除</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 操作</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>锁粗化</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 优化前</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">synchronized</span><span style="color:#89DDFF;">(this)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 操作</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 优化后</span></span>
<span class="line"><span style="color:#C792EA;">synchronized</span><span style="color:#89DDFF;">(this)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 操作</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ol><h3 id="实践建议" tabindex="-1">实践建议 <a class="header-anchor" href="#实践建议" aria-hidden="true">#</a></h3><ol><li><p><strong>优先使用<code>synchronized</code></strong></p><ul><li>简单场景选择<code>synchronized</code>（自动维护锁升级）</li><li>Java 6+版本性能与<code>ReentrantLock</code>相当</li></ul></li><li><p><strong>关注同步范围</strong></p><ul><li>最小化同步代码块</li><li>避免在循环内加锁</li></ul></li><li><p><strong>选择合适锁对象</strong></p><ul><li>避免使用String或基础类型包装类</li><li>最好创建专用的锁对象：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> lock </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ol><p>锁升级机制充分体现了Java对&quot;渐进式优化&quot;理念的贯彻，让开发者享受&quot;傻瓜式&quot;同步的同时，获得接近手动优化的性能。</p><hr><h2 id="一个线程两次调用start-方法会出现什么情况" tabindex="-1">一个线程两次调用start()方法会出现什么情况 <a class="header-anchor" href="#一个线程两次调用start-方法会出现什么情况" aria-hidden="true">#</a></h2><p>在Java中，一个线程实例<strong>不允许被多次启动</strong>。当你尝试第二次调用同一个线程对象的<code>start()</code>方法时，Java虚拟机会抛出<code>IllegalThreadStateException</code>异常。以下是详细说明：</p><hr><h4 id="_1-线程的生命周期状态" tabindex="-1">1. <strong>线程的生命周期状态</strong> <a class="header-anchor" href="#_1-线程的生命周期状态" aria-hidden="true">#</a></h4><p>Java线程的状态（通过<code>getState()</code>方法查看）包括：</p><ul><li><strong>NEW</strong>：新建状态（尚未调用<code>start()</code>）</li><li><strong>RUNNABLE</strong>：可运行状态（已调用<code>start()</code>）</li><li><strong>TERMINATED</strong>：终止状态（线程执行完毕）</li></ul><p><strong>关键点</strong>：一个线程只能从<strong>NEW状态</strong>进入<strong>RUNNABLE状态</strong>。一旦启动（即第一次调用<code>start()</code>），它的状态就不再是<code>NEW</code>。后续再调用<code>start()</code>会检查线程状态，如果非<code>NEW</code>则抛出异常。</p><hr><h4 id="_2-异常抛出的机制" tabindex="-1">2. <strong>异常抛出的机制</strong> <a class="header-anchor" href="#_2-异常抛出的机制" aria-hidden="true">#</a></h4><p><code>Thread.start()</code>方法的源代码中有明确的检查：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">threadStatus </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 0 代表NEW状态</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">throw</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">IllegalThreadStateException</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// ... 启动线程的实际逻辑</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>当线程状态 <code>threadStatus != 0</code>（即非<code>NEW</code>状态）时，直接抛出异常。</li><li>无论线程当前是<code>RUNNABLE</code>、<code>TERMINATED</code>还是其他状态（如<code>BLOCKED</code>），第二次调用<code>start()</code>均会触发异常。</li></ul><hr><h4 id="_3-示例代码验证" tabindex="-1">3. <strong>示例代码验证</strong> <a class="header-anchor" href="#_3-示例代码验证" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Main</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Thread</span><span style="color:#A6ACCD;"> thread </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Thread</span><span style="color:#89DDFF;">(()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Thread is running...</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">        thread</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 第一次启动成功</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            Thread</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sleep</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">2000</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 等待线程执行结束（进入TERMINATED状态）</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">InterruptedException</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            e</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">printStackTrace</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 第二次尝试启动（失败）</span></span>
<span class="line"><span style="color:#A6ACCD;">        thread</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 抛出IllegalThreadStateException</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><strong>输出</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">Thread is running...</span></span>
<span class="line"><span style="color:#A6ACCD;">Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException</span></span>
<span class="line"><span style="color:#A6ACCD;">    at java.lang.Thread.start(Thread.java:708)</span></span>
<span class="line"><span style="color:#A6ACCD;">    at Main.main(Main.java:13)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><hr><h4 id="_4-常见问题场景" tabindex="-1">4. <strong>常见问题场景</strong> <a class="header-anchor" href="#_4-常见问题场景" aria-hidden="true">#</a></h4><ul><li><strong>重复启动线程对象</strong>：无论线程是否已结束（<code>TERMINATED</code>），只要调用过<code>start()</code>，第二次调用就会失败。</li><li><strong>延迟启动线程</strong>：若线程尚未执行完（仍处于<code>RUNNABLE</code>状态），此时再次调用<code>start()</code>同样触发异常。</li></ul><hr><h4 id="_5-正确做法-重用任务而非线程" tabindex="-1">5. <strong>正确做法：重用任务而非线程</strong> <a class="header-anchor" href="#_5-正确做法-重用任务而非线程" aria-hidden="true">#</a></h4><p>若要多次执行相同任务，应<strong>重用任务对象</strong>而非线程：</p><ul><li>创建一个实现了<code>Runnable</code>的任务对象。</li><li>通过<strong>新线程实例</strong>或<strong>线程池</strong>执行任务：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Runnable</span><span style="color:#A6ACCD;"> task </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Task running</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 每次启动用新线程</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Thread</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">task</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 第一次</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Thread</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">task</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 第二次（允许）</span></span>
<span class="line"></span></code></pre></div></li><li>使用线程池（推荐）：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ExecutorService</span><span style="color:#A6ACCD;"> executor </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Executors</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newFixedThreadPool</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">executor</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">submit</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">task</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 多次提交无问题</span></span>
<span class="line"><span style="color:#A6ACCD;">executor</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">submit</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">task</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h4 id="总结-7" tabindex="-1">总结 <a class="header-anchor" href="#总结-7" aria-hidden="true">#</a></h4><table><thead><tr><th>调用次数</th><th>状态变化</th><th>结果</th></tr></thead><tbody><tr><td>第1次</td><td><code>NEW</code> → <code>RUNNABLE</code></td><td>线程正常启动</td></tr><tr><td>第2次</td><td>任何非<code>NEW</code>状态（如<code>RUNNABLE</code>/<code>TERMINATED</code>）</td><td>抛出<code>IllegalThreadStateException</code></td></tr></tbody></table><p><strong>结论</strong>：一个线程实例只能调用一次<code>start()</code>方法。多次启动的本质问题是违反了线程状态机规则，JVM通过强制抛出异常确保线程生命周期的正确性。</p><hr><h2 id="什么情况下java程序会产生死锁-如何定位-修复" tabindex="-1">什么情况下java程序会产生死锁，如何定位 修复？ <a class="header-anchor" href="#什么情况下java程序会产生死锁-如何定位-修复" aria-hidden="true">#</a></h2><p>在 Java 中，死锁发生在多个线程相互等待对方持有的资源，导致所有线程永久阻塞。以下是产生死锁的条件、定位方法和修复方案：</p><hr><h4 id="死锁产生的必要条件-需同时满足" tabindex="-1"><strong>死锁产生的必要条件（需同时满足）：</strong> <a class="header-anchor" href="#死锁产生的必要条件-需同时满足" aria-hidden="true">#</a></h4><ol><li><strong>互斥使用</strong>：资源一次只能被一个线程持有</li><li><strong>持有并等待</strong>：线程持有资源且不释放，同时等待其他资源</li><li><strong>不可剥夺</strong>：线程持有的资源不能被强制抢占</li><li><strong>循环等待</strong>：线程之间形成环形等待链（如 T1 等待 T2 的资源，T2 等待 T1 的资源）</li></ol><h4 id="常见引发场景" tabindex="-1"><strong>常见引发场景</strong> <a class="header-anchor" href="#常见引发场景" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 经典死锁示例：两个线程以不同顺序获取锁</span></span>
<span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> lockA </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> lockB </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">Thread</span><span style="color:#A6ACCD;"> t1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Thread</span><span style="color:#89DDFF;">(()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockA</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">          </span><span style="color:#676E95;font-style:italic;">// 1. 先获取 lockA</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockB</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 3. 等待 lockB（被t2持有）</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">Thread</span><span style="color:#A6ACCD;"> t2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Thread</span><span style="color:#89DDFF;">(()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockB</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">          </span><span style="color:#676E95;font-style:italic;">// 2. 先获取 lockB</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockA</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 4. 等待 lockA（被t1持有）→ 死锁</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">});</span></span>
<span class="line"><span style="color:#A6ACCD;">t1</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> t2</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">start</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="定位死锁" tabindex="-1"><strong>定位死锁</strong> <a class="header-anchor" href="#定位死锁" aria-hidden="true">#</a></h4><h5 id="_1-jstack-工具-命令行" tabindex="-1"><strong>1. jstack 工具（命令行）</strong> <a class="header-anchor" href="#_1-jstack-工具-命令行" aria-hidden="true">#</a></h5><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">## 1. 查看 Java 进程 PID</span></span>
<span class="line"><span style="color:#FFCB6B;">jps</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">## 2. 分析线程栈</span></span>
<span class="line"><span style="color:#FFCB6B;">jstack</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">PI</span><span style="color:#A6ACCD;">D</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><ul><li>在输出中搜索 <code>deadlock</code>，会明确标注发现的死锁及阻塞线程的堆栈信息</li></ul><h5 id="_2-jconsole-visualvm-图形化工具" tabindex="-1"><strong>2. JConsole / VisualVM（图形化工具）</strong> <a class="header-anchor" href="#_2-jconsole-visualvm-图形化工具" aria-hidden="true">#</a></h5><ul><li>打开工具并连接到目标 JVM</li><li>在&quot;线程&quot;选项卡中检测死锁（会直接标记死锁线程）</li></ul><h5 id="_3-代码检测-threadmxbean" tabindex="-1"><strong>3. 代码检测 ThreadMXBean</strong> <a class="header-anchor" href="#_3-代码检测-threadmxbean" aria-hidden="true">#</a></h5><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ThreadMXBean</span><span style="color:#A6ACCD;"> mxBean </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ManagementFactory</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getThreadMXBean</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#C792EA;">long</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> deadlockedThreads </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> mxBean</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">findDeadlockedThreads</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 返回死锁线程ID</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">deadlockedThreads </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Deadlock detected!</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="修复死锁的策略" tabindex="-1"><strong>修复死锁的策略</strong> <a class="header-anchor" href="#修复死锁的策略" aria-hidden="true">#</a></h4><h5 id="_1-保证锁顺序一致-破坏循环等待" tabindex="-1"><strong>1. 保证锁顺序一致（破坏循环等待）</strong> <a class="header-anchor" href="#_1-保证锁顺序一致-破坏循环等待" aria-hidden="true">#</a></h5><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 解决方案：全局约定获取锁的顺序（如先 lockA 后 lockB）</span></span>
<span class="line"><span style="color:#C792EA;">Thread</span><span style="color:#A6ACCD;"> t2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Thread</span><span style="color:#89DDFF;">(()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockA</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 改为先获取 lockA</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockB</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">});</span></span>
<span class="line"></span></code></pre></div><h5 id="_2-使用-trylock-超时机制-破坏持有等待" tabindex="-1"><strong>2. 使用 tryLock 超时机制（破坏持有等待）</strong> <a class="header-anchor" href="#_2-使用-trylock-超时机制-破坏持有等待" aria-hidden="true">#</a></h5><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Lock</span><span style="color:#A6ACCD;"> lockA </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ReentrantLock</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#C792EA;">Lock</span><span style="color:#A6ACCD;"> lockB </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ReentrantLock</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">Thread</span><span style="color:#A6ACCD;"> t1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Thread</span><span style="color:#89DDFF;">(()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(true)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockA</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">tryLock</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> TimeUnit</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">MILLISECONDS</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">lockB</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">tryLock</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> TimeUnit</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">MILLISECONDS</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/* 操作资源 */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> lockB</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unlock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> lockA</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unlock</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        Thread</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sleep</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 避免活锁</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">});</span></span>
<span class="line"></span></code></pre></div><h5 id="_3-减小锁粒度" tabindex="-1"><strong>3. 减小锁粒度</strong> <a class="header-anchor" href="#_3-减小锁粒度" aria-hidden="true">#</a></h5><ul><li>使用细粒度锁（如 <code>ConcurrentHashMap</code> 分段锁）</li><li>避免在方法上使用 <code>synchronized</code>（改用同步代码块）</li></ul><h5 id="_4-设计无锁结构" tabindex="-1"><strong>4. 设计无锁结构</strong> <a class="header-anchor" href="#_4-设计无锁结构" aria-hidden="true">#</a></h5><ul><li>使用线程安全类：<code>ConcurrentLinkedQueue</code>, <code>AtomicLong</code> 等</li><li>采用 Actor 模型（如 Akka 框架）或消息队列</li></ul><hr><h4 id="预防死锁的最佳实践" tabindex="-1"><strong>预防死锁的最佳实践</strong> <a class="header-anchor" href="#预防死锁的最佳实践" aria-hidden="true">#</a></h4><ol><li><strong>始终按固定顺序获取锁</strong>（如通过资源 ID 排序）</li><li><strong>设置锁超时</strong>：<code>ReentrantLock.tryLock(timeout)</code></li><li><strong>避免嵌套锁</strong>：重构代码减少所需的锁数量</li><li><strong>使用高级并发工具</strong>： <ul><li><code>Semaphore</code> (信号量)</li><li><code>CountDownLatch</code>/<code>CyclicBarrier</code></li><li><code>java.util.concurrent</code> 包中的锁机制</li></ul></li></ol><blockquote><p><strong>关键提示</strong>：死锁是设计问题而非实现细节，应在架构阶段考虑并发安全。通过代码审查和压力测试可提前暴露问题。</p></blockquote><hr><h2 id="java并发包提供了哪些并发工具类" tabindex="-1">Java并发包提供了哪些并发工具类？ <a class="header-anchor" href="#java并发包提供了哪些并发工具类" aria-hidden="true">#</a></h2><p>Java并发包（<code>java.util.concurrent</code>）提供了强大的工具类来简化并发编程，主要分为以下几类：</p><hr><h4 id="一、锁-locks" tabindex="-1">一、<strong>锁（Locks）</strong> <a class="header-anchor" href="#一、锁-locks" aria-hidden="true">#</a></h4><p>解决<code>synchronized</code>的局限性：</p><ol><li><strong><code>ReentrantLock</code></strong><ul><li>可重入互斥锁，支持公平锁/非公平锁。</li><li>示例：替代<code>synchronized</code>，支持<code>tryLock()</code>超时获取锁。</li></ul></li><li><strong><code>ReentrantReadWriteLock</code></strong><ul><li>读写分离锁：读锁共享，写锁互斥，提升读多写少场景性能。</li></ul></li><li><strong><code>StampedLock</code></strong>（Java 8） <ul><li>优化读写锁：支持乐观读（不阻塞写操作），避免写饥饿。</li></ul></li></ol><hr><h4 id="二、原子变量-atomic-classes" tabindex="-1">二、<strong>原子变量（Atomic Classes）</strong> <a class="header-anchor" href="#二、原子变量-atomic-classes" aria-hidden="true">#</a></h4><p>无锁线程安全操作：</p><ul><li><strong>基础类型</strong>：<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code></li><li><strong>引用类型</strong>：<code>AtomicReference</code>、<code>AtomicStampedReference</code>（解决ABA问题）</li><li><strong>数组</strong>：<code>AtomicIntegerArray</code>、<code>AtomicLongArray</code></li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">AtomicInteger</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">AtomicInteger</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">incrementAndGet</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 线程安全自增</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="三、并发集合-concurrent-collections" tabindex="-1">三、<strong>并发集合（Concurrent Collections）</strong> <a class="header-anchor" href="#三、并发集合-concurrent-collections" aria-hidden="true">#</a></h4><p>高并发场景下的数据结构：</p><ol><li><strong><code>ConcurrentHashMap</code></strong><ul><li>分段锁（Java 7）或CAS+synchronized（Java 8+），高性能并发Map。</li></ul></li><li><strong>阻塞队列（BlockingQueue）</strong><ul><li><code>ArrayBlockingQueue</code>：数组实现的有界队列。</li><li><code>LinkedBlockingQueue</code>：链表实现的可选有界队列。</li><li><code>PriorityBlockingQueue</code>：支持优先级的无界队列。</li></ul></li><li><strong>其他</strong><ul><li><code>CopyOnWriteArrayList</code>：读多写少场景的线程安全List（写时复制）。</li><li><code>ConcurrentSkipListMap</code>：跳表实现的有序并发Map。</li></ul></li></ol><hr><h4 id="四、同步器-synchronizers" tabindex="-1">四、<strong>同步器（Synchronizers）</strong> <a class="header-anchor" href="#四、同步器-synchronizers" aria-hidden="true">#</a></h4><p>控制线程协作：</p><ol><li><strong><code>CountDownLatch</code></strong><ul><li>倒计数器：等待指定数量线程完成。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">CountDownLatch</span><span style="color:#A6ACCD;"> latch </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">CountDownLatch</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">latch</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">await</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 阻塞直到计数器归零</span></span>
<span class="line"><span style="color:#A6ACCD;">latch</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">countDown</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 任务完成时调用</span></span>
<span class="line"></span></code></pre></div></li><li><strong><code>CyclicBarrier</code></strong><ul><li>循环栅栏：多线程相互等待，到达屏障后继续执行（可重用）。</li></ul></li><li><strong><code>Semaphore</code></strong><ul><li>信号量：控制同时访问资源的线程数（限流）。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Semaphore</span><span style="color:#A6ACCD;"> semaphore </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Semaphore</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 允许5个线程同时访问</span></span>
<span class="line"><span style="color:#A6ACCD;">semaphore</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">acquire</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 获取许可</span></span>
<span class="line"><span style="color:#A6ACCD;">semaphore</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">release</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 释放许可</span></span>
<span class="line"></span></code></pre></div></li><li><strong><code>Phaser</code></strong>（Java 7） <ul><li>灵活的阶段同步器，支持动态调整参与线程数。</li></ul></li></ol><hr><h4 id="五、线程池框架-executor-framework" tabindex="-1">五、<strong>线程池框架（Executor Framework）</strong> <a class="header-anchor" href="#五、线程池框架-executor-framework" aria-hidden="true">#</a></h4><p>管理线程生命周期：</p><ol><li><strong>核心接口</strong><ul><li><code>Executor</code>：执行任务的接口。</li><li><code>ExecutorService</code>：扩展<code>Executor</code>，支持任务提交和生命周期管理。</li><li><code>ScheduledExecutorService</code>：支持延时/周期性任务。</li></ul></li><li><strong>工厂类</strong><ul><li><code>Executors</code>：创建常见线程池（需注意资源耗尽风险）。</li></ul></li><li><strong>实现类</strong><ul><li><code>ThreadPoolExecutor</code>：可自定义核心参数（核心线程数、队列等）。</li><li><code>ForkJoinPool</code>：分治任务模型，配合<code>ForkJoinTask</code>使用。</li></ul></li></ol><hr><h4 id="六、异步任务-future-completablefuture" tabindex="-1">六、<strong>异步任务（Future &amp; CompletableFuture）</strong> <a class="header-anchor" href="#六、异步任务-future-completablefuture" aria-hidden="true">#</a></h4><p>异步编程支持：</p><ol><li><strong><code>Future</code>接口</strong><ul><li>表示异步计算结果（需手动轮询结果）。</li></ul></li><li><strong><code>CompletableFuture</code></strong>（Java 8） <ul><li>组合式异步编程：链式调用、异常处理、合并结果等。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">CompletableFuture</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">supplyAsync</span><span style="color:#89DDFF;">(()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">thenApply</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">s </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> s </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;"> World!</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">thenAccept</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;font-style:italic;">::</span><span style="color:#A6ACCD;">println</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div></li></ol><hr><h4 id="七、其他工具" tabindex="-1">七、<strong>其他工具</strong> <a class="header-anchor" href="#七、其他工具" aria-hidden="true">#</a></h4><ol><li><strong><code>ThreadLocalRandom</code></strong><ul><li>线程安全的随机数生成器（替代<code>Random</code>）。</li></ul></li><li><strong><code>Exchanger</code></strong><ul><li>线程间交换数据的同步点。</li></ul></li></ol><hr><h4 id="总结-8" tabindex="-1">总结 <a class="header-anchor" href="#总结-8" aria-hidden="true">#</a></h4><ul><li><strong>锁机制</strong>：<code>ReentrantLock</code>、<code>StampedLock</code></li><li><strong>原子操作</strong>：<code>AtomicInteger</code>、<code>AtomicReference</code></li><li><strong>并发集合</strong>：<code>ConcurrentHashMap</code>、<code>BlockingQueue</code></li><li><strong>同步器</strong>：<code>CountDownLatch</code>、<code>Semaphore</code>、<code>CyclicBarrier</code></li><li><strong>线程池</strong>：<code>ExecutorService</code>、<code>ThreadPoolExecutor</code></li><li><strong>异步编程</strong>：<code>CompletableFuture</code></li></ul><p>正确使用这些工具类可有效提升并发性能、避免死锁、简化代码逻辑。</p><hr><h2 id="并发包中的concurentlinkedqueue和linkedblockingqueue有什么区别" tabindex="-1">并发包中的ConcurentLinkedQueue和LinkedBlockingQueue有什么区别？ <a class="header-anchor" href="#并发包中的concurentlinkedqueue和linkedblockingqueue有什么区别" aria-hidden="true">#</a></h2><p><code>ConcurrentLinkedQueue</code> 和 <code>LinkedBlockingQueue</code> 都是 Java 并发包中的线程安全队列，但在设计目标和使用场景上有显著区别：</p><hr><h4 id="核心区别对比表" tabindex="-1"><strong>核心区别对比表</strong> <a class="header-anchor" href="#核心区别对比表" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>特性</strong></th><th><strong>ConcurrentLinkedQueue</strong></th><th><strong>LinkedBlockingQueue</strong></th></tr></thead><tbody><tr><td><strong>实现机制</strong></td><td>基于 CAS 的非阻塞算法 (无锁)</td><td>基于锁 (ReentrantLock)</td></tr><tr><td><strong>阻塞行为</strong></td><td>完全 <strong>非阻塞</strong></td><td><strong>支持阻塞</strong> (take/put)</td></tr><tr><td><strong>队列边界</strong></td><td>无界（理论无限增长）</td><td>支持有界/无界（默认 Integer.MAX_VALUE）</td></tr><tr><td><strong>空队列行为</strong></td><td><code>poll()</code> 返回 <code>null</code></td><td><code>take()</code> 阻塞至元素可用</td></tr><tr><td><strong>满队列行为</strong></td><td>永不满（无界）</td><td><code>put()</code> 阻塞至空间可用</td></tr><tr><td><strong>迭代器弱一致性</strong></td><td>✅ 是</td><td>✅ 是</td></tr><tr><td><strong>额外功能</strong></td><td>无阻塞方法</td><td>提供 <code>drainTo()</code>、超时方法等</td></tr><tr><td><strong>适用场景</strong></td><td>超高并发读 + 不要求阻塞</td><td>生产者-消费者协调 + 流量控制</td></tr></tbody></table><hr><h4 id="详细解析" tabindex="-1"><strong>详细解析</strong> <a class="header-anchor" href="#详细解析" aria-hidden="true">#</a></h4><h5 id="_1-实现机制" tabindex="-1"><strong>1. 实现机制</strong> <a class="header-anchor" href="#_1-实现机制" aria-hidden="true">#</a></h5><ul><li><p><strong><code>ConcurrentLinkedQueue</code></strong>: 基于 <strong>CAS（Compare-And-Swap）</strong> 的非阻塞算法，无锁设计。通过原子操作保证线程安全，在高并发下提供更高吞吐量。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ConcurrentLinkedQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> clq </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ConcurrentLinkedQueue</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#A6ACCD;">clq</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">offer</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">item1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// CAS 实现插入</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong><code>LinkedBlockingQueue</code></strong>: 基于 <strong>双锁分离设计</strong>（<code>takeLock</code> 和 <code>putLock</code>）：</p><ul><li>生产者锁 (<code>putLock</code>) 控制入队</li><li>消费者锁 (<code>takeLock</code>) 控制出队</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">LinkedBlockingQueue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> lbq </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">LinkedBlockingQueue</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">lbq</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">item1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 获取锁后插入 (阻塞)</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h5 id="_2-阻塞行为" tabindex="-1"><strong>2. 阻塞行为</strong> <a class="header-anchor" href="#_2-阻塞行为" aria-hidden="true">#</a></h5><table><thead><tr><th><strong>操作</strong></th><th>ConcurrentLinkedQueue</th><th>LinkedBlockingQueue</th></tr></thead><tbody><tr><td><strong>入队</strong></td><td><code>offer()</code> → 立即返回成功/失败</td><td><code>put()</code> → 阻塞至队列不满</td></tr><tr><td><strong>出队</strong></td><td><code>poll()</code> → 立即返回元素/null</td><td><code>take()</code> → 阻塞至队列非空</td></tr><tr><td><strong>特殊操作</strong></td><td>❌ 无阻塞方法</td><td>✅ <code>offer(e, timeout)</code>, <code>poll(timeout)</code></td></tr></tbody></table><hr><h5 id="_3-容量特性" tabindex="-1"><strong>3. 容量特性</strong> <a class="header-anchor" href="#_3-容量特性" aria-hidden="true">#</a></h5><table><thead><tr><th><strong>队列类型</strong></th><th><strong>行为</strong></th></tr></thead><tbody><tr><td><strong>ConcurrentLinkedQueue</strong></td><td>无界队列（可能导致 OOM）</td></tr><tr><td><strong>LinkedBlockingQueue</strong></td><td>默认无界（<code>Integer.MAX_VALUE</code>），但推荐指定容量成为 <strong>有界队列</strong>（阻塞控制流量）</td></tr></tbody></table><hr><h5 id="_4-性能对比" tabindex="-1"><strong>4. 性能对比</strong> <a class="header-anchor" href="#_4-性能对比" aria-hidden="true">#</a></h5><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐队列</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><strong>超高并发写入</strong></td><td><code>ConcurrentLinkedQueue</code></td><td>无锁设计减少线程冲突</td></tr><tr><td><strong>流量控制</strong></td><td><code>LinkedBlockingQueue</code></td><td>阻塞机制自然限流</td></tr><tr><td><strong>严格的生产者-消费者模型</strong></td><td><code>LinkedBlockingQueue</code></td><td>阻塞自动协调生产/消费节奏</td></tr><tr><td><strong>读多写少 + 高吞吐</strong></td><td><code>ConcurrentLinkedQueue</code></td><td>CAS 避免锁竞争带来的延迟</td></tr></tbody></table><hr><h4 id="代码行为示例" tabindex="-1"><strong>代码行为示例</strong> <a class="header-anchor" href="#代码行为示例" aria-hidden="true">#</a></h4><h5 id="_1-空队列时读取" tabindex="-1">1. <strong>空队列时读取</strong> <a class="header-anchor" href="#_1-空队列时读取" aria-hidden="true">#</a></h5><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// ConcurrentLinkedQueue</span></span>
<span class="line"><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> item1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> clq</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">poll</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 立即返回 null</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// LinkedBlockingQueue</span></span>
<span class="line"><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> item2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> lbq</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">take</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 阻塞直到其他线程放入元素</span></span>
<span class="line"></span></code></pre></div><h5 id="_2-队列满时写入" tabindex="-1">2. <strong>队列满时写入</strong> <a class="header-anchor" href="#_2-队列满时写入" aria-hidden="true">#</a></h5><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// ConcurrentLinkedQueue (无界，永不满)</span></span>
<span class="line"><span style="color:#A6ACCD;">clq</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">offer</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">overflow</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 永远返回 true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// LinkedBlockingQueue (有界容量100)</span></span>
<span class="line"><span style="color:#A6ACCD;">lbq</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">put</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">overflow</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// 阻塞直到队列有空位</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="如何选择-1" tabindex="-1"><strong>如何选择？</strong> <a class="header-anchor" href="#如何选择-1" aria-hidden="true">#</a></h4><ul><li><p><strong><code>ConcurrentLinkedQueue</code></strong>: 适用于 <strong>高并发 + 高吞吐 + 不需要阻塞协调</strong> 的场景（例如日志缓冲）。 <strong>风险</strong>：无界队列可能导致内存溢出（OOM）。</p></li><li><p><strong><code>LinkedBlockingQueue</code></strong>: 适用于 <strong>生产者-消费者模型 + 需要阻塞协调 + 流量控制</strong> 的场景（如线程池任务队列）。 <strong>最佳实践</strong>：创建时指定队列大小避免默认无界风险。</p></li></ul><hr><h4 id="高级特性补充" tabindex="-1"><strong>高级特性补充</strong> <a class="header-anchor" href="#高级特性补充" aria-hidden="true">#</a></h4><ul><li><strong>迭代器行为</strong>：两者均提供 <strong>弱一致性迭代器</strong>（遍历时不一定会反映最新修改）。</li><li><strong>内存可见性</strong>：所有操作遵守 <code>happens-before</code> 规则（Java 内存模型 JMM）。</li><li><strong>扩展能力</strong>： <ul><li><code>LinkedBlockingQueue</code> 支持批量操作 <code>drainTo(Collection)</code> (高效迁移元素)</li><li><code>ConcurrentLinkedQueue</code> 支持 <code>size()</code>（但需要遍历链表，性能不稳定）</li></ul></li></ul><hr><h2 id="java并发类库提供的线程池有哪几种-分别有什么特点" tabindex="-1">Java并发类库提供的线程池有哪几种？分别有什么特点 <a class="header-anchor" href="#java并发类库提供的线程池有哪几种-分别有什么特点" aria-hidden="true">#</a></h2><p>Java并发框架（<code>java.util.concurrent</code>）通过<code>Executors</code>工厂类提供了以下几种常见的线程池实现，每种线程池有独特的设计目标和适用场景：</p><hr><h4 id="_1-fixedthreadpool-固定大小线程池" tabindex="-1">1. <strong>FixedThreadPool（固定大小线程池）</strong> <a class="header-anchor" href="#_1-fixedthreadpool-固定大小线程池" aria-hidden="true">#</a></h4><ul><li><strong>创建方式</strong>： <code>Executors.newFixedThreadPool(int nThreads)</code></li><li><strong>核心特点</strong>： <ul><li>固定线程数量（核心线程数 = 最大线程数）。</li><li>使用<strong>无界阻塞队列</strong>（<code>LinkedBlockingQueue</code>），任务无限排队。</li><li>当所有线程都在忙时，新任务在队列中等待。</li></ul></li><li><strong>优点</strong>： 稳定控制最大并发数，避免资源耗尽。</li><li><strong>缺点</strong>： 无界队列可能堆积大量任务导致内存溢出（OOM）。</li><li><strong>适用场景</strong>： 负载较高、需限制并发线程数的场景（如Web服务）。</li></ul><hr><h4 id="_2-cachedthreadpool-缓存线程池" tabindex="-1">2. <strong>CachedThreadPool（缓存线程池）</strong> <a class="header-anchor" href="#_2-cachedthreadpool-缓存线程池" aria-hidden="true">#</a></h4><ul><li><strong>创建方式</strong>： <code>Executors.newCachedThreadPool()</code></li><li><strong>核心特点</strong>： <ul><li>线程数量动态伸缩（核心线程数=0，最大线程数为<code>Integer.MAX_VALUE</code>）。</li><li>使用<strong>直接提交队列</strong>（<code>SynchronousQueue</code>），任务不排队，直接交给线程处理。</li><li>空闲线程超时自动销毁（默认60秒）。</li></ul></li><li><strong>优点</strong>： 快速响应突发任务，避免任务堆积，适合短任务。</li><li><strong>缺点</strong>： 最大线程数无上限，可能创建大量线程引发资源耗尽。</li><li><strong>适用场景</strong>： 大量<strong>短生命周期的异步任务</strong>（如HTTP请求）。</li></ul><hr><h4 id="_3-singlethreadexecutor-单线程线程池" tabindex="-1">3. <strong>SingleThreadExecutor（单线程线程池）</strong> <a class="header-anchor" href="#_3-singlethreadexecutor-单线程线程池" aria-hidden="true">#</a></h4><ul><li><strong>创建方式</strong>： <code>Executors.newSingleThreadExecutor()</code></li><li><strong>核心特点</strong>： <ul><li><strong>仅一个工作线程</strong>（核心线程数=最大线程数=1）。</li><li>使用<strong>无界队列</strong>（<code>LinkedBlockingQueue</code>），任务顺序执行。</li><li>线程异常终止后自动重启。</li></ul></li><li><strong>优点</strong>： 保证任务按提交顺序有序执行，避免并发问题。</li><li><strong>缺点</strong>： 无界队列有OOM风险；单线程无法并行。</li><li><strong>适用场景</strong>： 需顺序执行的任务（如日志处理、简单调度）。</li></ul><hr><h4 id="_4-scheduledthreadpool-定时任务线程池" tabindex="-1">4. <strong>ScheduledThreadPool（定时任务线程池）</strong> <a class="header-anchor" href="#_4-scheduledthreadpool-定时任务线程池" aria-hidden="true">#</a></h4><ul><li><strong>创建方式</strong>： <code>Executors.newScheduledThreadPool(int corePoolSize)</code></li><li><strong>核心特点</strong>： <ul><li>固定核心线程数，支持<strong>延迟/周期性任务</strong>（如定时任务）。</li><li>使用<strong>延迟阻塞队列</strong>（<code>DelayedWorkQueue</code>）。</li><li>最大线程数为<code>Integer.MAX_VALUE</code>，但非核心线程会超时回收。</li></ul></li><li><strong>优点</strong>： 精准控制任务的延迟或周期性执行。</li><li><strong>缺点</strong>： 复杂调度逻辑可能导致任务堆积。</li><li><strong>适用场景</strong>： 定时任务、心跳检测、周期性同步（如数据备份）。</li></ul><hr><h4 id="_5-workstealingpool-工作窃取线程池-java-8" tabindex="-1">5. <strong>WorkStealingPool（工作窃取线程池）</strong>（Java 8+） <a class="header-anchor" href="#_5-workstealingpool-工作窃取线程池-java-8" aria-hidden="true">#</a></h4><ul><li><strong>创建方式</strong>： <code>Executors.newWorkStealingPool(int parallelism)</code></li><li><strong>核心特点</strong>： <ul><li>基于<strong>ForkJoinPool</strong>实现，采用<strong>工作窃取算法</strong>（空闲线程从其他线程队列尾部&quot;窃取&quot;任务）。</li><li>默认并行度为CPU核心数。</li></ul></li><li><strong>优点</strong>： 高性能并行处理，减少线程竞争，利用多核优势。</li><li><strong>适用场景</strong>： <strong>计算密集型任务</strong>（如分治、递归算法）。</li></ul><hr><h4 id="⚠️-关键注意事项" tabindex="-1">⚠️ 关键注意事项 <a class="header-anchor" href="#⚠️-关键注意事项" aria-hidden="true">#</a></h4><ol><li><p><strong>资源耗尽风险</strong>：</p><ul><li><code>FixedThreadPool</code>/<code>SingleThreadExecutor</code>使用<strong>无界队列</strong>，可能引起OOM。</li><li><code>CachedThreadPool</code>创建<strong>无上限线程</strong>，可能耗尽CPU/内存。</li><li><strong>解决</strong>：推荐手动创建<code>ThreadPoolExecutor</code>，明确指定队列长度和拒绝策略。</li></ul></li><li><p><strong>推荐创建方式</strong>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 自定义线程池（规避OOM风险）</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ThreadPoolExecutor</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  corePoolSize</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 核心线程数</span></span>
<span class="line"><span style="color:#A6ACCD;">  maxPoolSize</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">   </span><span style="color:#676E95;font-style:italic;">// 最大线程数</span></span>
<span class="line"><span style="color:#A6ACCD;">  keepAliveTime</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 空闲超时时间</span></span>
<span class="line"><span style="color:#A6ACCD;">  TimeUnit</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">SECONDS</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">LinkedBlockingQueue</span><span style="color:#89DDFF;">&lt;&gt;(</span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">),</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 有界队列</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ThreadFactoryBuilder</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">setNameFormat</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">pool-%d</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">build</span><span style="color:#89DDFF;">(),</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> ThreadPoolExecutor</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">CallerRunsPolicy</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 拒绝策略</span></span>
<span class="line"><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div></li></ol><hr><h4 id="总结对比" tabindex="-1">总结对比 <a class="header-anchor" href="#总结对比" aria-hidden="true">#</a></h4><table><thead><tr><th>线程池类型</th><th>核心线程数</th><th>最大线程数</th><th>任务队列</th><th>适用场景</th></tr></thead><tbody><tr><td>FixedThreadPool</td><td>固定（=nThreads）</td><td>固定（=nThreads）</td><td>无界队列（易OOM）</td><td>控制并发数的稳定任务</td></tr><tr><td>CachedThreadPool</td><td>0</td><td>Integer.MAX_VALUE</td><td>直接提交队列（不存储）</td><td>短生命周期任务</td></tr><tr><td>SingleThreadExecutor</td><td>1</td><td>1</td><td>无界队列（易OOM）</td><td>单线程顺序执行</td></tr><tr><td>ScheduledThreadPool</td><td>固定（用户指定）</td><td>Integer.MAX_VALUE</td><td>延迟队列</td><td>定时/周期性任务</td></tr><tr><td>WorkStealingPool</td><td>CPU核心数</td><td>无上限</td><td>工作窃取队列</td><td>计算密集型并行任务（Java8+）</td></tr></tbody></table><blockquote><p><strong>建议</strong>: 生产环境优先使用<code>ThreadPoolExecutor</code>手动配置参数（队列容量、拒绝策略），避免使用<code>Executors</code>的默认方法，以减少OOM风险。</p></blockquote><hr><h2 id="automicinteger底层实现原理是什么-如何在自己的产品代码中应用cas操作" tabindex="-1">AutomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？ <a class="header-anchor" href="#automicinteger底层实现原理是什么-如何在自己的产品代码中应用cas操作" aria-hidden="true">#</a></h2><p>AtomicInteger 的底层实现原理和应用 CAS 操作的指南如下：</p><hr><h4 id="atomicinteger-底层实现原理" tabindex="-1"><strong>AtomicInteger 底层实现原理</strong> <a class="header-anchor" href="#atomicinteger-底层实现原理" aria-hidden="true">#</a></h4><p><strong>核心：CAS (Compare-and-Swap) 操作 + volatile</strong></p><ol><li><p><strong>volatile 保证可见性：</strong><code>AtomicInteger</code> 内部使用 <code>private volatile int value;</code> 存储值：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">volatile</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> value</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 关键：volatile 确保写入后对其他线程立即可见</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>Unsafe 类操作 CAS：</strong> 通过 <code>Unsafe</code> 类调用底层 CPU 指令（如 x86 的 <code>CMPXCHG</code>）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">boolean</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">compareAndSet</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> expect</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> update</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> unsafe</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">compareAndSwapInt</span><span style="color:#89DDFF;">(this,</span><span style="color:#A6ACCD;"> valueOffset</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> expect</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> update</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li><code>valueOffset</code>: value 字段的内存偏移地址（通过 <code>Unsafe.objectFieldOffset</code> 获取）。</li></ul></li><li><p><strong>CAS 实现原子操作（以 getAndIncrement 为例）：</strong></p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getAndIncrement</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> unsafe</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getAndAddInt</span><span style="color:#89DDFF;">(this,</span><span style="color:#A6ACCD;"> valueOffset</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><code>Unsafe.getAndAddInt</code> 的典型实现（自旋 CAS）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getAndAddInt</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> o</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">long</span><span style="color:#A6ACCD;"> offset</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> delta</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> v</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">do</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        v </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getIntVolatile</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">o</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> offset</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 读取当前值</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(!</span><span style="color:#82AAFF;">compareAndSwapInt</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">o</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> offset</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> v</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> v </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> delta</span><span style="color:#89DDFF;">));</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// CAS 失败则重试</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> v</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ol><p><strong>核心流程：</strong></p><ol><li>读取当前值 <code>v</code>（volatile 保证可见）。</li><li>计算新值 <code>v + delta</code>（如 <code>v + 1</code>）。</li><li>执行 <code>CAS(v, v + delta)</code>： <ul><li>如果当前值仍为 <code>v</code>，则更新为 <code>v + delta</code>，操作成功。</li><li>如果当前值被其他线程修改，<code>CAS</code> 失败，<strong>立即重试</strong>（自旋）。</li></ul></li></ol><hr><h4 id="如何在产品代码中应用-cas-操作" tabindex="-1"><strong>如何在产品代码中应用 CAS 操作？</strong> <a class="header-anchor" href="#如何在产品代码中应用-cas-操作" aria-hidden="true">#</a></h4><h5 id="_1-优先使用标准库中的原子类" tabindex="-1"><strong>1. 优先使用标准库中的原子类</strong> <a class="header-anchor" href="#_1-优先使用标准库中的原子类" aria-hidden="true">#</a></h5><ul><li><strong>直接使用：</strong> <code>AtomicInteger</code>, <code>AtomicLong</code>, <code>AtomicReference</code>, <code>AtomicStampedReference</code>（解决ABA问题）等。</li><li><strong>适用场景：</strong> 计数器、状态标志、对象引用更新等。<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 无锁线程安全的计数器</span></span>
<span class="line"><span style="color:#C792EA;">AtomicInteger</span><span style="color:#A6ACCD;"> counter </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">AtomicInteger</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    counter</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getAndIncrement</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 内部使用 CAS</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul><h5 id="_2-借助-atomicreference-实现复杂对象的原子更新" tabindex="-1"><strong>2. 借助 <code>AtomicReference</code> 实现复杂对象的原子更新</strong> <a class="header-anchor" href="#_2-借助-atomicreference-实现复杂对象的原子更新" aria-hidden="true">#</a></h5><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">AtomicUserProfile</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Profile</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> age</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">AtomicReference</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Profile</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> ref </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">AtomicReference</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">updateProfile</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">newName</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">newAge</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Profile</span><span style="color:#A6ACCD;"> oldVal</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> newVal</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">do</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            oldVal </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ref</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;">                     </span><span style="color:#676E95;font-style:italic;">// 1. 读取当前值</span></span>
<span class="line"><span style="color:#A6ACCD;">            newVal </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Profile</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">newName</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> newAge</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">   </span><span style="color:#676E95;font-style:italic;">// 2. 创建新对象</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(!</span><span style="color:#A6ACCD;">ref</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">compareAndSet</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">oldVal</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> newVal</span><span style="color:#89DDFF;">));</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 3. CAS 更新（失败重试）</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h5 id="_3-使用-varhandle-java-9-推荐" tabindex="-1"><strong>3. 使用 <code>VarHandle</code>（Java 9+ 推荐）</strong> <a class="header-anchor" href="#_3-使用-varhandle-java-9-推荐" aria-hidden="true">#</a></h5><p>替代 <code>Unsafe</code>，是 JEP 193 定义的更安全、标准的方式：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Counter</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">volatile</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> count</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">VarHandle</span><span style="color:#A6ACCD;"> COUNT_HANDLE</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            COUNT_HANDLE </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> MethodHandles</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">lookup</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">findVarHandle</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">                Counter</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">count</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> int</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Exception</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">throw</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Error</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">e</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> oldVal</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">do</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            oldVal </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> COUNT_HANDLE</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">(this);</span><span style="color:#A6ACCD;">     </span><span style="color:#676E95;font-style:italic;">// 读取当前值</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(!</span><span style="color:#A6ACCD;">COUNT_HANDLE</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">compareAndSet</span><span style="color:#89DDFF;">(this,</span><span style="color:#A6ACCD;"> oldVal</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> oldVal </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">));</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h5 id="_4-使用-atomic-fieldupdater-低开销原子更新" tabindex="-1"><strong>4. 使用 <code>Atomic*FieldUpdater</code>（低开销原子更新）</strong> <a class="header-anchor" href="#_4-使用-atomic-fieldupdater-低开销原子更新" aria-hidden="true">#</a></h5><p>节省内存（避免每个对象创建原子实例）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">User</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">volatile</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> account</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">AtomicIntegerFieldUpdater</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">User</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> updater </span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">        AtomicIntegerFieldUpdater</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newUpdater</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">User</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">account</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        updater</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getAndIncrement</span><span style="color:#89DDFF;">(this);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// CAS 更新自己的 account 字段</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="应用-cas-的注意事项" tabindex="-1"><strong>应用 CAS 的注意事项</strong> <a class="header-anchor" href="#应用-cas-的注意事项" aria-hidden="true">#</a></h4><ol><li><p><strong>ABA 问题：</strong></p><ul><li><strong>问题描述：</strong> 值从 A 改为 B 后又改回 A，CAS 无法感知中间变化。</li><li><strong>解决方案：</strong><ul><li>使用带版本号的原子类（<code>AtomicStampedReference</code>）。</li><li><code>AtomicMarkableReference</code>。</li></ul></li></ul></li><li><p><strong>自旋开销：</strong></p><ul><li>高并发竞争时，反复重试 CAS 可能导致 CPU 飙升。</li><li><strong>优化策略：</strong><ul><li>结合线程阻塞（如 <code>LockSupport.parkNanos()</code>）后重试（如 <code>LongAdder</code> 策略）。</li></ul></li></ul></li><li><p><strong>不适用于复杂操作：</strong></p><ul><li>CAS 只能保证<strong>单个变量</strong>的原子性。</li><li>多个变量的原子更新需用锁或组合为对象后用 <code>AtomicReference</code>。</li></ul></li></ol><hr><h4 id="总结建议" tabindex="-1"><strong>总结建议</strong> <a class="header-anchor" href="#总结建议" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐方式</strong></th></tr></thead><tbody><tr><td>简单数值/布尔更新</td><td><code>AtomicInteger</code>, <code>AtomicBoolean</code></td></tr><tr><td>对象引用更新</td><td><code>AtomicReference</code></td></tr><tr><td>需感知版本变化的更新</td><td><code>AtomicStampedReference</code></td></tr><tr><td>类内字段的原子更新（节省开销）</td><td><code>Atomic*FieldUpdater</code> 或 <code>VarHandle</code></td></tr><tr><td>Java 9+ 环境的新代码</td><td>优先使用 <code>VarHandle</code></td></tr></tbody></table><p><strong>关键原则：</strong></p><ol><li><strong>避免重复造轮子</strong>（除非特殊优化）。</li><li><strong>严格检测性能</strong>（对比锁/CAS在不同场景的开销）。</li><li><strong>优先使用标准库</strong>（如 <code>java.util.concurrent.atomic</code>）。</li></ol><p>通过合理应用 CAS 机制，可以在高并发场景中以更低的开销实现线程安全（如金融交易计数器、实时状态机），但务必在充分理解其特性的前提下使用。</p><hr><h2 id="请介绍类加载过程-什么是双亲委派模型" tabindex="-1">请介绍类加载过程，什么是双亲委派模型？ <a class="header-anchor" href="#请介绍类加载过程-什么是双亲委派模型" aria-hidden="true">#</a></h2><h4 id="java-类加载过程" tabindex="-1">Java 类加载过程 <a class="header-anchor" href="#java-类加载过程" aria-hidden="true">#</a></h4><p>类加载是指 JVM 将 <code>.class</code> 文件的二进制数据加载到内存中，转换为可执行的 Java 类型（如 Class 对象）的过程，分为以下步骤：</p><h5 id="_1-加载-loading" tabindex="-1">1. <strong>加载（Loading）</strong> <a class="header-anchor" href="#_1-加载-loading" aria-hidden="true">#</a></h5><ul><li><strong>任务</strong>：查找并加载类的二进制数据（如 <code>.class</code> 文件）。</li><li><strong>步骤</strong>： <ul><li>通过类全限定名（如 <code>java.lang.String</code>）获取 <code>.class</code> 文件的字节流。</li><li>将字节流转换为<strong>方法区</strong>的运行时数据结构。</li><li>在堆中创建 <code>java.lang.Class</code> 对象，作为方法区数据的访问入口。</li></ul></li><li><strong>加载器</strong>：由类加载器（<code>ClassLoader</code>）完成，例如 <code>BootstrapClassLoader</code>、<code>AppClassLoader</code> 等。</li></ul><h5 id="_2-链接-linking" tabindex="-1">2. <strong>链接（Linking）</strong> <a class="header-anchor" href="#_2-链接-linking" aria-hidden="true">#</a></h5><ul><li><strong>(a) 验证（Verification）</strong> 确保 <code>.class</code> 文件符合 JVM 规范（如魔数、语法、字节码等），防止恶意代码。</li><li><strong>(b) 准备（Preparation）</strong> 为<strong>类变量</strong>（静态变量）分配内存，并赋<strong>默认初始值</strong>（如 <code>int</code> 为 <code>0</code>，引用类型为 <code>null</code>）。 ⚠️ 注意：<code>final static</code> 常量在此时赋真实值（如 <code>final static int x=100</code> 直接赋 <code>100</code>）。</li><li><strong>(c) 解析（Resolution）</strong> 将常量池中的<strong>符号引用</strong>（如类/方法名称）替换为<strong>直接引用</strong>（内存地址）。</li></ul><h5 id="_3-初始化-initialization" tabindex="-1">3. <strong>初始化（Initialization）</strong> <a class="header-anchor" href="#_3-初始化-initialization" aria-hidden="true">#</a></h5><ul><li>执行类构造器 <code>&lt;clinit&gt;()</code> 方法（由编译器生成），为类变量赋<strong>真实值</strong>，并执行 <code>static {}</code> 代码块。</li><li>触发条件：首次使用类时（如 <code>new</code> 实例、访问静态变量/方法等）。</li><li>父类需先初始化（除非是接口或已初始化）。</li></ul><blockquote><p><strong>总结流程</strong>： 加载 → 验证 → 准备 → 解析 → 初始化 （解析可能在初始化之后发生，取决于 JVM 实现）</p></blockquote><hr><h4 id="双亲委派模型-parent-delegation-model" tabindex="-1">双亲委派模型（Parent Delegation Model） <a class="header-anchor" href="#双亲委派模型-parent-delegation-model" aria-hidden="true">#</a></h4><p>双亲委派是类加载器的协作机制，确保类加载的安全性和唯一性。</p><h5 id="_1-工作原理" tabindex="-1">1. <strong>工作原理</strong> <a class="header-anchor" href="#_1-工作原理" aria-hidden="true">#</a></h5><ul><li>每个类加载器收到加载请求时，<strong>先委派给父类加载器</strong>处理。</li><li>父类加载器无法完成时（未找到类），子加载器才自己加载。</li><li><strong>委派关系链</strong>： <code>子加载器 → 父加载器 → 祖父加载器 → ...</code> 最终委派到启动类加载器（<code>BootstrapClassLoader</code>）。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 伪代码：ClassLoader 的 loadClass 方法核心逻辑</span></span>
<span class="line"><span style="color:#C792EA;">protected</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Class</span><span style="color:#89DDFF;">&lt;</span><span style="color:#89DDFF;font-style:italic;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">loadClass</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> name</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">boolean</span><span style="color:#A6ACCD;"> resolve</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> throws ClassNotFoundException </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">synchronized</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">getClassLoadingLock</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 1. 检查是否已加载</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Class</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> c </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">findLoadedClass</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">c </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">                </span><span style="color:#676E95;font-style:italic;">// 2. 请求父加载器加载</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">parent </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                    c </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> parent</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">loadClass</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">false);</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                    c </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">findBootstrapClassOrNull</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 委派给启动类加载器</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">ClassNotFoundException</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">                </span><span style="color:#676E95;font-style:italic;">// 父加载器失败，继续尝试</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 3. 若父加载器未找到，由自身加载</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">c </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                c </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">findClass</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 子类重写此方法</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> c</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h5 id="_2-加载器层次结构-从最高到最低" tabindex="-1">2. <strong>加载器层次结构（从最高到最低）</strong> <a class="header-anchor" href="#_2-加载器层次结构-从最高到最低" aria-hidden="true">#</a></h5><table><thead><tr><th><strong>类加载器</strong></th><th><strong>职责</strong></th><th><strong>路径</strong></th></tr></thead><tbody><tr><td><code>Bootstrap ClassLoader</code></td><td>加载核心库（如 <code>rt.jar</code>）</td><td><code>$JAVA_HOME/lib</code></td></tr><tr><td><code>Extension ClassLoader</code></td><td>加载扩展库</td><td><code>$JAVA_HOME/lib/ext</code></td></tr><tr><td><code>App ClassLoader</code></td><td>加载应用类（ClassPath 下的类）</td><td>项目 <code>classpath</code> 或模块路径</td></tr><tr><td>自定义加载器（如 <code>MyClassLoader</code>）</td><td>用户自定义加载逻辑</td><td>可指定任意路径（如网络/加密）</td></tr></tbody></table><h5 id="_3-双亲委派优势" tabindex="-1">3. <strong>双亲委派优势</strong> <a class="header-anchor" href="#_3-双亲委派优势" aria-hidden="true">#</a></h5><ul><li><strong>安全性</strong> 避免用户伪造核心类（如自定义 <code>java.lang.String</code> 会被父加载器阻止）。</li><li><strong>避免重复加载</strong> 父加载器已加载的类，子加载器不会重复加载。</li><li><strong>统一性</strong> 保证所有类使用同一份 <code>Class</code> 对象（如 <code>Object.class</code> 只由 <code>Bootstrap</code> 加载）。</li></ul><h5 id="_4-打破双亲委派的场景" tabindex="-1">4. <strong>打破双亲委派的场景</strong> <a class="header-anchor" href="#_4-打破双亲委派的场景" aria-hidden="true">#</a></h5><ul><li><strong>SPI机制</strong>（如 JDBC 驱动加载）： 核心接口（如 <code>java.sql.Driver</code>）由 <code>Bootstrap</code> 加载，但实现类需由线程上下文加载器（<code>Thread Context ClassLoader</code>）加载。</li><li><strong>热部署</strong>： 为同一类创建不同版本的类加载器（如 Tomcat 为每个 Web 应用提供独立加载器）。</li></ul><hr><h4 id="示例-双亲委派流程" tabindex="-1">示例：双亲委派流程 <a class="header-anchor" href="#示例-双亲委派流程" aria-hidden="true">#</a></h4><p>假设加载 <code>com.example.MyClass</code>：</p><ol><li><code>AppClassLoader</code> 收到请求，委派给 <code>ExtensionClassLoader</code>。</li><li><code>ExtensionClassLoader</code> 委派给 <code>BootstrapClassLoader</code>。</li><li><code>BootstrapClassLoader</code> 在核心库中未找到，返回失败。</li><li><code>ExtensionClassLoader</code> 在扩展库中未找到，返回失败。</li><li><code>AppClassLoader</code> 在 ClassPath 下查找并加载该类。</li></ol><h4 id="总结-9" tabindex="-1">总结 <a class="header-anchor" href="#总结-9" aria-hidden="true">#</a></h4><ul><li><strong>类加载过程</strong>：加载 → 链接（验证、准备、解析） → 初始化。</li><li><strong>双亲委派模型</strong>：保障安全与类唯一性，通过逐级向上委托避免重复加载。 通过理解其机制，可以更好地处理类冲突、设计自定义类加载器或解决类加载异常（如 <code>ClassNotFoundException</code>）。</li></ul><hr><h2 id="有哪些方法可以在运行时动态生成一个java类" tabindex="-1">有哪些方法可以在运行时动态生成一个Java类？ <a class="header-anchor" href="#有哪些方法可以在运行时动态生成一个java类" aria-hidden="true">#</a></h2><p>在 Java 中，有几种常用的方法在运行时动态生成类，各有其适用场景和特点：</p><hr><h4 id="_1-java-编译器-api-jdk-标准库" tabindex="-1">1. <strong>Java 编译器 API (JDK 标准库)</strong> <a class="header-anchor" href="#_1-java-编译器-api-jdk-标准库" aria-hidden="true">#</a></h4><p>通过 <code>javax.tools.JavaCompiler</code> 编译 Java 源码字符串：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">JavaCompiler</span><span style="color:#A6ACCD;"> compiler </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ToolProvider</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getSystemJavaCompiler</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">StandardJavaFileManager</span><span style="color:#A6ACCD;"> fileManager </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">        compiler</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getStandardFileManager</span><span style="color:#89DDFF;">(null,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 定义源码内容</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> className </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">DynamicClass</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> code </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">public class </span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> className </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;"> { public void hello() { System.out.println(</span><span style="color:#A6ACCD;">\\&quot;</span><span style="color:#C3E88D;">Hello, World!</span><span style="color:#A6ACCD;">\\&quot;</span><span style="color:#C3E88D;">); } }</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">JavaFileObject</span><span style="color:#A6ACCD;"> source </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">SimpleJavaFileObject</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">        URI</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">string:///</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> className </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">.java</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">),</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">        JavaFileObject</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Kind</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">SOURCE</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">CharSequence</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getCharContent</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">boolean</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">ignoreErrors</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> code</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 编译源码</span></span>
<span class="line"><span style="color:#A6ACCD;">    compiler</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getTask</span><span style="color:#89DDFF;">(null,</span><span style="color:#A6ACCD;"> fileManager</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null,</span><span style="color:#A6ACCD;"> Arrays</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">asList</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">source</span><span style="color:#89DDFF;">)).</span><span style="color:#82AAFF;">call</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 加载编译后的类</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">ClassLoader</span><span style="color:#A6ACCD;"> loader </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">URLClassLoader</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">URL</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">]);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Class</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> clazz </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> loader</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">loadClass</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">className</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> instance </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> clazz</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getDeclaredConstructor</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">newInstance</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    clazz</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getMethod</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">invoke</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">instance</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="_2-字节码操作库" tabindex="-1">2. <strong>字节码操作库</strong> <a class="header-anchor" href="#_2-字节码操作库" aria-hidden="true">#</a></h4><h5 id="asm-底层-高性能" tabindex="-1"><strong>ASM（底层，高性能）</strong> <a class="header-anchor" href="#asm-底层-高性能" aria-hidden="true">#</a></h5><p>直接操作字节码，效率高但学习曲线陡峭：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ClassWriter</span><span style="color:#A6ACCD;"> cw </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ClassWriter</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ClassWriter</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">COMPUTE_FRAMES</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">cw</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">visit</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Opcodes</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">V17</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Opcodes</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">ACC_PUBLIC</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">DynamicClass</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">java/lang/Object</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 生成 public void hello()</span></span>
<span class="line"><span style="color:#C792EA;">MethodVisitor</span><span style="color:#A6ACCD;"> mv </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> cw</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">visitMethod</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Opcodes</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">ACC_PUBLIC</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">()V</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null);</span></span>
<span class="line"><span style="color:#A6ACCD;">mv</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">visitFieldInsn</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Opcodes</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">GETSTATIC</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">java/lang/System</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">out</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Ljava/io/PrintStream;</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">mv</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">visitLdcInsn</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello, ASM!</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">mv</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">visitMethodInsn</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Opcodes</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">INVOKEVIRTUAL</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">java/io/PrintStream</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">println</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">(Ljava/lang/String;)V</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">false);</span></span>
<span class="line"><span style="color:#A6ACCD;">mv</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">visitInsn</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Opcodes</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">RETURN</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">mv</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">visitMaxs</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">mv</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">visitEnd</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 定义构造方法</span></span>
<span class="line"><span style="color:#C792EA;">MethodVisitor</span><span style="color:#A6ACCD;"> constructor </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> cw</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">visitMethod</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Opcodes</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">ACC_PUBLIC</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">&lt;init&gt;</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">()V</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null);</span></span>
<span class="line"><span style="color:#A6ACCD;">constructor</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">visitVarInsn</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Opcodes</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">ALOAD</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">constructor</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">visitMethodInsn</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Opcodes</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">INVOKESPECIAL</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">java/lang/Object</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">&lt;init&gt;</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">()V</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">false);</span></span>
<span class="line"><span style="color:#A6ACCD;">constructor</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">visitInsn</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Opcodes</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">RETURN</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">constructor</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">visitMaxs</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">constructor</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">visitEnd</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">cw</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">visitEnd</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#C792EA;">byte</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> byteCode </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> cw</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">toByteArray</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 加载类</span></span>
<span class="line"><span style="color:#C792EA;">Class</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> clazz </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ByteArrayClassLoader</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">defineClass</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">DynamicClass</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> byteCode</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">clazz</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getMethod</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">invoke</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">clazz</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getDeclaredConstructor</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">newInstance</span><span style="color:#89DDFF;">());</span></span>
<span class="line"></span></code></pre></div><p>自定义类加载器：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ByteArrayClassLoader</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ClassLoader</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">Class</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">defineClass</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">byte</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">code</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">defineClass</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> code</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> code</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><hr><h5 id="javassist-简化版" tabindex="-1"><strong>Javassist（简化版）</strong> <a class="header-anchor" href="#javassist-简化版" aria-hidden="true">#</a></h5><p>提供基于源码字符串的高级 API：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">ClassPool</span><span style="color:#A6ACCD;"> pool </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ClassPool</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getDefault</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#C792EA;">CtClass</span><span style="color:#A6ACCD;"> ctClass </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> pool</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">makeClass</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">DynamicClass</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#C792EA;">CtMethod</span><span style="color:#A6ACCD;"> method </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> CtNewMethod</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">make</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">public void hello() { System.out.println(</span><span style="color:#A6ACCD;">\\&quot;</span><span style="color:#C3E88D;">Hello, Javassist!</span><span style="color:#A6ACCD;">\\&quot;</span><span style="color:#C3E88D;">); }</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    ctClass</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">ctClass</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addMethod</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">method</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">ctClass</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addConstructor</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">CtNewConstructor</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defaultConstructor</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ctClass</span><span style="color:#89DDFF;">));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 加载类</span></span>
<span class="line"><span style="color:#C792EA;">Class</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> clazz </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ctClass</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">toClass</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> instance </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> clazz</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getDeclaredConstructor</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">newInstance</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">clazz</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getMethod</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">invoke</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">instance</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="_3-动态代理-jdk-或-cglib" tabindex="-1">3. <strong>动态代理 (JDK 或 CGLIB)</strong> <a class="header-anchor" href="#_3-动态代理-jdk-或-cglib" aria-hidden="true">#</a></h4><h5 id="jdk-动态代理-仅限接口" tabindex="-1"><strong>JDK 动态代理（仅限接口）</strong> <a class="header-anchor" href="#jdk-动态代理-仅限接口" aria-hidden="true">#</a></h5><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Hello</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">hello</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> proxy </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Proxy</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newProxyInstance</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">    loader</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Class</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;[]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> Hello</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">proxyObj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> method</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Dynamic Proxy Hello!</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">((</span><span style="color:#A6ACCD;">Hello</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> proxy</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">hello</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span></code></pre></div><h5 id="cglib-支持普通类" tabindex="-1"><strong>CGLIB（支持普通类）</strong> <a class="header-anchor" href="#cglib-支持普通类" aria-hidden="true">#</a></h5><p>需添加依赖：<code>cglib:cglib:3.3.0</code></p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Enhancer</span><span style="color:#A6ACCD;"> enhancer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Enhancer</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">enhancer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setSuperclass</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">enhancer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setCallback</span><span style="color:#89DDFF;">((</span><span style="color:#A6ACCD;">MethodInterceptor</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> method</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> args</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> proxy</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">CGLIB Dynamic Method!</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#89DDFF;">});</span></span>
<span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> proxy </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> enhancer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">proxy</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">toString</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 触发拦截</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="_4-脚本引擎-外嵌编译器" tabindex="-1">4. <strong>脚本引擎（外嵌编译器）</strong> <a class="header-anchor" href="#_4-脚本引擎-外嵌编译器" aria-hidden="true">#</a></h4><p>使用 Groovy 等脚本引擎：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Maven: org.codehaus.groovy:groovy:3.0.10</span></span>
<span class="line"><span style="color:#C792EA;">GroovyClassLoader</span><span style="color:#A6ACCD;"> loader </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">GroovyClassLoader</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#C792EA;">Class</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> groovyClass </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> loader</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">parseClass</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">class DynamicClass { void hello() { println &#39;Hello, Groovy!&#39; } }</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> instance </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> groovyClass</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getDeclaredConstructor</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">newInstance</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">groovyClass</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getMethod</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">invoke</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">instance</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="对比总结-2" tabindex="-1">对比总结： <a class="header-anchor" href="#对比总结-2" aria-hidden="true">#</a></h4><table><thead><tr><th><strong>方法</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>编译器 API</td><td>依赖 JDK 工具链，生成完整类</td><td>需完整 Java 语法的动态源码编译</td></tr><tr><td>ASM</td><td>高性能，直接操作字节码，学习曲线高</td><td>高性能场景（如框架底层）</td></tr><tr><td>Javassist</td><td>API 简单，支持源码字符串生成</td><td>需要快速开发的场景</td></tr><tr><td>动态代理</td><td>JDK 内置（仅接口），CGLIB 支持类</td><td>动态拦截方法调用（如 AOP）</td></tr><tr><td>脚本引擎</td><td>易用但需额外依赖（如 Groovy）</td><td>简化逻辑或已有脚本代码集成</td></tr></tbody></table><p>根据具体需求（灵活性、性能、易用性）选择合适的方法！</p><hr><h2 id="谈谈jvm内存区域划分-哪些区域可能发生outofmemoryerror" tabindex="-1">谈谈JVM内存区域划分，哪些区域可能发生OutOfMemoryError <a class="header-anchor" href="#谈谈jvm内存区域划分-哪些区域可能发生outofmemoryerror" aria-hidden="true">#</a></h2><h4 id="jvm内存区域划分" tabindex="-1">JVM内存区域划分 <a class="header-anchor" href="#jvm内存区域划分" aria-hidden="true">#</a></h4><p>JVM内存主要划分为以下核心区域：</p><h5 id="_1-程序计数器-program-counter-register" tabindex="-1">1. <strong>程序计数器（Program Counter Register）</strong> <a class="header-anchor" href="#_1-程序计数器-program-counter-register" aria-hidden="true">#</a></h5><ul><li><strong>作用</strong>：记录当前线程执行字节码的行号指示器</li><li><strong>特性</strong>： <ul><li>线程私有，生命周期与线程相同</li><li><strong>唯一不会发生OOM的内存区域</strong></li></ul></li></ul><h5 id="_2-虚拟机栈-jvm-stack" tabindex="-1">2. <strong>虚拟机栈（JVM Stack）</strong> <a class="header-anchor" href="#_2-虚拟机栈-jvm-stack" aria-hidden="true">#</a></h5><ul><li><strong>作用</strong>：存储方法调用的栈帧（局部变量表、操作数栈、动态链接、方法出口）</li><li><strong>特性</strong>： <ul><li>线程私有</li><li>可能出现两种错误：</li><li>❗ <code>StackOverflowError</code>（递归调用过深）</li><li>❗ <strong><code>OutOfMemoryError</code>（扩展栈空间时内存不足，如大量线程同时创建）</strong></li></ul></li><li><strong>关键参数</strong>：<code>-Xss</code>设置栈大小</li></ul><h5 id="_3-本地方法栈-native-method-stack" tabindex="-1">3. <strong>本地方法栈（Native Method Stack）</strong> <a class="header-anchor" href="#_3-本地方法栈-native-method-stack" aria-hidden="true">#</a></h5><ul><li><strong>作用</strong>：为Native方法服务（JNI调用）</li><li><strong>特性</strong>： <ul><li>线程私有</li><li>❗ <strong>类似虚拟机栈，可能抛出<code>OutOfMemoryError</code></strong></li></ul></li></ul><h5 id="_4-java堆-java-heap" tabindex="-1">4. <strong>Java堆（Java Heap）</strong> <a class="header-anchor" href="#_4-java堆-java-heap" aria-hidden="true">#</a></h5><ul><li><strong>作用</strong>：存储对象实例（几乎所有new创建的对象）</li><li><strong>特性</strong>： <ul><li>线程共享</li><li>GC主要作用区域</li><li>❗ <strong>最常发生<code>OutOfMemoryError</code>的区域</strong></li><li>典型场景：内存泄漏、加载过多数据</li></ul></li><li><strong>关键参数</strong>：<code>-Xms</code>初始堆大小, <code>-Xmx</code>最大堆大小</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Java堆OOM示例</span></span>
<span class="line"><span style="color:#C792EA;">List</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">byte</span><span style="color:#89DDFF;">[]&gt;</span><span style="color:#A6ACCD;"> list </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ArrayList</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(true)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  list</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">byte</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1024</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1024</span><span style="color:#89DDFF;">]);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 持续分配大对象</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 错误信息：java.lang.OutOfMemoryError: Java heap space</span></span>
<span class="line"></span></code></pre></div><h5 id="_5-方法区-method-area" tabindex="-1">5. <strong>方法区（Method Area）</strong> <a class="header-anchor" href="#_5-方法区-method-area" aria-hidden="true">#</a></h5><ul><li><strong>作用</strong>：存储类元信息、常量、静态变量等</li><li><strong>不同JDK版本的实现</strong>： <ul><li>JDK &lt; 1.8：永久代（PermGen） ❗ <strong><code>OutOfMemoryError: PermGen space</code></strong></li><li>JDK ≥ 1.8：元空间（Metaspace） ❗ <strong><code>OutOfMemoryError: Metaspace</code></strong></li></ul></li><li><strong>特性</strong>： <ul><li>线程共享</li><li>类加载过多/常量池溢出时触发OOM</li></ul></li><li><strong>关键参数</strong>： <code>-XX:PermSize</code>/<code>-XX:MaxPermSize</code>（永久代） <code>-XX:MetaspaceSize</code>/<code>-XX:MaxMetaspaceSize</code>（元空间）</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 元空间OOM示例（JDK8+）</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">MetaspaceOOM</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">DynamicClass</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(true)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#C792EA;">Enhancer</span><span style="color:#A6ACCD;"> enhancer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Enhancer</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">      enhancer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setSuperclass</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">DynamicClass</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">      enhancer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setUseCache</span><span style="color:#89DDFF;">(false);</span></span>
<span class="line"><span style="color:#A6ACCD;">      enhancer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setCallback</span><span style="color:#89DDFF;">((</span><span style="color:#A6ACCD;">MethodInterceptor</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> method</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> args1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> proxy</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">          proxy</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">invokeSuper</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> args1</span><span style="color:#89DDFF;">));</span></span>
<span class="line"><span style="color:#A6ACCD;">      enhancer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 动态生成类</span></span>
<span class="line"><span style="color:#A6ACCD;">      count</span><span style="color:#89DDFF;">++;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h5 id="_6-运行时常量池-runtime-constant-pool" tabindex="-1">6. <strong>运行时常量池（Runtime Constant Pool）</strong> <a class="header-anchor" href="#_6-运行时常量池-runtime-constant-pool" aria-hidden="true">#</a></h5><ul><li><strong>位置</strong>：方法区的一部分</li><li><strong>作用</strong>：存储字面量和符号引用</li><li>❗ <strong>当常量池容量超过限制时可能抛出<code>OutOfMemoryError</code></strong></li></ul><hr><h4 id="💥-可能发生outofmemoryerror的区域总结" tabindex="-1">💥 可能发生OutOfMemoryError的区域总结： <a class="header-anchor" href="#💥-可能发生outofmemoryerror的区域总结" aria-hidden="true">#</a></h4><ol><li><p><strong>Java堆</strong>（最常见）：</p><ul><li><code>java.lang.OutOfMemoryError: Java heap space</code></li><li>原因：过多对象实例 + GC无法回收</li></ul></li><li><p><strong>虚拟机栈 &amp; 本地方法栈</strong>：</p><ul><li><code>java.lang.OutOfMemoryError: unable to create new native thread</code></li><li>原因：线程栈空间累积超出系统内存</li></ul></li><li><p><strong>方法区</strong>：</p><ul><li>JDK7-：<code>java.lang.OutOfMemoryError: PermGen space</code></li><li>JDK8+：<code>java.lang.OutOfMemoryError: Metaspace</code></li><li>原因：类/常量/静态变量过量加载</li></ul></li><li><p><strong>直接内存（Direct Memory）</strong>：</p><ul><li><code>java.lang.OutOfMemoryError: Direct buffer memory</code></li><li>原因：NIO的ByteBuffer分配超出<code>-XX:MaxDirectMemorySize</code></li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 直接内存OOM示例</span></span>
<span class="line"><span style="color:#C792EA;">List</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">ByteBuffer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> buffers </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ArrayList</span><span style="color:#89DDFF;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(true)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  buffers</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ByteBuffer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">allocateDirect</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">100</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1024</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1024</span><span style="color:#89DDFF;">));</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ol><hr><h4 id="📊-关键参数配置建议" tabindex="-1">📊 关键参数配置建议： <a class="header-anchor" href="#📊-关键参数配置建议" aria-hidden="true">#</a></h4><table><thead><tr><th>内存区域</th><th>配置参数</th><th>典型场景</th></tr></thead><tbody><tr><td>Java堆</td><td><code>-Xms512m -Xmx1024m</code></td><td>Web服务优化</td></tr><tr><td>元空间</td><td><code>-XX:MaxMetaspaceSize=256m</code></td><td>动态代理框架应用</td></tr><tr><td>线程栈</td><td><code>-Xss256k</code></td><td>高并发服务</td></tr><tr><td>直接内存</td><td><code>-XX:MaxDirectMemorySize=512m</code></td><td>NIO文件传输</td></tr></tbody></table><blockquote><p>⚠️ 注意：程序计数器不会发生OOM，而是其他区域资源耗尽时的&quot;安全点&quot;记录器。</p></blockquote><hr><h2 id="如何监控和诊断jvm堆内和堆外内存使用" tabindex="-1">如何监控和诊断JVM堆内和堆外内存使用？ <a class="header-anchor" href="#如何监控和诊断jvm堆内和堆外内存使用" aria-hidden="true">#</a></h2><p>要监控和诊断JVM堆内内存（Heap）和堆外内存（Off-Heap），需要结合多种工具和方法。以下是详细指南：</p><hr><h4 id="一、堆内内存-heap-监控与诊断" tabindex="-1"><strong>一、堆内内存（Heap）监控与诊断</strong> <a class="header-anchor" href="#一、堆内内存-heap-监控与诊断" aria-hidden="true">#</a></h4><h5 id="_1-监控工具" tabindex="-1"><strong>1. 监控工具</strong> <a class="header-anchor" href="#_1-监控工具" aria-hidden="true">#</a></h5><ul><li><strong>JDK内置工具</strong>： <ul><li><strong><code>jcmd</code></strong>（推荐）：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">jcmd</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">pi</span><span style="color:#A6ACCD;">d</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">GC.heap_info</span><span style="color:#A6ACCD;">       </span><span style="color:#676E95;font-style:italic;"># 查看堆摘要</span></span>
<span class="line"><span style="color:#FFCB6B;">jcmd</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">pi</span><span style="color:#A6ACCD;">d</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">GC.class_histogram</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;"># 查看类实例统计</span></span>
<span class="line"></span></code></pre></div></li><li><strong><code>jstat</code></strong>（实时监控）：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">jstat</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-gc</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">pi</span><span style="color:#A6ACCD;">d</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#A6ACCD;">        </span><span style="color:#676E95;font-style:italic;"># 每1秒输出一次GC情况（Eden/Survivor/Old区使用量、GC次数/时间）</span></span>
<span class="line"></span></code></pre></div></li><li><strong><code>jmap</code></strong>（生成堆快照）：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">jmap</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-dump:format=b,file=heapdump.hprof</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">pi</span><span style="color:#A6ACCD;">d</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;"># 生成Heap Dump</span></span>
<span class="line"><span style="color:#FFCB6B;">jmap</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-histo</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">pi</span><span style="color:#A6ACCD;">d</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">                             </span><span style="color:#676E95;font-style:italic;"># 直方图统计活跃对象</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><strong>图形化工具</strong>： <ul><li><code>jconsole</code> / <code>VisualVM</code>：实时查看堆内存、GC活动、线程状态。</li><li><strong>Eclipse MAT</strong>（Memory Analyzer Tool）：分析Heap Dump，定位内存泄漏（如Retained Heap大的对象）。</li></ul></li><li><strong>生产环境推荐</strong>： <ul><li><strong>Prometheus + Grafana</strong>：通过<a href="https://github.com/prometheus/jmx_exporter" target="_blank" rel="noreferrer">JMX Exporter</a>采集JVM监控指标（堆使用率、GC时间等），可视化展示。</li></ul></li></ul><h5 id="_2-诊断步骤" tabindex="-1"><strong>2. 诊断步骤</strong> <a class="header-anchor" href="#_2-诊断步骤" aria-hidden="true">#</a></h5><ol><li><strong>观察堆内存趋势</strong>：通过<code>jstat</code>或监控系统检查堆内存是否持续增长。</li><li><strong>生成Heap Dump</strong>：在内存异常时使用<code>jmap</code>或<code>jcmd GC.heap_dump</code>生成快照。</li><li><strong>分析泄漏根源</strong>： <ul><li>用MAT分析Heap Dump，检查<code>Dominator Tree</code>，找到占用最大的对象。</li><li>检查强引用（如静态集合类缓存导致对象无法回收）。</li></ul></li></ol><hr><h4 id="二、堆外内存-off-heap-监控与诊断" tabindex="-1"><strong>二、堆外内存（Off-Heap）监控与诊断</strong> <a class="header-anchor" href="#二、堆外内存-off-heap-监控与诊断" aria-hidden="true">#</a></h4><p>堆外内存包括：</p><ul><li><strong>Direct ByteBuffer</strong>（NIO直接缓冲区）</li><li><strong>JNI分配的内存</strong></li><li><strong>Metaspace</strong>（类元数据）</li><li><strong>线程栈（Thread Stack）</strong></li><li><strong>Code Cache</strong>（JIT编译代码）</li></ul><h5 id="_1-监控工具-1" tabindex="-1"><strong>1. 监控工具</strong> <a class="header-anchor" href="#_1-监控工具-1" aria-hidden="true">#</a></h5><ul><li><strong>Native Memory Tracking (NMT)</strong>： 启用NMT（需重启JVM）：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">java</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-XX:NativeMemoryTracking=summary</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-XX:+UnlockDiagnosticVMOptions</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-XX:+PrintNMTStatistics</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">...</span></span>
<span class="line"></span></code></pre></div>运行时监控：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">jcmd</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">pi</span><span style="color:#A6ACCD;">d</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">VM.native_memory</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">summary</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;"># 获取摘要</span></span>
<span class="line"><span style="color:#FFCB6B;">jcmd</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">pi</span><span style="color:#A6ACCD;">d</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">VM.native_memory</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">detail</span><span style="color:#A6ACCD;">     </span><span style="color:#676E95;font-style:italic;"># 详细报告（包括Direct Buffer）</span></span>
<span class="line"></span></code></pre></div></li><li><strong>操作系统工具</strong>： <ul><li><strong><code>pmap</code></strong>（Linux）：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">pmap</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-X</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">pi</span><span style="color:#A6ACCD;">d</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">less</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;"># 查看进程内存映射，关注[anon]区块</span></span>
<span class="line"></span></code></pre></div></li><li><strong><code>top</code>/<code>htop</code></strong>：通过<code>RES</code>（物理内存）与堆内存差值观察堆外内存。</li><li><strong><code>/proc/&lt;pid&gt;/smaps</code></strong>：分析内存区域的明细。</li></ul></li><li><strong>JVM参数</strong>：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-XX:MaxDirectMemorySize=256m</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;"># 限制Direct Buffer大小</span></span>
<span class="line"></span></code></pre></div></li></ul><h5 id="_2-诊断步骤-1" tabindex="-1"><strong>2. 诊断步骤</strong> <a class="header-anchor" href="#_2-诊断步骤-1" aria-hidden="true">#</a></h5><ol><li><strong>确认堆外内存泄漏</strong>： <ul><li>使用<code>top</code>查看Java进程的<code>RES</code>持续增长，但堆内存（通过<code>jstat</code>观察）稳定。</li><li>对比堆内存 + Metaspace + Code Cache用量与<code>RES</code>的差值。</li></ul></li><li><strong>定位泄漏源头</strong>： <ul><li><strong>Direct ByteBuffer泄漏</strong>： <ul><li>使用NMT检查<code>Internal (malloc)</code>或<code>Direct</code>内存增长。</li><li>通过反射获取<code>DirectByteBuffer</code>分配信息：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Class</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">?</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> c </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Class</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">forName</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">java.nio.Bits</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#C792EA;">Field</span><span style="color:#A6ACCD;"> maxMemory </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> c</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getDeclaredField</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">maxMemory</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">maxMemory</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setAccessible</span><span style="color:#89DDFF;">(true);</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Max Direct Memory: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> maxMemory</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getLong</span><span style="color:#89DDFF;">(null));</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><strong>JNI泄漏</strong>：检查JNI代码中<code>malloc</code>/<code>new</code>后是否调用<code>free</code>/<code>delete</code>。</li><li><strong>线程栈泄漏</strong>：线程过多导致（通过<code>jstack &lt;pid&gt;</code>检查线程数）。</li></ul></li></ol><hr><h4 id="三、通用最佳实践" tabindex="-1"><strong>三、通用最佳实践</strong> <a class="header-anchor" href="#三、通用最佳实践" aria-hidden="true">#</a></h4><ol><li><strong>启动监控参数</strong>：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-XX:+UseGCLogFileRotation</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-XX:NumberOfGCLogFiles=3</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-XX:GCLogFileSize=50M</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-Xloggc:/logs/gc.log</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;"># GC日志</span></span>
<span class="line"><span style="color:#FFCB6B;">-XX:NativeMemoryTracking=detail</span><span style="color:#A6ACCD;">      </span><span style="color:#676E95;font-style:italic;"># NMT详细模式</span></span>
<span class="line"><span style="color:#FFCB6B;">-XX:+HeapDumpOnOutOfMemoryError</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-XX:HeapDumpPath=/logs/oom.hprof</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;"># OOM时自动Dump</span></span>
<span class="line"></span></code></pre></div></li><li><strong>内存分析流程</strong>： <ul><li>堆内存问题 → Heap Dump → MAT分析 → 定位泄露对象。</li><li>堆外内存问题 → NMT/pmap → 区分类型（Direct Buffer/JNI/其他）→ 代码审查。</li></ul></li><li><strong>第三方工具</strong>： <ul><li><strong>Apache SkyWalking</strong> / <strong>Pinpoint</strong>：分布式跟踪中集成JVM监控。</li><li><strong>Netflix</strong>的<code>JavaMemShell</code>：脚本化内存分析。</li><li><strong>gperftools</strong>（仅Linux）：分析Native内存分配热点。</li></ul></li></ol><hr><h4 id="四、常见内存溢出场景" tabindex="-1"><strong>四、常见内存溢出场景</strong> <a class="header-anchor" href="#四、常见内存溢出场景" aria-hidden="true">#</a></h4><table><thead><tr><th>内存类型</th><th>错误信息</th><th>解决方法</th></tr></thead><tbody><tr><td><strong>堆内存</strong></td><td><code>java.lang.OutOfMemoryError: Java heap space</code></td><td>增大<code>-Xmx</code>或修复内存泄露</td></tr><tr><td><strong>Metaspace</strong></td><td><code>java.lang.OutOfMemoryError: Metaspace</code></td><td>增大<code>-XX:MaxMetaspaceSize</code></td></tr><tr><td><strong>堆外直接内存</strong></td><td><code>java.lang.OutOfMemoryError: Direct buffer memory</code></td><td>限制<code>-XX:MaxDirectMemorySize</code>、检查Buffer释放</td></tr><tr><td><strong>堆外（JNI）</strong></td><td><code>java.lang.OutOfMemoryError: malloc failed</code></td><td>修复Native代码内存泄露</td></tr></tbody></table><hr><p>通过以上工具和方法，可全面监控JVM内外内存使用，快速定位问题根源。<strong>堆内存重点在于Heap Dump分析，堆外内存依赖NMT结合操作系统工具排查</strong>。</p><hr><h2 id="谈谈你的jvm-gc调优思路" tabindex="-1">谈谈你的JVM GC调优思路 <a class="header-anchor" href="#谈谈你的jvm-gc调优思路" aria-hidden="true">#</a></h2><p>好的，谈谈 JVM GC 调优的思路。GC 调优的核心目标是<strong>在满足应用程序性能需求的前提下，最小化垃圾收集的开销</strong>。这通常涉及到权衡<strong>吞吐量</strong>（应用程序执行有效代码的时间比例）、<strong>延迟</strong>（GC 引起的停顿时间，特别是 STW 停顿）以及<strong>内存占用</strong>。</p><p>这是一个系统性的过程，没有放之四海而皆准的“最佳配置”。以下是我的优化思路和关键步骤：</p><h4 id="📊-核心原则与指导思想" tabindex="-1">📊 核心原则与指导思想 <a class="header-anchor" href="#📊-核心原则与指导思想" aria-hidden="true">#</a></h4><ol><li><strong>优先理解应用，而非盲目调参：</strong> GC 是应用的“消费者”，它的行为模式由应用的<strong>对象创建速率、对象生命周期分布、存活对象集大小</strong>等决定。</li><li><strong>目标驱动：</strong> 调优前必须明确目标（如：降低 Young GC 停顿时间至 20ms 以内、消除 Full GC、提高吞吐量到 98%等）。不同目标对应的优化方向可能完全不同。</li><li><strong>数据驱动：</strong> 调优必须建立在<strong>监控</strong>和<strong>分析</strong>的基础上。没有数据支撑的调优是赌博。</li><li><strong>循序渐进而非一步到位：</strong> 遵循“观测 -&gt; 假设 -&gt; 调整 -&gt; 验证 -&gt; 重复”的循环过程。每次只调整少量参数。</li><li><strong>避免过度调优：</strong> 默认配置在大多数情况下表现良好。只有当性能问题明确指向 GC 时，再进行针对性调优。</li><li><strong>理解收集器机制：</strong> 你必须熟悉你使用的 GC 收集器的核心算法、停顿点、优缺点（如 Serial, Parallel, CMS, G1, ZGC, Shenandoah）。不同收集器的调优参数和思路差异很大。</li><li><strong>关注系统层面：</strong> GC 性能受操作系统（swap, NUMA）、硬件（CPU core/频, RAM 速度/带宽）、JVM Native Memory 使用等多方面影响。考虑 <code>-XX:+UseLargePages</code>, <code>-XX:+AlwaysPreTouch</code> 等优化系统交互的参数。</li></ol><hr><h4 id="🔧-jvm-gc-调优的具体步骤与方法要点" tabindex="-1">🔧 JVM GC 调优的具体步骤与方法要点 <a class="header-anchor" href="#🔧-jvm-gc-调优的具体步骤与方法要点" aria-hidden="true">#</a></h4><h5 id="🔍-一、-建立基准-进行监控-gather-data" tabindex="-1">🔍 一、 建立基准 &amp; 进行监控（Gather Data） <a class="header-anchor" href="#🔍-一、-建立基准-进行监控-gather-data" aria-hidden="true">#</a></h5><ul><li><strong>开启必要的日志参数：</strong><ul><li><strong>核心参数：</strong> 必须始终开启生产日志收集！ <ul><li><code>-XX:+PrintGCDetails</code></li><li><code>-XX:+PrintGCDateStamps</code>（或 <code>PrintGCTimeStamps</code>）</li><li><code>-XX:+PrintHeapAtGC</code>（可选，对 Full GC 根因诊断非常有用）</li><li><code>-Xloggc:&lt;file_location&gt;</code>（指定日志文件位置）</li></ul></li><li><strong>高级诊断：</strong><ul><li><code>-XX:+PrintPromotionFailure</code>（诊断晋升失败导致提前 Full GC）</li><li><code>-XX:+PrintTenuringDistribution</code>（查看晋升年龄分布）</li><li><code>-XX:+PrintReferenceGC</code>（诊断 FinalReference，SoftReference 等导致的停顿）</li><li><code>-XX:+HeapDumpOnOutOfMemoryError</code>（OOM 时自动生成堆转储）</li></ul></li></ul></li><li><strong>使用实时监控工具观察：</strong><ul><li><strong>JVM 自带工具：</strong><ul><li><strong><code>jstat -gcutil &lt;pid&gt; &lt;interval&gt; &lt;count&gt;</code>：</strong> 最常用，实时看各个内存区域利用率、GC次数/时间统计、晋升速率等。</li><li><strong><code>jstat -gccause &lt;pid&gt;</code>：</strong> 快速查看最近一次 GC 的原因。非常实用！</li><li><strong><code>jstat -printcompilation</code>：</strong> 查看 JIT 编译情况（如果 GC 频繁打断 JIT 会影响整体性能）。</li><li><strong><code>jmap -heap &lt;pid&gt;</code> / <code>jmap -histo:live &lt;pid&gt;</code>：</strong> 生成堆内存信息/直方图（谨慎使用 <code>-histo:live</code>，会触发 Full GC！）。</li><li><strong>VisualVM / JConsole：</strong> 图形化监控堆、元空间、线程、GC活动等。适合初步查看。</li></ul></li><li><strong>更强大的第三方工具：</strong><ul><li><strong><code>jcmd &lt;pid&gt; GC.heap_dump</code>：</strong> 安全生成堆转储，不触发 Full GC。</li><li><strong>Visual GC（VisualVM Plugin）:</strong> 图形化展示 Young/Old/Metaspace GC 活动、内存池变化趋势。</li><li><strong>Java Flight Recorder (JFR)：</strong> JDK 内置的强大轻量级剖析和事件收集工具。提供极其详尽的 GC 相关信息、对象分配火焰图等。需 <code>-XX:+UnlockCommercialFeatures</code>（在付费许可下）或 JDK 11+ 使用开源版本。</li><li><strong><code>vjtools</code> / <code>jvmtop</code> / <code>pmap</code> / <code>jstack</code>：</strong> 查看 Java/Native 内存，线程栈等。</li><li>专业的 APM/日志聚合工具：如 Dynatrace, AppDynamics, New Relic, Elastic stack (Filebeat + ELK/Grafana), Prometheus + Grafana（结合 jmx_exporter）。用于存储、聚合、可视化历史 GC 日志和度量指标。</li></ul></li></ul></li><li><strong>分析 GC 日志：</strong><ul><li>使用工具（如 <code>GCViewer</code>, <code>gceasy.io</code>, <code>Grafana with Prometheus</code>, <code>camelot</code>）解析 GC 日志：获取详细的暂停时间列表（平均/最大/P95/P99），吞吐量，内存使用趋势、分配/晋升速率、回收效率、GC原因统计等。</li><li>特别关注：<strong>Stop-The-World (STW) 停顿时间</strong>、<strong>Young GC 频率</strong>、 <strong>Full GC 频率/时长/原因</strong>（是 System.gc() 调用，还是晋升失败、自适应失败、并发模式失败等）。</li></ul></li></ul><h5 id="🧩-二、-优化基础内存配置-foundation" tabindex="-1">🧩 二、 优化基础内存配置（Foundation） <a class="header-anchor" href="#🧩-二、-优化基础内存配置-foundation" aria-hidden="true">#</a></h5><ul><li><strong>设置合适的堆大小 (<code>-Xms/-Xmx</code>)：</strong><ul><li>初始值设相等 (<code>-Xms=Xmx</code>) 以避免运行时伸缩造成的开销。</li><li>大小不是越大越好！ <ul><li><strong>过小 → 频繁 GC 且易 OOM。</strong></li><li><strong>过大 →：</strong><ul><li>单次 Young GC 遍历活对象时间变长（虽然频率低），可能导致较长停顿。</li><li>Full GC 停顿时间可能极长（与存活对象集大小和算法相关）</li><li>影响系统整体性能（OS 可能频繁 swap）。</li></ul></li></ul></li><li><strong>建议：</strong> 基于监控数据和预期目标配置。目标是让 GC 频率保持在可接受范围内，让 Old Gen/Full GC 不频繁发生（除非使用了 ZGC/Shenandoah），且每次回收效率足够高。</li></ul></li><li><strong>设置合适的新生代大小 (<code>-Xmn</code> 或比例控制</strong>): <ul><li>直接影响 <strong>Young GC 频率</strong> 和 <strong>单次 Young GC 停顿时间</strong>。</li><li><strong>过大 →：</strong><ul><li>Young GC 频率低，但单次停顿时间可能变长（需要遍历大量年轻代对象）。</li><li>可能导致晋升速率变慢（对象有更多时间在年轻代“死掉”）。</li><li>Old Gen 相对变小，可能更容易触发 Full GC（如果使用 CMS/G1）或 Mixed GC（G1）。</li></ul></li><li><strong>过小 →：</strong><ul><li>Young GC 非常频繁。</li><li>晋升速率变快（对象更快被移到老年代），可能导致老年代更快填满、过早触发 Full GC/Mixed GC。</li></ul></li><li><strong>建议：</strong><ul><li><strong>关注晋升速率/年龄分布 (<code>jstat -gcutil</code>, 日志 <code>PrintTenuringDistribution</code>)</strong>。理想的晋升速率是稳定的、缓慢的（大部分对象在年轻代就被回收）。</li><li>调整 <code>-XX:NewRatio</code> 或显式指定 <code>-Xmn</code></li><li>目标是在可接受的 Young GC 频率下，尽量让短的 Young GC 停顿发生，并提供足够的空间缓冲晋升。</li></ul></li></ul></li><li><strong>设置合适的老年代大小：</strong> 堆大小减去年轻代大小就是老年代大小。</li><li><strong>合理设置 Survivor Spaces (S0, S1) 大小：</strong> 通过 <code>-XX:SurvivorRatio=N</code> 设置 Eden:S0:S1 = N:1:1。太大浪费（对象在幸存区“旅居”时间变短），太小可能导致存活对象提前晋升老年代。可用 <code>-XX:+UseAdaptiveSizePolicy</code> 或 <code>-XX:TargetSurvivorRatio</code>（如 <code>-XX:TargetSurvivorRatio=70</code>，默认50）来自动/手动调整 Survivor 区域的利用率。核心是减少不必要的晋升（Minor GC 后活下的对象应该尽可能留在 Survivor）。</li><li><strong>设置合适的元空间大小 (<code>-XX:MetaspaceSize/-XX:MaxMetaspaceSize</code>)：</strong><ul><li><code>MetaspaceSize</code> 是初始值，<code>MaxMetaspaceSize</code> 是上限。</li><li>设置过小可能导致频繁的 <code>Full GC</code>（即使老年代还有空间）来卸载类或调整元空间容量（如果是 CMS/Parallel）。</li><li>设置过大占用额外 Native Memory。</li></ul></li><li><strong>优化系统交互：</strong><ul><li><code>-XX:ReservedCodeCacheSize</code>: 适当增大方法 JIT 编译后的本地代码缓存区大小。</li><li><code>-XX:+UseLargePages / -XX:+UseTransparentHugePages</code>: 减少 TLB Miss，提高内存访问效率。需要 OS 支持并配置好大页（如 <code>Transparent Huge Pages</code>）。</li><li><code>-XX:+AlwaysPreTouch</code>: 启动时预 touch 所有申请的堆内存。避免运行时 page fault 引入延迟。启动变慢，运行时更稳定。</li><li><code>-XX:+UseNUMA</code>: 在 NUMA 架构服务器上启用，提高内存访问局部性。</li></ul></li></ul><h5 id="⚙-三、-选择合适的垃圾收集器-select-the-right-collector" tabindex="-1">⚙ 三、 选择合适的垃圾收集器（Select the Right Collector） <a class="header-anchor" href="#⚙-三、-选择合适的垃圾收集器-select-the-right-collector" aria-hidden="true">#</a></h5><ul><li><strong>JDK8及以前主流选择：</strong><ul><li><strong><code>Serial</code> (+ <code>Serial Old</code>)：</strong> 单线程，停顿时间长。适合微服务/client端/嵌入式。参数 <code>-XX:+UseSerialGC</code>。</li><li><strong><code>Parallel</code> / <code>Throughput</code> Collector (+ <code>Parallel Old</code>)：</strong> 多线程 Young/Old GC，追求 <strong>最大化吞吐量</strong>（GC 总时间尽可能短）。默认收集器。对延迟不敏感的应用首选。参数 <code>-XX:+UseParallelGC -XX:+UseParallelOldGC</code>。</li><li><strong><code>Concurrent Mark-Sweep</code> (+ <code>ParNew</code>)：</strong> Young GC并行（ParNew），Old GC大部分阶段并发（CMS），试图 <strong>缩短最长停顿时间</strong>（避免长时间 Full GC）。适合内存较大、对延迟敏感、能容忍碎片化的应用。注意 <strong>Concurrent Mode Failure</strong> 风险（未完成并发回收时老年代无空间了，需要 STW Full GC）。参数 <code>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC</code>。</li></ul></li><li><strong>JDK9 及以后默认/主流选择 (特别是 JDK11+):</strong><ul><li><strong><code>Garbage-First (G1) - Default in JDK9+</code>：</strong> 分区垃圾收集器。追求 <strong>可控的停顿时间目标</strong>（<code>-XX:MaxGCPauseMillis</code>）。将堆划分为多个大小相等的 Region（<code>-XX:G1HeapRegionSize</code>）。核心阶段：Young GC 在 Eden Regions 中进行（STW），Concurrent Marking（并发标记）, Mixed GC（同时回收年轻代和老年代 Region，STW）。适合大堆 (&gt;4-6GB) 和对延迟有一定要求的应用。优化重点在于避免 Full GC（在 <code>-XX:+ExplicitGCInvokesConcurrent</code> 配合下，<code>System.gc()</code> 也是并发）。</li><li><strong><code>ZGC</code>：</strong> 革命性的低延迟收集器（JDK11+ 生产可用, 15+ 非实验）。主要目标是将 <strong>STW 停顿控制在亚毫秒级别（&lt;10ms）, 几乎与堆大小无关</strong>。核心技术：着色指针 (Colored Pointers)、读屏障、并发引用处理/重定位。适合超大堆 (&gt;TB 级) 和极度敏感的延迟要求（如金融交易）。开启 <code>-XX:+UseZGC</code>。</li><li><strong><code>Shenandoah</code>：</strong> 类似 ZGC 的低延迟目标（由 Red Hat 开发贡献）。核心技术：Brooks指针（Forwarding Pointer）、读+写屏障、并发引用处理/重定位。提供更好的短期暂停时间保证（ZGC 暂停时间相对更稳定）。JDK12+ 正式可用。开启 <code>-XX:+UseShenandoahGC</code>。</li></ul></li><li><strong>选择依据：</strong><ul><li><strong>堆大小：</strong> 小堆 (&lt;4G) 可选 Serial/CMS/Parallel/G1; 中大堆 (&gt;4-8G) 可选 CMS/G1/ZGC/Shenandoah; 超大堆 (&gt;&gt;100G) 优先 ZGC/Shenandoah。</li><li><strong>性能目标：</strong><ul><li>吞吐量优先 → Parallel Collector。</li><li>延迟敏感（几十毫秒）→ CMS（已移）/G1。</li><li>极致延迟（&lt;10ms/亚毫秒），堆不限 → ZGC/Shenandoah。</li></ul></li><li><strong>系统开销容忍度：</strong> ZGC/Shenandoah 使用屏障技术，会有额外 CPU/内存开销（读屏障、Store Buffer），吞吐量可能稍逊于Parallel/G1。评估应用负载是否可接受。</li><li><strong>JDK 版本限制：</strong> ZGC/Shenandoah需要较新的JDK版本支持。</li></ul></li></ul><h5 id="🛠-四、-针对具体收集器进行参数微调-fine-tune-for-specific-collector" tabindex="-1">🛠 四、 针对具体收集器进行参数微调（Fine-tune for Specific Collector） <a class="header-anchor" href="#🛠-四、-针对具体收集器进行参数微调-fine-tune-for-specific-collector" aria-hidden="true">#</a></h5><ul><li><strong>Parallel Collector:</strong><ul><li><code>-XX:ParallelGCThreads=N</code>: 设定用于Young/Old GC的并行线程数（通常建议设置为<strong>物理核心数</strong>）。</li><li><code>-XX:MaxGCPauseMillis=M (不强制) / -XX:GCTimeRatio=N</code>: 默认更关注吞吐量(GCTimeRatio)。如果设定了MaxGCPause，JVM会自动调整年轻代大小来实现（可能牺牲吞吐量）。</li></ul></li><li><strong>CMS Collector (逐渐被替代)：</strong><ul><li><code>-XX:CMSInitiatingOccupancyFraction=&lt;P&gt;</code>: 设置老年代空间使用率阈值（默认92%），触发Concurrent Marking。过低 (频繁 Concurrent Mark) → CPU消耗高；过高→Concurrent Mode Failure 风险高。<strong>极其关键！</strong></li><li><code>-XX:+UseCMSInitiatingOccupancyOnly</code>: 保证只使用 <code>CMSInitiatingOccupancyFraction</code> 参数，禁用自适应调整启动占用率行为。</li><li><code>-XX:CMSFullGCsBeforeCompaction=N</code>: 在发生 N 次 Full GC 后才进行压缩碎片整理（0表示每次都压缩）。</li><li><code>-XX:+CMSParallelInitialMarkEnabled / -XX:+CMSParallelRemarkEnabled</code>: 开启初始标记和并发再标记的多线程并行。</li><li><code>-XX:+CMSScavengeBeforeRemark</code>: 在重新标记前进行一次 Young GC 以减少 Old Gen的引用链（减少 Remark 阶段停顿时间）。</li><li><code>-XX:+IgnoreUnrecognizedVMOptions -XX:-CMSConcurrentMTEnabled</code>：关闭CMS并发线程模式（避免特定BUG）。<strong>仅限经验丰富者操作。</strong></li></ul></li><li><strong>G1 Collector:</strong><ul><li><strong>核心目标参数：</strong><ul><li><code>-XX:MaxGCPauseMillis=&lt;N&gt;</code>: G1 <strong>努力</strong>达到的暂停时间目标（毫秒）。不是硬性保证！<strong>最重要且通常首先调整的参数</strong>。G1会根据此目标自动调整 Region 大小、晋升年龄等。设置太激进（过低）可能导致更高的 CPU 消耗和更低的吞吐量（频繁/无效的 GC）；设置太保守（过高）可能导致老年代来不及回收而发生 Full GC。</li></ul></li><li><strong>内存/Region设置：</strong><ul><li><code>-XX:InitiatingHeapOccupancyPercent=&lt;P&gt;</code>: 触发并发标记周期的整堆占用率阈值（默认45%）。如果并发周期启动太晚可能导致 Mixed GC 来不及回收空间而发生 Evacuation Failure-&gt;Full GC。监控并发启动时间点。</li></ul></li><li><strong>并发/并行线程数：</strong><ul><li><code>-XX:ConcGCThreads=N</code>: 并发标记阶段使用的线程数（如暂停目标严格，可适当增加，但注意并发阶段CPU消耗）。</li><li><code>-XX:ParallelGCThreads=N</code>: STW 阶段（Young/Mixed GC）使用的并行线程数（通常建议等于物理核心数）。</li></ul></li><li><strong>GC效率选项：</strong><ul><li><code>-XX:+G1RSetUpdatingPauseTimePercent &amp; -XX:G1RSetRegionEntries</code>: 优化 RememberedSet (RS) 维护的开销，影响Mixed GC效率。</li><li><code>-XX:G1MixedGCLiveThresholdPercent / -XX:G1HeapWastePercent / -XX:G1MixedGCCountTarget</code>: 控制Mixed GC阶段选择老年代Region的阈值（存活率过高/过低的不值得回收）、可以容忍的堆空间浪费比例、以及尝试达到暂停目标所需的Mixed GC次数。</li><li><code>-XX:+G1ConcurrentRefinementThreads</code>: 并发处理日志缓冲区线程数（影响停顿时间）。</li></ul></li><li><strong>避免 Full GC：</strong><ul><li><code>-XX:+ExplicitGCInvokesConcurrent</code>: 使 <code>System.gc()</code> 触发一次 Concurrent Marking Cycle （而不是 STW Full GC）— <strong>强烈建议开启！</strong></li><li><code>-XX:ParallelRefProcEnabled=true</code>: 并行处理引用对象(FinalReference, SoftRef)。</li></ul></li></ul></li><li><strong>ZGC / Shenandoah:</strong><ul><li><strong>低延迟目标：</strong><ul><li>主要是设置目标暂停时间（ZGC: <code>-XX:MaxGCPauseMillis=M</code>，Shenandoah: <code>-XX:ShenandoahTargetMaxPause=N</code>）。默认已经很低。</li></ul></li><li><strong>负载控制：</strong><ul><li>这类收集器并发工作阶段非常激进（目标是尽快完成任务），会占用更多的 CPU（对吞吐量有影响）。</li><li>关注系统整体 CPU 利用率和负载。</li></ul></li><li><strong>Region/TLAB：</strong><ul><li>ZGC：<code>-XX:ConcGCThreads</code>/<code>-XX:ParallelGCThreads</code>，<code>-XX:TLEADivisionSize</code>(TLAB相关）。</li><li>Shenandoah：<code>-XX:ShenandoahConcGCThreads</code>/<code>-XX:ShenandoahParallelGCThreads</code>。</li></ul></li><li><strong>其他优化：</strong><ul><li>ZGC：<code>-XX:SoftMaxHeapSize</code>（用于在内存紧张时更早触发 GC 释放内存给 OS）。</li><li>两者都可开启 <code>-XX:+UseLargePages</code> 和 <code>-XX:+UseNUMA</code>。</li></ul></li><li>这两者调优相对简单（默认配置已经很激进），主要关注监控和资源占用是否合理。</li></ul></li></ul><h5 id="🧪-五、-高级诊断与特定问题解决-troubleshooting-specific-issues" tabindex="-1">🧪 五、 高级诊断与特定问题解决（Troubleshooting Specific Issues） <a class="header-anchor" href="#🧪-五、-高级诊断与特定问题解决-troubleshooting-specific-issues" aria-hidden="true">#</a></h5><ul><li><strong>频繁 Full GC：</strong><ul><li><strong>原因：</strong><ul><li>内存泄漏（Old Gen 被无意义长期持有的对象填满）-- <strong>最常见根本原因！</strong></li><li>年轻代设置不合理 → 对象过快升到老年代（短命长存）。</li><li>CMS/G1: Concurrent Mode Failure/Evacuation Failure（并发收集期间老年代无空间）。</li><li><code>System.gc()</code> 被调用（尤其未加 <code>-XX:+DisableExplicitGC</code> 或 <code>-XX:+ExplicitGCInvokesConcurrent</code>）。</li><li>元空间太小。</li><li>应用突然负载飙升（产生大量对象）。</li></ul></li><li><strong>解决：</strong><ol><li>分析堆转储 (<code>jmap -dump</code>, MAT / Eclipse Memory Analyzer)，找出内存泄漏点。</li><li>检查 GC 日志，确定 Full GC 原因 (<code>-XX:+PrintGCDetails</code> 或 <code>jstat -gccause</code>)。</li><li>调整年轻代/晋升设置 (<code>-Xmn</code>, <code>-XX:SurvivorRatio</code>, <code>-XX:MaxTenuringThreshold</code>, <code>-XX:TargetSurvivorRatio</code>)。</li><li>优化 CMS 启动阈值 (<code>-XX:CMSInitiatingOccupancyFraction</code>)，确保并发标记提前启动。</li><li>避免 <code>System.gc()</code>（使用系统参数屏蔽或转换为并发 GC）。</li><li>确保元空间设置合理 (<code>-XX:MetaspaceSize/-XX:MaxMetaspaceSize</code>)。</li><li>避免在非预期时段执行大量数据加载。</li></ol></li></ul></li><li><strong>Young GC 停顿时间长：</strong><ul><li>年轻代太大 → 需要复制太多的存活对象。适当减小年轻代 (<code>-Xmn</code>) 或增加 GC 线程数 (<code>-XX:ParallelGCThreads</code>)。</li><li>对象晋升率过高 → 很多“长寿”对象需要复制到 Survivor/老年代 → 增加 Survivor 空间 (<code>-XX:SurvivorRatio</code>) 或调整晋升年龄阈值 (<code>-XX:MaxTenuringThreshold</code>) 或检查应用对象分配模式。</li></ul></li><li><strong>CMS Concurrent Mode Failure (JDK &lt;14):</strong><ul><li>并发标记启动太晚 (<code>-XX:CMSInitiatingOccupancyFraction</code> 设置过高）或回收速度赶不上对象分配/晋升速度。</li><li><strong>解决：</strong> 降低 <code>-XX:CMSInitiatingOccupancyFraction</code> (如从70-&gt;60%)，检查晋升是否过多（优化年轻代设置）。</li></ul></li><li><strong>G1 Evacuation Failure / To-space exhausted:</strong><ul><li>Mixed GC 期间无法找到足够空闲 Region 容纳存活对象（晋升目标空间不足）。</li><li><strong>原因：</strong> 通常因并发周期启动太晚 (<code>-XX:InitiatingHeapOccupancyPercent</code> 过高）或 Mixed GC 来不及回收，或幸存者区溢出。也可能因元空间满引起 Full GC。</li><li><strong>解决：</strong> 降低 <code>-XX:InitiatingHeapOccupancyPercent</code> (如从45-&gt;35%), 增大年轻代（有风险！需平衡），检查对象分配是否异常或泄漏。</li></ul></li><li><strong>高 CPU 占用（尤其 GC线程)：</strong><ul><li>GC 非常频繁（如 Young Gen 过小）。</li><li>并发收集器（CMS/G1/ZGC/SH）长时间处于并发周期，与应用争抢 CPU (尤其 <code>ConcGCThreads</code> 设置过高)。</li><li>查看 <code>jstack</code> 或 JFR 的 Flame Graph 确定 GC 线程的 CPU 占比。</li></ul></li><li><strong>内存碎片化（CMS/G1)：</strong><ul><li>频繁 Full GC（CMS <code>-XX:+UseCMSCompactAtFullCollection</code> / <code>-XX:CMSFullGCsBeforeCompaction</code>）。</li><li>G1 <code>Full GC (Allocation Failure)</code> 会压缩，但应尽量避免进入 Full GC。监控堆利用率与堆碎片相关的指标（如有）。</li></ul></li><li><strong>Finalization 导致的停顿：</strong><ul><li>大量的 <code>FinalReference</code> 导致 Finalizer 线程阻塞（<code>ReferenceQueue</code> 满）或在 GC 的引用处理环节阻塞。</li><li><code>-XX:+PrintReferenceGC</code> 查看耗时。<strong>最佳实践是避免使用 <code>finalize()</code> 方法！</strong></li></ul></li></ul><h5 id="✅-六、-验证与迭代-validate-and-iterate" tabindex="-1">✅ 六、 验证与迭代（Validate and Iterate） <a class="header-anchor" href="#✅-六、-验证与迭代-validate-and-iterate" aria-hidden="true">#</a></h5><ol><li><strong>压力测试：</strong> 使用 <strong>JMeter</strong>, <strong>Gatling</strong>, <strong>wrk</strong>, <strong>Locust</strong> 等工具模拟线上流量模式（最好包括高峰流量）。</li><li><strong>长稳测试：</strong> 进行长时间（如24h+）的压力测试，监控内存泄漏迹象（堆内Old Gen 使用持续缓慢增长）、Full GC 频率是否归零。</li><li><strong>观察实时指标：</strong> 用 <code>jstat</code>, VisualVM, Prometheus+Grafana 等实时观察 GC 活动、停顿时间、堆利用率、CPU等。</li><li><strong>分析新 GC 日志：</strong> 使用相同/升级过的工具分析新日志，对比调优前后的性能（停顿时间、吞吐量、Full GC次数）。</li></ol><hr><h4 id="📝-总结-checklist-要点" tabindex="-1">📝 总结 Checklist 要点 <a class="header-anchor" href="#📝-总结-checklist-要点" aria-hidden="true">#</a></h4><ol><li><strong>明确目标（优先级！）</strong>：低延迟？高吞吐？小内存？</li><li><strong>开启详细日志</strong>：基础+进阶的必开参数。生产环境必须保留日志！</li><li><strong>建立监控视图</strong>：<code>jstat</code> + 日志分析工具 + APM/指标平台。</li><li><strong>理解应用的内存行为</strong>：分配速率、存活集大小、对象寿命分布。</li><li><strong>设定合理堆/元空间大小</strong>：<code>-Xms=Xmx</code>，避免过大过小。</li><li><strong>调整好年轻代结构</strong>：大小 (<code>-Xmn</code>/Ratio)、Survivor区 (<code>SurvivorRatio</code>, <code>TargetSurviorRatio</code>)、晋升阈值 (<code>MaxTenuringThreshold</code>）。</li><li><strong>精选GC算法</strong>：根据目标选择并熟悉其特征（Parallel(吞吐), G1(低延迟), ZGC/Shenandoah(亚毫秒超大堆)）。</li><li><strong>收集器特异性调优</strong>： <ul><li>G1：首要调 <code>MaxGCPauseMillis</code> 和 <code>InitiatingHeapOccupancyPercent</code>。</li><li>老收集器：熟悉其关键启动/失败控制参数（如CMS <code>CMSInitiatingOccupancyFraction</code>）。</li><li>低延迟收集器：关注暂停目标和CPU负载。</li></ul></li><li><strong>诊断与解决问题</strong>： <ul><li>Full GC：内存泄漏 (堆转储分析)、CMS并发失败 (调启动点/年轻代)、<code>System.gc()</code>、元空间设置。</li><li>长暂停：YGC时间长（年轻代大/对象晋升多）、CMS/G1的Remark长 (<code>CMSScavengeBeforeRemark</code>）。</li><li>高CPU：GC过于频繁或并发线程过度竞争。</li><li>碎片化：CMS Full GC压缩触发设置。</li></ul></li><li><strong>压力测试 &amp; 回归验证</strong>：模拟真实环境，关注长稳。</li><li><strong>渐进小心调整</strong>：每次改少量参数，保留修改记录。</li><li><strong>警惕内存泄漏</strong>：这是引起绝大多数长时间GC问题的根本原因之一。</li></ol><p>🌟 <strong>再次强调：没有完美的配置！GC 调优是基于监控数据不断迭代优化的过程。</strong> 最好的优化往往是对应用本身的优化（数据结构选择、算法效率、减少不必要的对象创建、缩短对象生命周期）。当你在应用层面优化到位后，GC调优往往会事半功倍、甚至变得极其简单。🎯</p><hr><h2 id="java-常见的垃圾收集器有哪些" tabindex="-1">Java 常见的垃圾收集器有哪些？ <a class="header-anchor" href="#java-常见的垃圾收集器有哪些" aria-hidden="true">#</a></h2><p>Java 常见的垃圾收集器（Garbage Collector）主要有以下几种，针对不同场景优化，适用于不同版本的 JDK：</p><hr><h4 id="_1-串行收集器-serial-collector" tabindex="-1"><strong>1. 串行收集器 (Serial Collector)</strong> <a class="header-anchor" href="#_1-串行收集器-serial-collector" aria-hidden="true">#</a></h4><ul><li><strong>工作机制</strong>：单线程收集，回收时触发 <strong>STW（Stop-The-World）</strong>，暂停所有应用线程。</li><li><strong>区域</strong>：新生代（标记-复制算法）、老年代（标记-整理算法）。</li><li><strong>特点</strong>：内存占用低，简单高效（单 CPU 环境）。</li><li><strong>适用场景</strong>：Client 模式或小型应用（如桌面程序）。</li><li><strong>启用参数</strong>：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-XX:+UseSerialGC</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h4 id="_2-并行收集器-parallel-collector-throughput-collector" tabindex="-1"><strong>2. 并行收集器 (Parallel Collector / Throughput Collector)</strong> <a class="header-anchor" href="#_2-并行收集器-parallel-collector-throughput-collector" aria-hidden="true">#</a></h4><ul><li><strong>工作机制</strong>：<strong>多线程并行回收</strong>，显著减少回收时间，但仍需 STW。</li><li><strong>名称</strong>：<code>ParNew</code>（新生代）、<code>Parallel Scavenge</code>（新生代）、<code>Parallel Old</code>（老年代）。</li><li><strong>特点</strong>： <ul><li><code>Parallel Scavenge</code> 关注 <strong>吞吐量</strong>（用户代码运行时间 / 总时间）。</li><li><code>ParNew</code> 是 <code>Parallel Scavenge</code> 的兼容版，主要与 CMS 配合使用。</li></ul></li><li><strong>适用场景</strong>：后台计算、批处理任务（高吞吐需求）。</li><li><strong>启用参数</strong>：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;"># 新生代 Parallel Scavenge + 老年代 Parallel Old</span></span>
<span class="line"><span style="color:#FFCB6B;">-XX:+UseParallelGC</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 新生代 ParNew + 老年代 CMS (需组合使用)</span></span>
<span class="line"><span style="color:#FFCB6B;">-XX:+UseParNewGC</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-XX:+UseConcMarkSweepGC</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h4 id="_3-cms-收集器-concurrent-mark-sweep" tabindex="-1"><strong>3. CMS 收集器 (Concurrent Mark Sweep)</strong> <a class="header-anchor" href="#_3-cms-收集器-concurrent-mark-sweep" aria-hidden="true">#</a></h4><ul><li><strong>工作机制</strong>：以 <strong>最小停顿时间</strong> 为目标，主要分四步： <ol><li>初始标记（STW）。</li><li>并发标记（与应用线程并发）。</li><li>重新标记（STW）。</li><li>并发清除（与应用线程并发）。</li></ol></li><li><strong>区域</strong>：仅用于老年代（标记-清除算法）。</li><li><strong>特点</strong>： <ul><li><strong>并发收集</strong>，减少停顿时间。</li><li>存在 <strong>内存碎片</strong>，可能触发 Full GC。</li><li>无法处理 &quot;浮动垃圾&quot;（回收过程中新产生的垃圾）。</li></ul></li><li><strong>启用参数</strong>：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-XX:+UseConcMarkSweepGC</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h4 id="_4-g1-收集器-garbage-first" tabindex="-1"><strong>4. G1 收集器 (Garbage-First)</strong> <a class="header-anchor" href="#_4-g1-收集器-garbage-first" aria-hidden="true">#</a></h4><ul><li><strong>工作机制</strong>： <ul><li>将堆划分为 <strong>多个 Region</strong>（默认 2048 个），优先回收垃圾最多的区域（Garbage-First）。</li><li>分阶段回收（Young GC / Mixed GC），可设定 <strong>预期停顿时间</strong>（如 <code>-XX:MaxGCPauseMillis=200ms</code>）。</li></ul></li><li><strong>区域</strong>：同时管理新生代和老年代（标记-复制 + 标记-整理算法）。</li><li><strong>特点</strong>： <ul><li>JDK 9 及之后版本的 <strong>默认收集器</strong>。</li><li>适合大堆（数十 GB 以上），停顿时间可控。</li></ul></li><li><strong>启用参数</strong>：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-XX:+UseG1GC</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h4 id="_5-zgc-z-garbage-collector" tabindex="-1"><strong>5. ZGC (Z Garbage Collector)</strong> <a class="header-anchor" href="#_5-zgc-z-garbage-collector" aria-hidden="true">#</a></h4><ul><li><strong>工作机制</strong>： <ul><li>使用 <strong>着色指针</strong>（Colored Pointers）和 <strong>读屏障</strong>（Load Barrier），实现 <strong>亚毫秒级停顿</strong>（通常 &lt;10ms）。</li><li>全程并发（包括标记、转移、重定位），几乎无 STW。</li></ul></li><li><strong>区域</strong>：不分代（未来可能支持分代）。</li><li><strong>特点</strong>： <ul><li>JDK 15 开始正式支持，应对超大堆（TB 级）。</li></ul></li><li><strong>启用参数</strong>：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-XX:+UseZGC</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h4 id="_6-shenandoah" tabindex="-1"><strong>6. Shenandoah</strong> <a class="header-anchor" href="#_6-shenandoah" aria-hidden="true">#</a></h4><ul><li><strong>工作机制</strong>： <ul><li>类似 ZGC，通过 <strong>转发指针</strong>（Brooks Pointer）和 <strong>读屏障</strong> 实现并发回收。</li></ul></li><li><strong>特点</strong>： <ul><li>Red Hat 贡献，与 ZGC 竞争，低延迟场景表现优异。</li></ul></li><li><strong>启用参数</strong>：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-XX:+UseShenandoahGC</span></span>
<span class="line"></span></code></pre></div></li></ul><hr><h4 id="总结对比-1" tabindex="-1"><strong>总结对比</strong> <a class="header-anchor" href="#总结对比-1" aria-hidden="true">#</a></h4><table><thead><tr><th>收集器</th><th>特点</th><th>适用场景</th><th>JDK 默认版本</th></tr></thead><tbody><tr><td><strong>Serial</strong></td><td>单线程，简单高效，STW 长</td><td>客户端/小内存</td><td>Client 模式默认</td></tr><tr><td><strong>Parallel</strong></td><td>多线程，高吞吐量</td><td>后台计算/批处理</td><td>JDK 8 及之前并行 GC</td></tr><tr><td><strong>CMS</strong></td><td>并发收集，低停顿，有碎片</td><td>响应优先的老年代回收</td><td>JDK 14 被废弃</td></tr><tr><td><strong>G1</strong></td><td>分 Region，可预测停顿</td><td>大堆/平衡吞吐与延迟</td><td><strong>JDK 9+ 默认</strong></td></tr><tr><td><strong>ZGC</strong></td><td>超低停顿（&lt;10ms），支持超大堆</td><td>云原生/延迟敏感型应用</td><td>JDK 15+ 生产可用</td></tr><tr><td><strong>Shenandoah</strong></td><td>低延迟，与 ZGC 竞争</td><td>类似 ZGC</td><td>需明确启用</td></tr></tbody></table><hr><h4 id="如何选择-2" tabindex="-1"><strong>如何选择？</strong> <a class="header-anchor" href="#如何选择-2" aria-hidden="true">#</a></h4><ul><li><strong>小型应用</strong>：<code>Serial</code> 或 <code>Parallel</code>（低内存开销）。</li><li><strong>响应优先</strong>（如 Web 服务）：<code>G1</code>、<code>ZGC</code> 或 <code>Shenandoah</code>（追求低延迟）。</li><li><strong>计算密集型</strong>：<code>Parallel</code>（最大化吞吐量）。</li><li><strong>超大规模堆</strong>（≥32GB）：<code>ZGC</code> 或 <code>Shenandoah</code>（避免 Full GC）。</li></ul><blockquote><p>📌 <strong>注意</strong>：新版 JDK（17/21）优先使用 <strong>G1</strong> 或 <strong>ZGC</strong>，CMS 已在 JDK 14 标记为废弃（Deprecated）。</p></blockquote><hr><h2 id="详细介绍java中的aqs" tabindex="-1">详细介绍Java中的AQS <a class="header-anchor" href="#详细介绍java中的aqs" aria-hidden="true">#</a></h2><h3 id="java-aqs-abstractqueuedsynchronizer-详解" tabindex="-1">Java AQS（AbstractQueuedSynchronizer）详解 <a class="header-anchor" href="#java-aqs-abstractqueuedsynchronizer-详解" aria-hidden="true">#</a></h3><h4 id="一、核心作用" tabindex="-1"><strong>一、核心作用</strong> <a class="header-anchor" href="#一、核心作用" aria-hidden="true">#</a></h4><p>AQS是Java并发包（<code>java.util.concurrent.locks</code>）的核心基础框架，通过<strong>CLH队列</strong>（FIFO双向链表）管理线程阻塞、排队、唤醒等底层同步机制，实现了同步器的通用语义。大多数JUC工具（如ReentrantLock、Semaphore、CountDownLatch）都基于AQS构建。</p><hr><h4 id="二、核心组成" tabindex="-1"><strong>二、核心组成</strong> <a class="header-anchor" href="#二、核心组成" aria-hidden="true">#</a></h4><ol><li><p><strong>volatile int state</strong></p><ul><li>同步状态标志位，通过CAS原子操作修改。</li><li>子类可赋予其不同语义（如锁的重入次数、信号量许可数）。</li><li>提供线程安全的访问方法：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#82AAFF;">getState</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">setState</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">compareAndSetState</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> expect</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> update</span><span style="color:#89DDFF;">)</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong>CLH队列</strong>（同步队列）</p><ul><li>双向链表结构，存储等待线程（Node节点）。</li><li>Node节点关键属性：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">volatile</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> waitStatus</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 节点状态（CANCELLED、SIGNAL、CONDITION等）</span></span>
<span class="line"><span style="color:#C792EA;">volatile</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Node</span><span style="color:#A6ACCD;"> prev</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">       </span><span style="color:#676E95;font-style:italic;">// 前驱节点</span></span>
<span class="line"><span style="color:#C792EA;">volatile</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Node</span><span style="color:#A6ACCD;"> next</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">       </span><span style="color:#676E95;font-style:italic;">// 后继节点</span></span>
<span class="line"><span style="color:#C792EA;">volatile</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Thread</span><span style="color:#A6ACCD;"> thread</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">   </span><span style="color:#676E95;font-style:italic;">// 绑定的线程</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ol><hr><h4 id="三、核心方法-需子类实现" tabindex="-1"><strong>三、核心方法（需子类实现）</strong> <a class="header-anchor" href="#三、核心方法-需子类实现" aria-hidden="true">#</a></h4><p>AQS使用了模板方法模式，子类需覆盖以下方法：</p><table><thead><tr><th>操作模式</th><th>方法签名</th><th>作用描述</th></tr></thead><tbody><tr><td><strong>独占模式</strong></td><td><code>protected boolean tryAcquire(int arg)</code></td><td>尝试获取资源（需CAS）</td></tr><tr><td></td><td><code>protected boolean tryRelease(int arg)</code></td><td>尝试释放资源</td></tr><tr><td><strong>共享模式</strong></td><td><code>protected int tryAcquireShared(int arg)</code></td><td>尝试获取共享资源（返回负数为失败）</td></tr><tr><td></td><td><code>protected boolean tryReleaseShared(int arg)</code></td><td>尝试释放共享资源</td></tr><tr><td>通用</td><td><code>protected boolean isHeldExclusively()</code></td><td>当前线程是否独占资源</td></tr></tbody></table><hr><h4 id="四、同步模式" tabindex="-1"><strong>四、同步模式</strong> <a class="header-anchor" href="#四、同步模式" aria-hidden="true">#</a></h4><ol><li><p><strong>独占模式（Exclusive）</strong></p><ul><li>一次仅一个线程可获取资源（如ReentrantLock）。</li><li><strong>核心方法</strong>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#82AAFF;">acquire</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> arg</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">      </span><span style="color:#676E95;font-style:italic;">// 获取资源（忽略中断）</span></span>
<span class="line"><span style="color:#82AAFF;">acquireInterruptibly</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> arg</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 响应中断</span></span>
<span class="line"><span style="color:#82AAFF;">release</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> arg</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">      </span><span style="color:#676E95;font-style:italic;">// 释放资源</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong>共享模式（Shared）</strong></p><ul><li>多个线程可同时获取资源（如Semaphore）。</li><li><strong>核心方法</strong>：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#82AAFF;">acquireShared</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> arg</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#82AAFF;">acquireSharedInterruptibly</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> arg</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#82AAFF;">releaseShared</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> arg</span><span style="color:#89DDFF;">)</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ol><hr><h4 id="五、工作流程" tabindex="-1"><strong>五、工作流程</strong> <a class="header-anchor" href="#五、工作流程" aria-hidden="true">#</a></h4><ol><li><p><strong>独占模式获取资源</strong>（以<code>acquire()</code>为例）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">acquire</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> arg</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(!</span><span style="color:#82AAFF;">tryAcquire</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">arg</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;">        </span><span style="color:#676E95;font-style:italic;">// 尝试获取资源</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">acquireQueued</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">addWaiter</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">EXCLUSIVE</span><span style="color:#89DDFF;">),</span><span style="color:#A6ACCD;"> arg</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 失败则入队</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li><strong>tryAcquire</strong>：子类实现的自旋+CAS获取逻辑。</li><li><strong>addWaiter</strong>：线程封装为独占节点并入队尾。</li><li><strong>acquireQueued</strong>：线程在队列中自旋阻塞（通过LockSupport.park()）。</li></ul></li><li><p><strong>释放资源流程</strong>（以独占模式为例）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">boolean</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">release</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> arg</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">tryRelease</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">arg</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">      </span><span style="color:#676E95;font-style:italic;">// 子类实现释放逻辑</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Node</span><span style="color:#A6ACCD;"> h </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> head</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">h </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> h</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">waitStatus </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#82AAFF;">unparkSuccessor</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">h</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 唤醒后继节点线程</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">false;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ol><hr><h4 id="六、关键特性" tabindex="-1"><strong>六、关键特性</strong> <a class="header-anchor" href="#六、关键特性" aria-hidden="true">#</a></h4><ol><li><p><strong>可中断与超时机制</strong></p><ul><li><code>acquireInterruptibly()</code>：线程在阻塞中响应中断。</li><li><code>tryAcquireNanos()</code>：支持超时获取资源。</li></ul></li><li><p><strong>条件队列支持</strong></p><ul><li>通过<code>ConditionObject</code>实现条件等待（等待/通知机制）。</li><li>示例：<div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">Condition</span><span style="color:#A6ACCD;"> condition </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> lock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newCondition</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">condition</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">await</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 释放锁并加入条件队列</span></span>
<span class="line"><span style="color:#A6ACCD;">condition</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">signal</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 将等待线程移回同步队列</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><strong>公平性控制</strong></p><ul><li><strong>公平锁</strong>：严格按队列顺序分配资源。</li><li><strong>非公平锁</strong>：新线程可抢先尝试获取资源（通过tryAcquire实现）。</li></ul></li></ol><hr><h4 id="七、经典实现类" tabindex="-1"><strong>七、经典实现类</strong> <a class="header-anchor" href="#七、经典实现类" aria-hidden="true">#</a></h4><table><thead><tr><th>同步器</th><th>AQS使用方式</th><th>state含义</th></tr></thead><tbody><tr><td>ReentrantLock</td><td>独占模式</td><td>锁重入次数（0=未占用）</td></tr><tr><td>Semaphore</td><td>共享模式</td><td>可用许可证数量</td></tr><tr><td>CountDownLatch</td><td>共享模式</td><td>倒计数初始值</td></tr><tr><td>ReentrantReadWriteLock</td><td>读写锁（读共享，写独占）</td><td>高16位=读锁数量，低16位=写锁重入次数</td></tr></tbody></table><hr><h4 id="八、自研同步器示例-独占锁" tabindex="-1"><strong>八、自研同步器示例（独占锁）</strong> <a class="header-anchor" href="#八、自研同步器示例-独占锁" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Mutex</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">AbstractQueuedSynchronizer</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 尝试获取锁</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">protected</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">boolean</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">tryAcquire</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">acquires</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">compareAndSetState</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// CAS设置state</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#82AAFF;">setExclusiveOwnerThread</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Thread</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">currentThread</span><span style="color:#89DDFF;">());</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">false;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 尝试释放锁</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">protected</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">boolean</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">tryRelease</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">releases</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">getState</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">throw</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">IllegalMonitorStateException</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">setExclusiveOwnerThread</span><span style="color:#89DDFF;">(null);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#82AAFF;">setState</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 无需CAS，独占线程安全</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 判断是否已上锁</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">boolean</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">isLocked</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getState</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><hr><h4 id="九、aqs设计哲学" tabindex="-1"><strong>九、AQS设计哲学</strong> <a class="header-anchor" href="#九、aqs设计哲学" aria-hidden="true">#</a></h4><ol><li><strong>职责分离</strong>： AQS负责同步队列管理，子类定义资源获取/释放逻辑。</li><li><strong>模板方法模式</strong>： 子类仅实现核心钩子方法（tryAcquire/tryRelease）。</li><li><strong>性能优化</strong>： 通过自旋+CAS减少阻塞，避免上下文切换开销。</li></ol><blockquote><p><strong>重要提示</strong>：直接使用AQS需深入理解其内存语义，建议优先使用JUC内置同步器（如ReentrantLock）。深入掌握AQS是解锁Java并发高级特性的关键。</p></blockquote><hr><h2 id="springboot-的项目启动过程详细每个步骤介绍" tabindex="-1">springboot 的项目启动过程详细每个步骤介绍 <a class="header-anchor" href="#springboot-的项目启动过程详细每个步骤介绍" aria-hidden="true">#</a></h2><p>Spring Boot 项目的启动过程是一个复杂但高度自动化的流程，分为多个阶段，<strong>核心是通过 <code>SpringApplication</code> 类驱动框架初始化并启动内嵌容器</strong>。以下是详细步骤分解：</p><hr><h3 id="_1-创建-springapplication-实例" tabindex="-1">1. <strong>创建 SpringApplication 实例</strong> <a class="header-anchor" href="#_1-创建-springapplication-实例" aria-hidden="true">#</a></h3><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">SpringApplication</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">run</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">AppConfig</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> args</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div><ul><li><strong>关键操作</strong>： <ul><li>推断应用类型（Servlet、Reactive、非Web），决定后续创建的 <code>ApplicationContext</code> 类型（如 <code>AnnotationConfigServletWebServerApplicationContext</code>）。</li><li>加载 <code>META-INF/spring.factories</code> 中的配置： <ul><li><code>ApplicationContextInitializer</code>：上下文初始化扩展点。</li><li><code>ApplicationListener</code>：事件监听器（如 <code>EventPublishingRunListener</code> 用于事件广播）。</li></ul></li><li>推断主配置类（标注 <code>@SpringBootApplication</code> 的类）。</li></ul></li></ul><hr><h3 id="_2-执行-run-方法-核心流程" tabindex="-1">2. <strong>执行 run() 方法（核心流程）</strong> <a class="header-anchor" href="#_2-执行-run-方法-核心流程" aria-hidden="true">#</a></h3><h4 id="_1-启动计时器" tabindex="-1">(1) <strong>启动计时器</strong> <a class="header-anchor" href="#_1-启动计时器" aria-hidden="true">#</a></h4><ul><li>初始化 <code>StopWatch</code> 记录启动耗时。</li></ul><h4 id="_2-初始化应用监听器" tabindex="-1">(2) <strong>初始化应用监听器</strong> <a class="header-anchor" href="#_2-初始化应用监听器" aria-hidden="true">#</a></h4><ul><li>发布 <code>ApplicationStartingEvent</code> 事件。</li></ul><h4 id="_3-准备环境-environment" tabindex="-1">(3) <strong>准备环境 <code>Environment</code></strong> <a class="header-anchor" href="#_3-准备环境-environment" aria-hidden="true">#</a></h4><ul><li>加载配置源（如 <code>application.yml</code>、系统变量、命令行参数）。</li><li>发布 <code>ApplicationEnvironmentPreparedEvent</code> 事件（监听器可修改环境配置）。</li></ul><h4 id="_4-创建应用上下文-applicationcontext" tabindex="-1">(4) <strong>创建应用上下文 <code>ApplicationContext</code></strong> <a class="header-anchor" href="#_4-创建应用上下文-applicationcontext" aria-hidden="true">#</a></h4><ul><li><strong>根据应用类型创建对应上下文</strong>： <ul><li>Web 应用：<code>AnnotationConfigServletWebServerApplicationContext</code></li><li>响应式应用：<code>AnnotationConfigReactiveWebServerApplicationContext</code></li><li>非Web应用：<code>AnnotationConfigApplicationContext</code></li></ul></li></ul><h4 id="_5-准备上下文" tabindex="-1">(5) <strong>准备上下文</strong> <a class="header-anchor" href="#_5-准备上下文" aria-hidden="true">#</a></h4><ul><li><strong>关键操作</strong>： <ul><li>设置环境（<code>Environment</code>）。</li><li>执行 <code>ApplicationContextInitializer</code> 初始化器。</li><li>发布 <code>ApplicationContextInitializedEvent</code> 事件。</li><li><strong>加载主配置类与组件</strong>（通过 <code>AnnotatedBeanDefinitionReader</code> 解析 <code>@SpringBootApplication</code> 类）。</li><li>发布 <code>ApplicationPreparedEvent</code> 事件（此时 Bean 定义已加载但未初始化）。</li></ul></li></ul><hr><h3 id="_3-刷新上下文-refreshcontext" tabindex="-1">3. <strong>刷新上下文（<code>refreshContext()</code>）</strong> <a class="header-anchor" href="#_3-刷新上下文-refreshcontext" aria-hidden="true">#</a></h3><p>执行 <code>AbstractApplicationContext.refresh()</code> 方法，<strong>这是最核心的步骤</strong>，包含以下关键子阶段：</p><h4 id="_1-preparerefresh" tabindex="-1">(1) <strong><code>prepareRefresh()</code></strong> <a class="header-anchor" href="#_1-preparerefresh" aria-hidden="true">#</a></h4><ul><li>设置上下文状态（激活状态、启动时间）。</li></ul><h4 id="_2-obtainfreshbeanfactory" tabindex="-1">(2) <strong><code>obtainFreshBeanFactory()</code></strong> <a class="header-anchor" href="#_2-obtainfreshbeanfactory" aria-hidden="true">#</a></h4><ul><li>获取 <code>BeanFactory</code>（<code>DefaultListableBeanFactory</code>）。</li></ul><h4 id="_3-preparebeanfactory" tabindex="-1">(3) <strong><code>prepareBeanFactory()</code></strong> <a class="header-anchor" href="#_3-preparebeanfactory" aria-hidden="true">#</a></h4><ul><li>配置 <code>BeanFactory</code> 基础功能： <ul><li>添加 <code>ApplicationContextAware</code> 处理器。</li><li>注册环境相关的单例 Bean（<code>Environment</code>、<code>SystemProperties</code>）。</li></ul></li></ul><h4 id="_4-postprocessbeanfactory" tabindex="-1">(4) <strong><code>postProcessBeanFactory()</code></strong> <a class="header-anchor" href="#_4-postprocessbeanfactory" aria-hidden="true">#</a></h4><ul><li>扩展点：子类可在此定制 <code>BeanFactory</code>（如 <code>ServletWebServerApplicationContext</code> 会添加 <code>ServletContextAwareProcessor</code>）。</li></ul><h4 id="_5-invokebeanfactorypostprocessors" tabindex="-1">(5) <strong><code>invokeBeanFactoryPostProcessors()</code></strong> <a class="header-anchor" href="#_5-invokebeanfactorypostprocessors" aria-hidden="true">#</a></h4><ul><li><strong>关键阶段</strong>：<strong>处理配置类（如 <code>@Configuration</code>）和自动配置</strong>。 <ul><li>调用 <code>ConfigurationClassPostProcessor</code> 解析主配置类。</li><li>扫描 <code>@ComponentScan</code> 指定的包，注册 Bean 定义。</li><li><strong>自动配置机制</strong>：加载 <code>META-INF/spring.factories</code> 中的 <code>EnableAutoConfiguration</code> 类，根据 <code>@Conditional</code> <strong>条件过滤并加载配置</strong>。</li></ul></li></ul><h4 id="_6-registerbeanpostprocessors" tabindex="-1">(6) <strong><code>registerBeanPostProcessors()</code></strong> <a class="header-anchor" href="#_6-registerbeanpostprocessors" aria-hidden="true">#</a></h4><ul><li>注册 <code>BeanPostProcessor</code>（如 <code>AutowiredAnnotationBeanPostProcessor</code> 处理 <code>@Autowired</code>）。</li></ul><h4 id="_7-initmessagesource" tabindex="-1">(7) <strong><code>initMessageSource()</code></strong> <a class="header-anchor" href="#_7-initmessagesource" aria-hidden="true">#</a></h4><ul><li>初始化国际化资源。</li></ul><h4 id="_8-initapplicationeventmulticaster" tabindex="-1">(8) <strong><code>initApplicationEventMulticaster()</code></strong> <a class="header-anchor" href="#_8-initapplicationeventmulticaster" aria-hidden="true">#</a></h4><ul><li>初始化事件广播器（<code>SimpleApplicationEventMulticaster</code>）。</li></ul><h4 id="_9-onrefresh" tabindex="-1">(9) <strong><code>onRefresh()</code></strong> <a class="header-anchor" href="#_9-onrefresh" aria-hidden="true">#</a></h4><ul><li><strong>扩展点</strong>：子类实现容器启动逻辑（<strong>关键！</strong>）： <ul><li><code>ServletWebServerApplicationContext</code> 会在此 <strong>创建并启动内嵌 Web 容器</strong>（如 Tomcat/Jetty）。</li><li>容器端口监听在此阶段启动。</li></ul></li></ul><h4 id="_10-registerlisteners" tabindex="-1">(10) <strong><code>registerListeners()</code></strong> <a class="header-anchor" href="#_10-registerlisteners" aria-hidden="true">#</a></h4><ul><li>注册监听器（监听事件广播）。</li></ul><h4 id="_11-finishbeanfactoryinitialization" tabindex="-1">(11) <strong><code>finishBeanFactoryInitialization()</code></strong> <a class="header-anchor" href="#_11-finishbeanfactoryinitialization" aria-hidden="true">#</a></h4><ul><li><strong>实例化所有非懒加载的单例 Bean</strong>： <ul><li>依赖注入（如 <code>@Autowired</code>）、初始化回调（<code>@PostConstruct</code>）。</li><li>执行 <code>BeanPostProcessor</code> 的后置处理（如 AOP 代理）。</li></ul></li></ul><h4 id="_12-finishrefresh" tabindex="-1">(12) <strong><code>finishRefresh()</code></strong> <a class="header-anchor" href="#_12-finishrefresh" aria-hidden="true">#</a></h4><ul><li>发布 <code>ContextRefreshedEvent</code> 事件。</li><li>完成内嵌容器启动（例如初始化 Servlet 的 Filter/Servlet）。</li></ul><hr><h3 id="_4-启动后处理" tabindex="-1">4. <strong>启动后处理</strong> <a class="header-anchor" href="#_4-启动后处理" aria-hidden="true">#</a></h3><h4 id="_1-发布-applicationstartedevent-事件" tabindex="-1">(1) <strong>发布 <code>ApplicationStartedEvent</code> 事件</strong> <a class="header-anchor" href="#_1-发布-applicationstartedevent-事件" aria-hidden="true">#</a></h4><ul><li>表示应用已启动。</li></ul><h4 id="_2-执行-runner-接口" tabindex="-1">(2) <strong>执行 Runner 接口</strong> <a class="header-anchor" href="#_2-执行-runner-接口" aria-hidden="true">#</a></h4><ul><li>调用 <code>CommandLineRunner</code> 和 <code>ApplicationRunner</code> 的 <code>run()</code> 方法（用于启动后任务）。</li></ul><h4 id="_3-发布-applicationreadyevent-事件" tabindex="-1">(3) <strong>发布 <code>ApplicationReadyEvent</code> 事件</strong> <a class="header-anchor" href="#_3-发布-applicationreadyevent-事件" aria-hidden="true">#</a></h4><ul><li>表示应用完全就绪（可接收请求）。</li></ul><h4 id="_4-启动完成" tabindex="-1">(4) <strong>启动完成</strong> <a class="header-anchor" href="#_4-启动完成" aria-hidden="true">#</a></h4><ul><li>返回已初始化的 <code>ApplicationContext</code>。</li></ul><hr><h3 id="关键机制解析" tabindex="-1">关键机制解析 <a class="header-anchor" href="#关键机制解析" aria-hidden="true">#</a></h3><ol><li><p><strong>自动配置原理</strong>：</p><ul><li>通过 <code>@EnableAutoConfiguration</code> 激活自动配置类（<code>XXXAutoConfiguration</code>）。</li><li>基于 <code>@Conditional</code> 条件动态注册 Bean（如 <code>@ConditionalOnClass</code> 检测类路径是否存在）。</li></ul></li><li><p><strong>内嵌容器启动</strong>：</p><ul><li><code>ServletWebServerFactory</code> 负责创建 Web 服务器（如 <code>TomcatServletWebServerFactory</code>）。</li><li>在 <code>onRefresh()</code> 阶段通过 <code>getWebServer()</code> 启动容器。</li></ul></li><li><p><strong>事件驱动模型</strong>：</p><ul><li>共发布 <strong>6个核心事件</strong>（<code>Starting</code>, <code>EnvironmentPrepared</code>, <code>ContextPrepared</code>, <code>ContextLoaded</code>, <code>Started</code>, <code>Ready</code>），贯穿整个启动流程。</li></ul></li></ol><hr><h3 id="启动事件序列图" tabindex="-1">启动事件序列图 <a class="header-anchor" href="#启动事件序列图" aria-hidden="true">#</a></h3><div class="language-plaintext"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">SpringApplication.run()</span></span>
<span class="line"><span style="color:#A6ACCD;">  │</span></span>
<span class="line"><span style="color:#A6ACCD;">  ├── ApplicationStartingEvent</span></span>
<span class="line"><span style="color:#A6ACCD;">  │</span></span>
<span class="line"><span style="color:#A6ACCD;">  ├── Environment 初始化 → ApplicationEnvironmentPreparedEvent</span></span>
<span class="line"><span style="color:#A6ACCD;">  │</span></span>
<span class="line"><span style="color:#A6ACCD;">  ├── ApplicationContext 创建 → ApplicationContextInitializedEvent</span></span>
<span class="line"><span style="color:#A6ACCD;">  │</span></span>
<span class="line"><span style="color:#A6ACCD;">  ├── Bean 加载 → ApplicationPreparedEvent</span></span>
<span class="line"><span style="color:#A6ACCD;">  │</span></span>
<span class="line"><span style="color:#A6ACCD;">  ├── refreshContext() 刷新上下文</span></span>
<span class="line"><span style="color:#A6ACCD;">  │   ├── onRefresh() 启动内嵌容器</span></span>
<span class="line"><span style="color:#A6ACCD;">  │   └── finishRefresh() → ContextRefreshedEvent</span></span>
<span class="line"><span style="color:#A6ACCD;">  │</span></span>
<span class="line"><span style="color:#A6ACCD;">  ├── ApplicationStartedEvent</span></span>
<span class="line"><span style="color:#A6ACCD;">  │</span></span>
<span class="line"><span style="color:#A6ACCD;">  ├── 执行 Runners</span></span>
<span class="line"><span style="color:#A6ACCD;">  │</span></span>
<span class="line"><span style="color:#A6ACCD;">  └── ApplicationReadyEvent</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>这个过程体现了 Spring Boot <strong>约定优于配置</strong>的核心思想，通过自动化和事件机制大幅简化了传统 Spring 应用的启动配置。</p><hr><h2 id="springboot如何自定义starter" tabindex="-1">springboot如何自定义starter <a class="header-anchor" href="#springboot如何自定义starter" aria-hidden="true">#</a></h2><p>在 Spring Boot 中自定义 Starter 是一种封装公共组件或配置的方式，便于其他项目复用。以下是详细步骤和最佳实践：</p><h3 id="_1-创建-starter-项目结构" tabindex="-1">1. <strong>创建 Starter 项目结构</strong> <a class="header-anchor" href="#_1-创建-starter-项目结构" aria-hidden="true">#</a></h3><p>建议分为两个模块：</p><ul><li><strong>自动配置模块</strong> (xxx-spring-boot-autoconfigure)：包含核心逻辑</li><li><strong>Starter 模块</strong> (xxx-spring-boot-starter)：空项目，仅依赖自动配置模块和必要库</li></ul><blockquote><p>📌 也可合并为单一模块（小型 Starter 适用）</p></blockquote><hr><h3 id="_2-自动配置模块实现" tabindex="-1">2. <strong>自动配置模块实现</strong> <a class="header-anchor" href="#_2-自动配置模块实现" aria-hidden="true">#</a></h3><h4 id="_1-添加-maven-依赖" tabindex="-1">(1) 添加 Maven 依赖 <a class="header-anchor" href="#_1-添加-maven-依赖" aria-hidden="true">#</a></h4><div class="language-xml"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">dependencies</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">&lt;!-- Spring Boot 自动配置核心 --&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">dependency</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">groupId</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">org.springframework.boot</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">groupId</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">artifactId</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">spring-boot-autoconfigure</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">artifactId</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">dependency</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">&lt;!-- 配置注解处理器（可选） --&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">dependency</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">groupId</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">org.springframework.boot</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">groupId</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">artifactId</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">spring-boot-configuration-processor</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">artifactId</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">optional</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">true</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">optional</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">dependency</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">dependencies</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><h4 id="_2-创建配置属性类" tabindex="-1">(2) 创建配置属性类 <a class="header-anchor" href="#_2-创建配置属性类" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">ConfigurationProperties</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">prefix</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">demo.service</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">DemoProperties</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> prefix </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">[默认前缀]</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> suffix </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">[默认后缀]</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// Getter/Setter 省略</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h4 id="_3-核心服务类" tabindex="-1">(3) 核心服务类 <a class="header-anchor" href="#_3-核心服务类" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">DemoService</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> prefix</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> suffix</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">DemoService</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">prefix</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">suffix</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">prefix </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> prefix</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">suffix </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> suffix</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">wrap</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">content</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> prefix </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> content </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> suffix</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h4 id="_4-自动配置类" tabindex="-1">(4) 自动配置类 <a class="header-anchor" href="#_4-自动配置类" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Configuration</span></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">EnableConfigurationProperties</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">DemoProperties</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 启用配置</span></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">ConditionalOnClass</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">DemoService</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 类路径存在时生效</span></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">ConditionalOnProperty</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">prefix</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">demo.service</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">name</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">enabled</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">havingValue</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">true</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">matchIfMissing</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true)</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">DemoAutoConfiguration</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Bean</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">ConditionalOnMissingBean</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 容器不存在该Bean时创建</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">DemoService</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">demoService</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">DemoProperties</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">properties</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">DemoService</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">properties</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getPrefix</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> properties</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getSuffix</span><span style="color:#89DDFF;">());</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h4 id="_5-注册自动配置" tabindex="-1">(5) 注册自动配置 <a class="header-anchor" href="#_5-注册自动配置" aria-hidden="true">#</a></h4><p>在 <code>resources/META-INF</code> 下创建文件：</p><ul><li><strong>Spring Boot 2.7+</strong> : <code>spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">com.example.autoconfigure.DemoAutoConfiguration</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div></li><li><strong>旧版本</strong> : <code>spring.factories</code><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\</span></span>
<span class="line"><span style="color:#A6ACCD;">  com.example.autoconfigure.DemoAutoConfiguration</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div></li></ul><hr><h3 id="_3-starter-模块实现" tabindex="-1">3. <strong>Starter 模块实现</strong> <a class="header-anchor" href="#_3-starter-模块实现" aria-hidden="true">#</a></h3><h4 id="_1-添加-maven-依赖-1" tabindex="-1">(1) 添加 Maven 依赖 <a class="header-anchor" href="#_1-添加-maven-依赖-1" aria-hidden="true">#</a></h4><div class="language-xml"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">dependencies</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">dependency</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">groupId</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">com.example</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">groupId</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">artifactId</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">xxx-spring-boot-autoconfigure</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">artifactId</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">version</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1.0.0</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">version</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">dependency</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">&lt;!-- 可添加其他必要依赖 --&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">dependencies</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><h4 id="_2-命名规范-重要" tabindex="-1">(2) 命名规范（重要） <a class="header-anchor" href="#_2-命名规范-重要" aria-hidden="true">#</a></h4><ul><li>官方 Starter 命名：<code>spring-boot-starter-{name}</code></li><li>自定义 Starter 命名：<code>{name}-spring-boot-starter</code></li></ul><hr><h3 id="_4-安装到本地仓库" tabindex="-1">4. <strong>安装到本地仓库</strong> <a class="header-anchor" href="#_4-安装到本地仓库" aria-hidden="true">#</a></h3><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">mvn</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">clean</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">install</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="_5-在其他项目中使用" tabindex="-1">5. <strong>在其他项目中使用</strong> <a class="header-anchor" href="#_5-在其他项目中使用" aria-hidden="true">#</a></h3><h4 id="_1-添加依赖" tabindex="-1">(1) 添加依赖 <a class="header-anchor" href="#_1-添加依赖" aria-hidden="true">#</a></h4><div class="language-xml"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">dependency</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">groupId</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">com.example</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">groupId</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">artifactId</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">demo-spring-boot-starter</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">artifactId</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">version</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1.0.0</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">version</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">dependency</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><h4 id="_2-配置文件-application-yml" tabindex="-1">(2) 配置文件 <code>application.yml</code> <a class="header-anchor" href="#_2-配置文件-application-yml" aria-hidden="true">#</a></h4><div class="language-yaml"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F07178;">demo</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">service</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">enabled</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">prefix</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">✨</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">suffix</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">✨</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"></span></code></pre></div><h4 id="_3-注入使用" tabindex="-1">(3) 注入使用 <a class="header-anchor" href="#_3-注入使用" aria-hidden="true">#</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">RestController</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">DemoController</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Autowired</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">DemoService</span><span style="color:#A6ACCD;"> demoService</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">GetMapping</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">/test</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">test</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">input</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> demoService</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">wrap</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">input</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><hr><h3 id="✨-最佳实践-注意事项" tabindex="-1">✨ 最佳实践 &amp; 注意事项 <a class="header-anchor" href="#✨-最佳实践-注意事项" aria-hidden="true">#</a></h3><ol><li><p><strong>条件化配置</strong>：大量使用 <code>@Conditional</code> 系列注解，根据条件动态装配</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">ConditionalOnWebApplication</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 仅Web应用生效</span></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">ConditionalOnMissingClass</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">com.example.OtherService</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 类不存在时生效</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>配置元数据</strong>：在属性类中添加 Javadoc 或使用 <code>spring-boot-configuration-processor</code> 生成提示</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">ConfigurationProperties</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">prefix</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">demo.service</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">DemoProperties</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * 内容前缀装饰符</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     */</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> prefix </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">[默认]</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li><li><p><strong>模块分离</strong>：将自动配置与 Starter 分离，避免传递不需要的依赖</p></li><li><p><strong>错误处理</strong>：添加 <code>@ImportRuntimeHints</code> 支持 AOT 编译（Spring Boot 3+）</p></li><li><p><strong>版本兼容</strong>：在 Starter 的 pom.xml 中明确依赖版本：</p><div class="language-xml"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">dependencyManagement</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">     </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">dependencies</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">         </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">dependency</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">             </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">groupId</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">org.springframework.boot</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">groupId</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">             </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">artifactId</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">spring-boot-dependencies</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">artifactId</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">             </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">version</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">\${spring.boot.version}</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">version</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">             </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">pom</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">             </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">scope</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">import</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">scope</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">         </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">dependency</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">     </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">dependencies</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">dependencyManagement</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div></li></ol><p>完整目录结构示例：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">demo-spring-boot-starter/</span></span>
<span class="line"><span style="color:#A6ACCD;">   pom.xml</span></span>
<span class="line"><span style="color:#A6ACCD;">demo-spring-boot-autoconfigure/</span></span>
<span class="line"><span style="color:#A6ACCD;">   src/</span></span>
<span class="line"><span style="color:#A6ACCD;">     main/</span></span>
<span class="line"><span style="color:#A6ACCD;">       java/</span></span>
<span class="line"><span style="color:#A6ACCD;">         com/example/autoconfigure/</span></span>
<span class="line"><span style="color:#A6ACCD;">           DemoAutoConfiguration.java</span></span>
<span class="line"><span style="color:#A6ACCD;">           DemoProperties.java</span></span>
<span class="line"><span style="color:#A6ACCD;">           DemoService.java</span></span>
<span class="line"><span style="color:#A6ACCD;">       resources/</span></span>
<span class="line"><span style="color:#A6ACCD;">         META-INF/</span></span>
<span class="line"><span style="color:#A6ACCD;">           spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</span></span>
<span class="line"><span style="color:#A6ACCD;">   pom.xml</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>通过以上步骤，即可创建高可用的 Spring Boot Starter，实现“开箱即用”的组件集成效果。</p>`,1073),p=[t];function e(r,c,i,y,D,C){return a(),n("div",null,p)}const d=s(o,[["render",e]]);export{F as __pageData,d as default};
