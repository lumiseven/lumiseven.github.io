import{_ as t,c as e,o as l,a as n}from"./app.9e6df08e.js";const f=JSON.parse('{"title":"web开发中针对有限的资源, 有存在漏斗模式和令牌筒的模式, 能简单介绍下吗?","description":"","frontmatter":{},"headers":[],"relativePath":"jotting/1751351308.md","lastUpdated":1751367489000}'),r={name:"jotting/1751351308.md"},s=n('<h1 id="web开发中针对有限的资源-有存在漏斗模式和令牌筒的模式-能简单介绍下吗" tabindex="-1">web开发中针对有限的资源, 有存在漏斗模式和令牌筒的模式, 能简单介绍下吗? <a class="header-anchor" href="#web开发中针对有限的资源-有存在漏斗模式和令牌筒的模式-能简单介绍下吗" aria-hidden="true">#</a></h1><p>在Web开发中，特别是在处理有限资源时，性能优化和流量控制至关重要。你提到的“漏斗模式”和“令牌桶模式”都是常见的限流算法，它们用于规范和限制对资源的访问速率，以防止系统过载。</p><p>让我为你简单介绍一下这两种模式：</p><h3 id="_1-漏斗模式-leaky-bucket" tabindex="-1">1. 漏斗模式（Leaky Bucket） <a class="header-anchor" href="#_1-漏斗模式-leaky-bucket" aria-hidden="true">#</a></h3><p><strong>形象比喻：</strong> 想象一个漏水的桶，上面有很多水龙头（请求），下面有一个固定大小的孔（处理能力）。</p><p><strong>工作原理：</strong></p><ul><li><strong>入口（水龙头）：</strong> 各种请求（数据包、API调用等）会源源不断地进入“桶”中。</li><li><strong>桶（缓冲区/队列）：</strong> 桶有一个固定的容量。如果桶满了，新的请求就会被丢弃（拒绝），或者被阻塞等待。</li><li><strong>出口（漏水速度）：</strong> 桶底部的孔以一个恒定的速率漏水，这代表了系统处理请求的能力或速率。</li></ul><p><strong>特点和应用场景：</strong></p><ul><li><strong>平滑输出：</strong> 漏斗模式的主要特点是它能将突发的流量（水流涌入）削峰填谷，最终以一个非常平滑、恒定的速率输出请求。</li><li><strong>固定速率：</strong> 无论入口流量有多大，出口速率始终保持不变。</li><li><strong>应对突发流量：</strong> 能有效防止突发流量冲垮系统。</li><li><strong>缺点：</strong> 无法处理短时间的爆发流量（即使在能力范围内），因为输出速率是恒定的。所有请求都必须按照固定速率排队，这可能导致高延迟。</li><li><strong>适用场景：</strong> 对平滑性要求高，允许请求排队，例如网络流量整形、数据包发送。</li></ul><p><strong>代码实现思路（概念性）：</strong></p><p>维护一个队列，请求进入队列。然后有一个后台线程以固定间隔从队列中取出请求进行处理。如果队列满了，新请求就直接拒绝。</p><h3 id="_2-令牌桶模式-token-bucket" tabindex="-1">2. 令牌桶模式（Token Bucket） <a class="header-anchor" href="#_2-令牌桶模式-token-bucket" aria-hidden="true">#</a></h3><p><strong>形象比喻：</strong> 想象一个装满“令牌”的桶，系统每处理一个请求，就需要消耗一个令牌。源源不断地有新的令牌自动生成并放入桶中。</p><p><strong>工作原理：</strong></p><ul><li><strong>令牌生成：</strong> 桶内以一个固定的速率生成令牌。</li><li><strong>令牌容量：</strong> 桶有一个最大的容量，当桶满了，新生成的令牌就会被丢弃。</li><li><strong>请求处理：</strong> 当有请求到来时，它首先需要从桶中获取一个令牌。 <ul><li>如果桶中有足够的令牌，请求就获取一个令牌并被立即处理。</li><li>如果桶中没有令牌，请求就会被拒绝（或者等待直到有令牌）</li></ul></li><li><strong>令牌消耗：</strong> 每个被处理的请求都会消耗一个令牌。</li></ul><p><strong>特点和应用场景：</strong></p><ul><li><strong>允许突发：</strong> 在桶中有足够令牌的情况下，令牌桶允许在短时间内处理突发的高流量（一次性消耗多个令牌）。这是它与漏斗模式最大的区别。</li><li><strong>速率限制与突发上限：</strong> 令牌生成速率决定了长期平均的处理速率，而桶的容量决定了短时间内允许的最大突发量。</li><li><strong>更灵活：</strong> 对于Web服务API限流等场景，通常更适用。因为Web服务往往需要响应突发请求，而不是严格的固定速率。</li><li><strong>缺点：</strong> 如果令牌桶容量设置不当，可能会导致某些不规范的客户端在短时间内消耗大量资源。</li><li><strong>适用场景：</strong> API限流、服务QPS（每秒查询数）限制。</li></ul><p><strong>代码实现思路（概念性）：</strong></p><p>维护一个变量 <code>current_tokens</code> 表示当前桶中的令牌数，以及 <code>last_fill_time</code> 表示上次填充令牌的时间。当请求到来时：</p><ol><li>根据当前时间与 <code>last_fill_time</code> 的差值计算出应该生成多少新令牌，并加到 <code>current_tokens</code> 中，但不要超过桶容量。</li><li>如果 <code>current_tokens &gt;= 1</code>，则 <code>current_tokens--</code> 并处理请求。</li><li>否则，拒绝请求。</li></ol><h3 id="总结比较" tabindex="-1">总结比较： <a class="header-anchor" href="#总结比较" aria-hidden="true">#</a></h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">漏斗模式 (Leaky Bucket)</th><th style="text-align:left;">令牌桶模式 (Token Bucket)</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>输出速率</strong></td><td style="text-align:left;">恒定，平滑，削峰填谷</td><td style="text-align:left;">平均速率恒定，但允许短时间的突发流量</td></tr><tr><td style="text-align:left;"><strong>处理突发</strong></td><td style="text-align:left;">不支持，会丢弃或排队等待</td><td style="text-align:left;">支持，允许在高令牌数时快速处理</td></tr><tr><td style="text-align:left;"><strong>弹性</strong></td><td style="text-align:left;">较低，严格控制速率</td><td style="text-align:left;">较高，可以应对临时流量高峰</td></tr><tr><td style="text-align:left;"><strong>主要用途</strong></td><td style="text-align:left;">网络流量整形、消息队列平滑发送</td><td style="text-align:left;">API限流、服务QPS限制、流量整形</td></tr><tr><td style="text-align:left;"><strong>丢弃/排队</strong></td><td style="text-align:left;">桶满时可能丢弃新请求或让其排队</td><td style="text-align:left;">桶无令牌时丢弃请求或让其等待</td></tr></tbody></table><p>在Web开发中，<strong>令牌桶模式通常更受欢迎，尤其是在API网关、微服务限流等场景</strong>。因为它能在限制平均访问速率的同时，允许一定程度的突发流量，这更符合大多数Web服务的实际需求。而漏斗模式则在对流量输出平滑性有严格要求的场景下表现更佳。</p><p>理解这两种模式能帮助你在设计高并发、高可用系统时，有效地进行流量控制和资源管理。</p>',24),o=[s];function i(a,g,d,c,p,_){return l(),e("div",null,o)}const u=t(r,[["render",i]]);export{f as __pageData,u as default};
